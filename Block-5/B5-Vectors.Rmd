# Vectors

```{r include=FALSE}
library(Znotes)
```

In this course, we adopt the convention that a vector is a  **column** of numbers, like this one we're naming $\vec{v}$:

$$\vec{v} \equiv  \left(\begin{array}{c}3\\2\\6\end{array}\right)$$ 
Vectors are so important in mathematics and science that they are used to *represent* all  sorts of things. For example, it's legitimate to  say that  *force* is a vector. Of course this doesn't mean that force is a column of numbers. Force  is a physical impetus. It's represented as a vector because every force has both a magnitude--which we'll later call "length"--and a direction. Similarly, *velocity* is a vector because it has a direction and a magnitude. (The word  "speed" refers to the magnitude alone, without the direction.)

Some things that are vectors actually start out as a series of numbers. For instance, a variable in a data frame is literally a  column of numbers. As  you'll see later, it's incredibly  powerful to be able to think about a data variable as having a direction  and a magnitude, even if it isn't obvious at this point what those would be.  

In Block 1, you saw  that *functions* can  be represented for many purposes as a table of data. In  this sense, a function is also a vector: the column  of numbers from the table. Like variables, it turns out  to  be very useful to  think of functions as having a direction  and a magnitude. 

```{r  echo=FALSE, fig.cap="Representing vectors graphically.",  out.width = "50%"}
knitr::include_graphics("www/4vectors.png")
```

The representation  of vectors graphically, as arrows, fits naturally with the idea of a vector as a magnitude and a direction. The magnitude is shown by the *length* of the vector, and the direction literally by the direction  of the arrow.

What's unfortunate about the graphical presentation of vectors as arrows is the suggestion that a vector has not only  a magnitude and  direction,  but also  a "place."  For instance, the vector labeled (a) in  the diagram is obviously to the left of (b). You may have to force yourself to remember that "place" is not  a property of vectors. Wherever you might choose to place  the arrow (a), it  would be  the same vector (so long  as  you don't change it's length or direction).

The  human capacity to think about vectors easily is pretty much limited to vectors in two- or three-dimensions. Force and velocity are both vectors in three dimensions. But those vectors that arise from columns of data or functions can often have more than three numbers. Geometrically, this corresponds to a direction in a space with more than three dimensions. Many otherwise well  educated people will claim that a space with more than three dimensions cannot exist. It's OK if you want to  think of  high-dimensional spaces as  a kind of metaphor, although a physicist  working with space-time or with string theory  might argue with you.

What makes it possible to use vectors in high-dimensional space for practical problems is that the geometry of vectors has an exact interpretation as arithmetic  (and *vice versa*). In  this Daily Digital, you'll  work with  both geometric vectors and numerical vectors--but keep in  the back of your mind that these are merely two different  modes of  representation of the same mathematical abstraction.

## Vectors, arithmetically

Computers are the technological innovation  that makes it possible for us to work with  high-dimensional vectors.  

A starting  point  is creating a vector on the computer. In  some sense this a vector is just a collection  of numbers, but it's helpful  to  be disciplined  and  remember that, for our purposes, a  vector is  a **column** of numbers. R knows about such columns and will  handle them appropriately.

One way to create a column vector is with  the  `rbind()` function.

use the  `rbind()` function applied to individual arguments. Here,  for instance,  is a command that makes a three-dimensional vector we are calling `b`.

```{r}
b <- rbind(4, -2, 6)
b
```

Notice that in  printing out a  vector, R  includes a series of indices  (e.g. `[1,]` or `[3,]`) to help the reader identify the location  of any element in  the vector. It also  prints a header (`[,1]`) which  is helpful later when we work with  collections of vectors.

## Matrix

You are going to hear the word "matrix" a lot.  Later in  this tutorial we will use the term "matrix multiplication." A matrix is a collection  of  vectors, all of the same dimension. We'll get to them  in good time.  

## Scalar multiplication

You  can multiply a vector times  a  number. The result is a new vector with exactly the  same direction as  the original, but with  a different length. The  arithmetic  is  very  simple: do ordinary multiplication  of the number by  each of the elements  of the  vector. Examples:

$$2 \left(\begin{array}{c}4\\7\end{array}\right) = \left(\begin{array}{c}8\\14\end{array}\right)$$

This  simple  multiplication is called "scalar multiplication" for two  reasons:

1. The result is to "scale" the vector, in the sense of a  "scale  model",  that  is, to make the vector bigger or smaller.
2. There is another important form of vector  arithmetic called "matrix multiplication." By  saying  "scalar multiplication,"  we avoid the  confusion  that might arise if  we  used "multiplication" alone.

In R, scalar multiplication of a vector is  done with `*`, just like ordinary multiplication   with numbers:

```{r echo=TRUE}
b <- rbind(4, -2, 6)
2.3 * b
```

::: {.example data-latex=""}
In a `r sandbox_link()`, Write  the  R  code to create a vector named `w` with  components 4, -1,  and -3.5.  Then scalar multiply `w` by 6.3.

```{r echo=TRUE, eval=FALSE} 
w <- _______
6.3 _______ w
```

<details>
<summary>Solution</summary>
```{r}
w <- rbind(4,  -1,  -3.5)
6.3 *  w
```
</details>
:::

## Dot product and `%*%`

Now to  introduce  a new R arithmetic function, written `%*%`. This symbol is pronounced "matrix multiply."  In traditional mathematical notation, matrix multiplication is indicated by putting the two quantities next to one another, like this: $\vec{\mathbf m}^T \vec{\mathbf x}$, or sometimes with a dot $\vec{\mathbf m}T\cdot \vec{\mathbf x}$. The superscript $^T$ means "transpose." For us, this  is merely a  book-keeping convention.

The operation `%*%` will do several  different types  of  arithmetic  with  vectors. The one we will work with here is  called  a *dot product*.  (There are  also "matrix products"  and "outer products".)

The R notation for a dot product very  much echoes the  traditional matrix  notation,  at least  with  respect to $^T$.  We'll  illustrate by creating  two vectors `u`  and `v` and then calculating their dot  product.

```{r}
u <- rbind(6, -3,  7)
v <- rbind(2,  1,  3)
t(u) %*%  v
```

Notice  that the  output  of a dot product is  a single number: a scalar. (R prints the output as if the scalar were  a vector in one-dimension.)

Arithmetically, the dot product is calculated by multiplying the corresponding components in the two vectors  (e.g.  $6  \times 2$ and  $-3 \times 1$ and  $7 \times 3$) and adding up the  result. You can see why the dot product always involves two vectors with the same number of elements.

The R `t()` function corresponds to  the mathematical notation for the transpose: $^T$. So `t(u)` would be written, mathematically, as $\vec{u}^T$. The  purpose of `t()` is to turn columns (like our vector `u`) into rows,  and vice versa.  If you  like,  try the command `t(u)` in  the sandbox to see how it  is printed.

For us,  the purpose of writing `t(u)` is  to signal  to  the `%*%`  matrix multiplication  operation that we want a particular operation: the dot product.

The  dot product always involves the transpose of a column vector on  the left side of  `%*%`  and a column vector on  the right side.

You  can  also  write a command  `u %*% t(v)`,  but  this is not a  dot product. It is  called  an "outer product" and we will not need it in this course. Try it out in  the sandbox.

::: {.caution}
The ***dot product*** and the ***outer product*** are written in very similar ways but produce completely different results. We won't have much use for outer products in this course, but you should be aware what they look like so that you can diagnose the problem if your attempt at a dot product goes wrong.

**Dot products**
```{r}
t(u) %*% v
t(v) %*% u
```

**Outer product**
```{r}
u %*% t(v)
v %*% t(u)
```
:::


## Vector lengths

For  a vector $\vec{v}$, the  length is denoted $|| \vec{v} ||$. Vector length can  be measured with  a ruler ...  so long as you have physical access to  the vector. But often, all we have  is the numerical representation. So, we use arithmetic---the dot product---to calculate vector length: 
$$|| \vec{v}  || \equiv \sqrt{\ \vec{v}^T \cdot \vec{v}}$$

::: {.example data-latex=""}
Consider the two vectors 
$$\vec{u} \equiv \left(\begin{array}{c}3\\4\end{array}\right) \  \  \ \mbox{and}  \ \ \ \vec{w} \equiv \left(\begin{array}{c}1\\1\\1\\1\end{array}\right)
$$

The length of $\vec{u}$ is $|| \vec{u} || = \sqrt{\strut 3^2 + 4^2} = \sqrt{\strut 25} = 5$.

The length of $\vec{w}$ is $|| \vec{w} || = \sqrt{\strut 1^2 + 1^2 + 1^2 + 1^2} = \sqrt{\strut 4} = 2$.

Using a `r sandbox_link()`, use R commands to create the vectors $\vec{u}$ and $\vec{w}$ and find their lengths using the `dot-product operator`%*%` operator.

```{r eval=FALSE}
u <- rbind( ____ )
# length of u
sqrt( ____ %*% ____ )

v <- rbind( ______ )
# length of v
sqrt( ____ %*% ____ )
```

<details>
<summary>Solution</summary>
```{r}
u <- rbind(3, 4)
sqrt(t(u) %*% u)
w <- rbind(1, 1, 1, 1)
sqrt(t(w) %*% w)
```
</details>

## Angles

Any two vectors of the same dimension have a distinct ***angle*** between them. This is easily seen for two-dimensional vectors. Draw two vectors on a sheet of paper. Since vectors have only two properties, length and direction, in your mind's eye you can pick up one of the vectors and relocate its "tail" to meet the tail of the other vector. The letters **L** and **V** illustrate the connection between the two vectors as do the characters **^**, **>**, and **<**. The angle for **L** is roughly 90 degrees, the other characters are made of vectors with acute angles (that is, less than 90 degrees). The two vectors **_** and **/**, when brought together as **_/** subtend an obtuse angle.

In describing the angle between two vectors, we always measure the short way round. So angles between vectors are always between 0 and 180 degrees. Any larger angle, say 260 degrees, will be identified with its circular complement: 100 degrees is the complement of a 260 degree angle.

A worthwhile experiment is to pick up two pencils pointing in different directions. Place the eraser ends together, pinched between thumb and forefinger. You can point the whole rigid assembly in any direction you like. The angle between them will remain the same. 

Place a card on top of the pencils, slipping it between your pressed fingers to hold it tightly in place. The card is another kind of geometrical object: a planar surface. The orientation of two vectors together determine the orientation of the surface. This simple fact will be extremely important later on.

You could replace the pencils with line segments drawn on the card underneath each pencil. Now you have the angle readily measurable in two dimensions. The angle between two vectors in three dimensions is the same as the angle drawn on the two-dimension surface that rests on the vectors.

Notice that you can also lay a card along a *single* vector. What's different here is that you can roll the card around the pencil; there are many different orientations for such a card even while the vector stays fixed. So a single fixed vector does not determine uniquely the orientation of the planar surface in which the two vectors can reside. But with two fixed vectors, there is only one such surface.

A pencil is a physical object that does a good job representing a vector in three dimensional space. Three-dimensional space is all around us and it's easy---indeed, inevitable---to situate a pencil in it. We have no such physical access to 4-dimensional space or higher-dimensional spaces. Instead of a physical representation, we need to rely on a mathematical one: a column of numbers. And we can't use a protractor to measure the angle between two vectors in 4- or higher-dimensional space. Instead, we calculate the angle using arithmetic. But to define the numerical process for calculating an angle, we need to make sure that the result follows the familiar conventions for angles, specifically that they be between 0 and 180 degrees, that the angle between two vectors with the same orientation is 0, and that the angle between two opposite-pointing vectors is 180 degrees.

The arithmetic formula for computing the angle between two vectors is simple. Or, rather, it's simple if we allow ourselves to calculate the cosine of the angle rather than the angle $\theta$ itself. The underlying quantity can be calculated using dot products: 
$$\cos(\theta) \equiv \frac{\vec{v}^T \cdot \vec{w}}{\sqrt{\strut (\vec{v}^T\cdot \vec{v})(\vec{w}^T\cdot \vec{w})}}$$

If you insist on knowing $\theta$ rather than $\cos(\theta)$, there is a function that will do the conversion show in in Figure \@ref(fig:cosine-conversion).

```{r cosine-conversion, echo=FALSE, fig.cap="The $\arccos()$ function converts $\cos(\theta)$ to $\theta$."}
slice_plot(180*acos(theta)/pi ~ theta, domain(theta=-1:1), npts=300) %>%
    gf_labs(x="cos(theta)", y = "theta (degrees)") %>%
    gf_refine(scale_y_continuous(breaks=c(0,15, 30,45,60,75, 90,105, 120,135,150,165, 180)))
```

## Orthogonality

Two vectors are said to be ***orthogonal*** when the angle between them is 90 degrees. In everyday speech we call a 90 degree angle a "right angle." The word "orthogonal" is really just a literal translation of "right angle." The syllable "gon" indicates an angle, as in the five-angled pentagon or six angled hexagon. "Ortho" means "right" or "correct," as in "orthodox" (right beliefs) or "orthodontics" (right teeth) or "orthopedic" (right feet).

Two vectors are at right angles---we prefer "orthogonal" since "right" has many meanings not related to angles---when the dot product between them is zero.

::: {.example data-latex=""}
Find a vector that's orthogonal to $(1,2)$. 

The arithmetic trick is to reverse the order of the components and put a minus sign in front of one of them, so $(-2, 1)$.

We can confirm the orthogonality by calculating the dot product: $(-2, 1)^T \cdot (1,2) = -2\times1 + 1 \times 2 = 0$.
:::

::: {.example data-latex=""}
Find a vector orthogonal to $(1,2,3)$.

We have a little more scope here. A simple approach is to insert a zero component in the new vector and then use the two-dimensional trick to fill in the remaining components.

For instance, starting with $(0, __, __)^T$ the only non-zero components of the dot product will involve the 2 and 3 of the original vector. So $(0, -3, 2)$ is orthogonal. Or, if we start with $(1,0,3)$ we would construct $(-3, 0, 1)$. 

In addition to the two vectors we constructed with the arithmetic trick, any vector that is a linear combination of those two vectors will also be orthogonal to $(1,2,3)$.
:::

## Exercises

`r insert_calcZ_exercise("XX.XX", "Of7QlW", "Exercises/snake-choose-ring.Rmd")`

`r insert_calcZ_exercise("XX.XX", "dwALW7", "Exercises/octopus-sell-mattress.Rmd")`

`r insert_calcZ_exercise("XX.XX", "xuENab", "Exercises/rhinosaurus-break-knob.Rmd")`

`r insert_calcZ_exercise("XX.XX", "MBTGQt", "Exercises/duck-do-pantry.Rmd")`

`r insert_calcZ_exercise("XX.XX", "Q2ars0", "Exercises/squirrel-hear-glasses.Rmd")`

`r insert_calcZ_exercise("XX.XX", "OoPatc", "Exercises/dog-let-coat.Rmd")`

`r insert_calcZ_exercise("XX.XX", "Gw42pX", "Exercises/beech-iron-clock.Rmd")`

`r insert_calcZ_exercise("XX.XX", "1Jxboc", "Exercises/snake-ride-glasses.Rmd")`

`r insert_calcZ_exercise("XX.XX", "N98zli", "Exercises/falcon-begin-door.Rmd")`

## Outline

a. Dual representations of vectors.
    i. arithmetic: a vector is a column of numbers.
    ii. graphically: an arrow.
        a.  direction and a magnitude.
        b. Position isn't a feature. You can draw the vector whereever is convenient so long as you keep the direction and magnitude.
b. A vector is embedded ("lives in") a space. The dimension of that space is the count of rows in the column of numbers (arithmetic representation). Graphically, the dimension must be figured out in context, since all arrows look the same.
b. Scalar multiplication and addition in both representations.
c. Dot product
    i. takes two vectors, produces a *number*
    ii. arithmetical operation: componentwise multiply then add
    iii. interpreting graphically
        a. proportional to (cosine of) angle between vectors
d. Length of a vector
    i. arithmetically: pythagorus
    ii. arithmetically: sqruare root of dot product with itself
    iii. graphically: ruler.

```{r}
gvec(from=c(-2,3), to=c(4,4), color="red") %>%
graph_paper(xticks=-5:5, yticks=-5:5) %>%
    gvec(from=c(0,0), to=c(-2,3))
```
