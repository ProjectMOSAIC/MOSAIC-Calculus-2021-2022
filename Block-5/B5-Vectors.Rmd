# Linear objects

```{r include=FALSE}
library(Znotes)
```

Until now, our presentation of calculus has featured functions, sometimes expressed as formulas involving combinations of the basic modeling functions, sometimes generated directly from data by smoothing or splines. Now we turn to a new framework for expressing functions, the inputs on which they operate, and the kind of outputs they generate.

This framework is central to technical work in a huge range of fields. The usual name given to it by mathematicians is ***linear algebra***, although only the word "linear" conveys useful information about the subject. The physicists developing the first workable quantum theory called it ***matrix mechanics***. The framework is fundamental to scientific computation and is often the approach of choice even to non-linear problems. Application of the framework to problems of information access was the spark the ignited the modern era of search engines. 

Although the words "algebra" and "quantum" may suggest that conceptual difficulties are in store, in fact human intuition is well suited to establishing a useful understanding. 

We will introduce the framework in two different but equivalent forms. The ***geometric form*** is readily grasped by many students, even those with modest mathematical background. The geometry would have been easily grasped by the mathematicians of antiquity, who might even have regarded it as so trivial to be beneath their notice. They also could not possibly have understood the many important applications of the form which became apparent only in the last half of the 20th century with the emergence of statistics, data science, and computing generally. It can fairly be said that some of the most important developments in computer technology stem from algorithms developed from geometric properties of the form.

The other, equivalent way of describing the mathematics is via ***simple arithmetic and numbers***. This form is lacks the concreteness and visibility of the geometric approach, but more than makes up for this by the ways it makes the mathematics amenable to exact computation and to extending the applications in ways that transcend the limitations of our human, geometrical intuition.

## Vectors

A vector is a mathematical idea that is deeply rooted in everyday physical experience. A vector is simply an object consisting only of  ***length*** and ***direction***. 

A pencil is a good physical metaphor for a vector, but a pencil has other, non-vector qualities such as diameter, color, and an eraser. And, being a physical object, a pencil always has position: the place it's at.

```{r two-vectors-pencils, echo=FALSE, fig.cap="Three pencils, but just two vectors. The yellow and blue pencils have the same length and direction, so they are exactly the same vector. Pencils have position, but vectors don't. The green pencil shares the same direction, but it has a different length, so it is a different vector from the blue/yellow vector."}
knitr::include_graphics("www/pencils/two-vectors.png")
```

Of course, a pencil has a tip and a tail; the eraser is affixed at the tail. 

```{r opposing-pencils, echo=FALSE, fig.cap="Two different vectors. They have the same length and are parallel, but they point in opposite directions."}
knitr::include_graphics("www/pencils/opposing-vectors.png")
```

Vectors are always ***embedded*** in a ***vector space***. Our physical stand-ins for vectors, the pencils, were photographed on a table top: a two-dimensional space. Naturally, the pencil-vectors are also embedded in our everyday three-dimensional space. The table-top can be thought of as a representation of a two-dimensional ***subspace*** of three-dimensional space.

Pencils are useful for visualizing vectors, but it's helpful to conceptualize them as a ***step*** or ***displacement*** in the sense of "step to the left" or "step forward." An individual vector is a step specific length in a particular direction. Much of the mathematics of vectors can be understood as constructing instructions for reaching a target: "take three and a half steps along the green vector, then turn and take two steps backwards along the yellow vector."

Vectors embedded in three-dimensional space are central to physics and engineering. Quantities such as force, acceleration, and velocity are properly represented not as simple numerical quantities but as vectors with ***magnitude*** (that is, length) and direction. A statement like, "the plane's velocity is 450 miles per hour to the north-north-west" is perfectly intelligible to most people, describing as it magnitude and direction. Note that the vector velocity can be understood without having to know where the plane is located; vectors have only the two qualities of magnitude and direction. Position is irrelevant to describing velocity, or, for that matter, force or acceleration.

The gradients that we studied with partial differentiation (Chapter `r Chaps$gradient`) are vectors. A gradient's direction points directly uphill from a given point; it's magnitude tells how steep the hill is at that point. 

Vectors are a practical tool in many situations such as relative motion. Consider the problem of finding an aircraft heading and speed to intercept another plane that's also moving. The US Navy training movie from the 1950s shows how such calculations used to be done with paper and pencil.

<iframe width="560" height="315" src="https://www.youtube.com/embed/j197C0XuNUA?start=20" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Nowadays such relative motion calculations are computerized. You may well wonder how the computer is able to represent vectors, since pencils aren't part of computer hardware. The answer is disappointingly simple: the properties of direction and magnitude can also be represented by a set of numbers. Two numbers will do for a vector embedded in two-dimensional space, three for a vector embedded in three-dimensions.

Representing a vector as a set of numbers requires the imposition of a framework: a coordinate system. In Figure \@ref(fig:vector-graph-paper), the vector (that is, the green pencil) has been placed in a coordinate system. Usually you would expect there to be labels for each of the coordinate lines, but this labelling is not necessarily to show a vector even if it is needed to specify a *position*. The two coordinates to be assigned to the vector are the difference between the tip and the tail. In the figure, there are 20 units horizontally and 16 units vertically, so the vector is $(20, 16)$. 

```{r vector-graph-paper, echo=FALSE, fig.cap="Representing a vector as a set of numbers requires reference to a coordinate system, shown here as graph paper."}
knitr::include_graphics("www/pencils/graph-paper.png")
```

By convention, when we write a vector as a set of coordinate numbers, we write the numbers in a ***column***. For instance, the vector in Figure \@ref(fig:vector-graph-paper), which we'll call $\overset{\longrightarrow}{\text{green}}$, would be written:

$$\overset{\longrightarrow}{\text{green}} \equiv \left[\begin{array}{c}20\\16\end{array}\right]$$
Such notation is intended for a human reader, perhaps clearly to distinguish a vector from a coordinate description of a position such as $(20,16)$. It's also useful to carry over the idea of "this is a column" in computer software, by including into the computer data structure connecting the numbers themselves---20 and 16 here---to a description of the "shape" of the vectors. By convention we would say that $\left[\begin{array}{c}20\\16\end{array}\right]$ has a $2 \times 1$ shape, which will be printed out as 2 rows in one column. A vector like velocity will have three numerical components, that is
$$\vec{v} = \left[\begin{array}{c}v_x\\v_y\\v_z\end{array}\right]\ .$$ Each of these components might be a function of time, so $$\partial_t \vec{v}(t) = \left[\begin{array}{c}\partial_t v_x(t)\\\partial_t v_y(t)\\\partial_t v_z(t)\end{array}\right] = \vec{a(t)}\ ,$$
where $\vec{a}(t)$ is the vector acceleration. 


The numerical representation of vectors is convenient when we need to perform mathematical operations on vectors such as addition, subtraction, reversal, and scaling. For instance, if an object with velocity vector $\vec{v}$ is subjected to a force vector $\vec{f}$, the velocity vector will change over time: $$\partial_t \vec{v} = \frac{1}{m}\vec{f}$$ (where $m$ is the mass of the object). 

Concretely, the above equation can be seen as shorthand for the description of the derivative of **three functions**, one each for the $x$, $y$, and $z$ components of $\vec{v}$, that is:
$$\partial_t v_x(t) = f_x/m\\
\partial_t v_y(t) = f_y/m\\
\partial_t v_z(t) = f_z/m\ .$$
We can apply numerical techniques such as integration to each of the components, for instance to find out what the velocity will be at some future time.

The numerical representation of vectors is also the way that most people can understand a tremendously important generalization of vectors to something that will at first seem absurdly abstract: 4-dimensional space, 5-dimensional space, and on up. In general: $n$-dimensional space.


## The n^th^ dimension

Living as we do in a palpably three-dimensional space, and being part of a species whose senses and brains developed in three dimensions, it's hard and maybe even impossible to get a grasp on what higher-dimensional spaces would be like.

A lovely 1884 book, *[Flatland](https://en.wikipedia.org/wiki/Flatland)*  features the inhabitants of a two-dimensional world. The central character, Square, receives a visitor, Sphere, from the three-dimensional world in which Flatland is embedded. Only with difficulty can Square assemble a conception of Sphere from the appearing, growing, and vanishing of Sphere's intersection with the flat world. Square's attempt to convince Sphere that his three-dimensional world might be embedded in a four-dimensional one leads to rejection and disgrace.  

<iframe width="560" height="315" src="https://www.youtube.com/embed/yBbZmwROv84" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

But even if the spatial extent of higher dimensions is not accessible, the one-dimensional vector inhabitants of any such space can be readily perceived and constructed as alist of numbers. With this device, allow us to introduce vectors from 4, 5, and 6 dimensions, and even $n$ dimensional space.

$$\left[\begin{array}{r}6.4\\3.0\\-2.5\\17.3\end{array}\right]\ \ \ \left[\begin{array}{r}-14.2\\-6.9\\18.0\\1.5\\-0.3\end{array}\right]\ \ \ \left[\begin{array}{r}5.3\\-9.6\\84.1\\5.7\\-11.3\\4.8\end{array}\right]\ \ \ \cdots\ \ \ \left.\left[\begin{array}{r}7.2\\-4.4\\0.6\\-4.1\\4.7\\\vdots\ \ \\-7.3\\8.3\end{array}\right]\right\} n$$

Sensible people may consider it mathematical tomfoolery to promote of an everyday column of numbers into a vector in high-dimensional space, but there is a good reason. It encourages us to think about the arithmetic we are about to do on vectors in terms of familiar geometrical concepts: lengths, angles, alignment, and so on. Perhaps unexpectedly, it also guides us to think about data---which consists of columns of numbers in a data frame---using our powerful geometrical intuition.

## Geometry as arithmetic

Computers are the technological innovation  that makes it possible for us to work with  high-dimensional vectors.  

A starting  point  is creating a vector on the computer. In  some sense this a vector is just a collection  of numbers, but it's helpful  to  be disciplined  and  remember that, for our purposes, a  vector is  a **column** of numbers. R knows about such columns and will  handle them appropriately.

One way to create a column vector is with  the  `rbind()` function.

use the  `rbind()` function applied to individual arguments. Here,  for instance,  is a command that makes a three-dimensional vector we are calling `b`.

```{r}
b <- rbind(4, -2, 6)
b
```

Notice that in  printing out a  vector, R  includes a series of indices  (e.g. `[1,]` or `[3,]`) to help the reader identify the location  of any element in  the vector. It also  prints a header (`[,1]`) which  is helpful later when we work with  collections of vectors.

## Matrix

You are going to hear the word "matrix" a lot.  Later in  this tutorial we will use the term "matrix multiplication." A matrix is a collection  of  vectors, all of the same dimension. We'll get to them  in good time.  

## Scalar multiplication

You  can multiply a vector times  a  number. The result is a new vector with exactly the  same direction as  the original, but with  a different length. The  arithmetic  is  very  simple: do ordinary multiplication  of the number by  each of the elements  of the  vector. Examples:

$$2 \left(\begin{array}{c}4\\7\end{array}\right) = \left(\begin{array}{c}8\\14\end{array}\right)$$

This  simple  multiplication is called "scalar multiplication" for two  reasons:

1. The result is to "scale" the vector, in the sense of a  "scale  model",  that  is, to make the vector bigger or smaller.
2. There is another important form of vector  arithmetic called "matrix multiplication." By  saying  "scalar multiplication,"  we avoid the  confusion  that might arise if  we  used "multiplication" alone.

In R, scalar multiplication of a vector is  done with `*`, just like ordinary multiplication   with numbers:

```{r echo=TRUE}
b <- rbind(4, -2, 6)
2.3 * b
```

::: {.example data-latex=""}
In a `r sandbox_link()`, Write  the  R  code to create a vector named `w` with  components 4, -1,  and -3.5.  Then scalar multiply `w` by 6.3.

```{r echo=TRUE, eval=FALSE} 
w <- _______
6.3 _______ w
```

<details>
<summary>Solution</summary>
```{r}
w <- rbind(4,  -1,  -3.5)
6.3 *  w
```
</details>
:::

## Dot product and `%*%`

Now to  introduce  a new R arithmetic function, written `%*%`. This symbol is pronounced "matrix multiply."  In traditional mathematical notation, matrix multiplication is indicated by putting the two quantities next to one another, like this: $\vec{\mathbf m}^T \vec{\mathbf x}$, or sometimes with a dot $\vec{\mathbf m}T\cdot \vec{\mathbf x}$. The superscript $^T$ means "transpose." For us, this  is merely a  book-keeping convention.

The operation `%*%` will do several  different types  of  arithmetic  with  vectors. The one we will work with here is  called  a *dot product*.  (There are  also "matrix products"  and "outer products".)

The R notation for a dot product very  much echoes the  traditional matrix  notation,  at least  with  respect to $^T$.  We'll  illustrate by creating  two vectors `u`  and `v` and then calculating their dot  product.

```{r}
u <- rbind(6, -3,  7)
v <- rbind(2,  1,  3)
t(u) %*%  v
```

Notice  that the  output  of a dot product is  a single number: a scalar. (R prints the output as if the scalar were  a vector in one-dimension.)

Arithmetically, the dot product is calculated by multiplying the corresponding components in the two vectors  (e.g.  $6  \times 2$ and  $-3 \times 1$ and  $7 \times 3$) and adding up the  result. You can see why the dot product always involves two vectors with the same number of elements.

The R `t()` function corresponds to  the mathematical notation for the transpose: $^T$. So `t(u)` would be written, mathematically, as $\vec{u}^T$. The  purpose of `t()` is to turn columns (like our vector `u`) into rows,  and vice versa.  If you  like,  try the command `t(u)` in  the sandbox to see how it  is printed.

For us,  the purpose of writing `t(u)` is  to signal  to  the `%*%`  matrix multiplication  operation that we want a particular operation: the dot product.

The  dot product always involves the transpose of a column vector on  the left side of  `%*%`  and a column vector on  the right side.

You  can  also  write a command  `u %*% t(v)`,  but  this is not a  dot product. It is  called  an "outer product" and we will not need it in this course. Try it out in  the sandbox.

::: {.caution}
The ***dot product*** and the ***outer product*** are written in very similar ways but produce completely different results. We won't have much use for outer products in this course, but you should be aware what they look like so that you can diagnose the problem if your attempt at a dot product goes wrong.

**Dot products**
```{r}
t(u) %*% v
t(v) %*% u
```

**Outer product**
```{r}
u %*% t(v)
v %*% t(u)
```
:::


## Vector lengths

For  a vector $\vec{v}$, the  length is denoted $|| \vec{v} ||$. Vector length can  be measured with  a ruler ...  so long as you have physical access to  the vector. But often, all we have  is the numerical representation. So, we use arithmetic---the dot product---to calculate vector length: 
$$|| \vec{v}  || \equiv \sqrt{\ \vec{v}^T \cdot \vec{v}}$$

::: {.example data-latex=""}
Consider the two vectors 
$$\vec{u} \equiv \left(\begin{array}{c}3\\4\end{array}\right) \  \  \ \mbox{and}  \ \ \ \vec{w} \equiv \left(\begin{array}{c}1\\1\\1\\1\end{array}\right)
$$

The length of $\vec{u}$ is $|| \vec{u} || = \sqrt{\strut 3^2 + 4^2} = \sqrt{\strut 25} = 5$.

The length of $\vec{w}$ is $|| \vec{w} || = \sqrt{\strut 1^2 + 1^2 + 1^2 + 1^2} = \sqrt{\strut 4} = 2$.

Using a `r sandbox_link()`, use R commands to create the vectors $\vec{u}$ and $\vec{w}$ and find their lengths using the `dot-product operator`%*%` operator.

```{r eval=FALSE}
u <- rbind( ____ )
# length of u
sqrt( ____ %*% ____ )

v <- rbind( ______ )
# length of v
sqrt( ____ %*% ____ )
```

<details>
<summary>Solution</summary>
```{r}
u <- rbind(3, 4)
sqrt(t(u) %*% u)
w <- rbind(1, 1, 1, 1)
sqrt(t(w) %*% w)
```
</details>

## Angles

Any two vectors of the same dimension have a distinct ***angle*** between them. This is easily seen for two-dimensional vectors. Draw two vectors on a sheet of paper. Since vectors have only two properties, length and direction, in your mind's eye you can pick up one of the vectors and relocate its "tail" to meet the tail of the other vector. The letters **L** and **V** illustrate the connection between the two vectors as do the characters **^**, **>**, and **<**. The angle for **L** is roughly 90 degrees, the other characters are made of vectors with acute angles (that is, less than 90 degrees). The two vectors **_** and **/**, when brought together as **_/** subtend an obtuse angle.

In describing the angle between two vectors, we always measure the short way round. So angles between vectors are always between 0 and 180 degrees. Any larger angle, say 260 degrees, will be identified with its circular complement: 100 degrees is the complement of a 260 degree angle.

A worthwhile experiment is to pick up two pencils pointing in different directions. Place the eraser ends together, pinched between thumb and forefinger. You can point the whole rigid assembly in any direction you like. The angle between them will remain the same. 

Place a card on top of the pencils, slipping it between your pressed fingers to hold it tightly in place. The card is another kind of geometrical object: a planar surface. The orientation of two vectors together determine the orientation of the surface. This simple fact will be extremely important later on.

You could replace the pencils with line segments drawn on the card underneath each pencil. Now you have the angle readily measurable in two dimensions. The angle between two vectors in three dimensions is the same as the angle drawn on the two-dimension surface that rests on the vectors.

Notice that you can also lay a card along a *single* vector. What's different here is that you can roll the card around the pencil; there are many different orientations for such a card even while the vector stays fixed. So a single fixed vector does not determine uniquely the orientation of the planar surface in which the two vectors can reside. But with two fixed vectors, there is only one such surface.

A pencil is a physical object that does a good job representing a vector in three dimensional space. Three-dimensional space is all around us and it's easy---indeed, inevitable---to situate a pencil in it. We have no such physical access to 4-dimensional space or higher-dimensional spaces. Instead of a physical representation, we need to rely on a mathematical one: a column of numbers. And we can't use a protractor to measure the angle between two vectors in 4- or higher-dimensional space. Instead, we calculate the angle using arithmetic. But to define the numerical process for calculating an angle, we need to make sure that the result follows the familiar conventions for angles, specifically that they be between 0 and 180 degrees, that the angle between two vectors with the same orientation is 0, and that the angle between two opposite-pointing vectors is 180 degrees.

The arithmetic formula for computing the angle between two vectors is simple. Or, rather, it's simple if we allow ourselves to calculate the cosine of the angle rather than the angle $\theta$ itself. The underlying quantity can be calculated using dot products: 
$$\cos(\theta) \equiv \frac{\vec{v}^T \cdot \vec{w}}{\sqrt{\strut (\vec{v}^T\cdot \vec{v})(\vec{w}^T\cdot \vec{w})}}$$

If you insist on knowing $\theta$ rather than $\cos(\theta)$, there is a function that will do the conversion show in in Figure \@ref(fig:cosine-conversion).

```{r cosine-conversion, echo=FALSE, fig.cap="The $\\arccos()$ function converts $\\cos(\\theta)$ to $\\theta$."}
slice_plot(180*acos(theta)/pi ~ theta, domain(theta=-1:1), npts=300) %>%
    gf_labs(x="cos(theta)", y = "theta (degrees)") %>%
    gf_refine(scale_y_continuous(breaks=c(0,15, 30,45,60,75, 90,105, 120,135,150,165, 180)))
```

## Orthogonality

Two vectors are said to be ***orthogonal*** when the angle between them is 90 degrees. In everyday speech we call a 90 degree angle a "right angle." The word "orthogonal" is really just a literal translation of "right angle." The syllable "gon" indicates an angle, as in the five-angled pentagon or six angled hexagon. "Ortho" means "right" or "correct," as in "orthodox" (right beliefs) or "orthodontics" (right teeth) or "orthopedic" (right feet).

Two vectors are at right angles---we prefer "orthogonal" since "right" has many meanings not related to angles---when the dot product between them is zero.

::: {.example data-latex=""}
Find a vector that's orthogonal to $(1,2)$. 

The arithmetic trick is to reverse the order of the components and put a minus sign in front of one of them, so $(-2, 1)$.

We can confirm the orthogonality by calculating the dot product: $(-2, 1)^T \cdot (1,2) = -2\times1 + 1 \times 2 = 0$.
:::

::: {.example data-latex=""}
Find a vector orthogonal to $(1,2,3)$.

We have a little more scope here. A simple approach is to insert a zero component in the new vector and then use the two-dimensional trick to fill in the remaining components.

For instance, starting with $(0, __, __)^T$ the only non-zero components of the dot product will involve the 2 and 3 of the original vector. So $(0, -3, 2)$ is orthogonal. Or, if we start with $(1,0,3)$ we would construct $(-3, 0, 1)$. 

In addition to the two vectors we constructed with the arithmetic trick, any vector that is a linear combination of those two vectors will also be orthogonal to $(1,2,3)$.
:::

## Exercises

`r insert_calcZ_exercise("XX.XX", "Of7QlW", "Exercises/snake-choose-ring.Rmd")`

`r insert_calcZ_exercise("XX.XX", "dwALW7", "Exercises/octopus-sell-mattress.Rmd")`

`r insert_calcZ_exercise("XX.XX", "xuENab", "Exercises/rhinosaurus-break-knob.Rmd")`

`r insert_calcZ_exercise("XX.XX", "MBTGQt", "Exercises/duck-do-pantry.Rmd")`

`r insert_calcZ_exercise("XX.XX", "Q2ars0", "Exercises/squirrel-hear-glasses.Rmd")`

`r insert_calcZ_exercise("XX.XX", "OoPatc", "Exercises/dog-let-coat.Rmd")`

`r insert_calcZ_exercise("XX.XX", "Gw42pX", "Exercises/beech-iron-clock.Rmd")`

`r insert_calcZ_exercise("XX.XX", "1Jxboc", "Exercises/snake-ride-glasses.Rmd")`

`r insert_calcZ_exercise("XX.XX", "N98zli", "Exercises/falcon-begin-door.Rmd")`

`r insert_calcZ_exercise("XX.XX", "PCfYDo", "Exercises/crocodile-talk-mattress.Rmd")`

`r insert_calcZ_exercise("XX.XX", "4QzeWP", "Exercises/cat-do-pants.Rmd")`

`r insert_calcZ_exercise("XX.XX", "5zmmBu", "Exercises/girl-send-scarf.Rmd")`

`r insert_calcZ_exercise("XX.XX", "7KJQQd", "Exercises/bear-fight-closet.Rmd")`

`r insert_calcZ_exercise("XX.XX", "k5u7hG", "Exercises/titmouse-stand-pantry.Rmd")`

## Outline

a. Dual representations of vectors.
    i. arithmetic: a vector is a column of numbers.
    ii. graphically: an arrow.
        a.  direction and a magnitude.
        b. Position isn't a feature. You can draw the vector whereever is convenient so long as you keep the direction and magnitude.
b. A vector is embedded ("lives in") a space. The dimension of that space is the count of rows in the column of numbers (arithmetic representation). Graphically, the dimension must be figured out in context, since all arrows look the same.
b. Scalar multiplication and addition in both representations.
c. Dot product
    i. takes two vectors, produces a *number*
    ii. arithmetical operation: componentwise multiply then add
    iii. interpreting graphically
        a. proportional to (cosine of) angle between vectors
d. Length of a vector
    i. arithmetically: pythagorus
    ii. arithmetically: sqruare root of dot product with itself
    iii. graphically: ruler.

```{r}
gvec(from=c(-2,3), to=c(4,4), color="red") %>%
graph_paper(xticks=-5:5, yticks=-5:5) %>%
    gvec(from=c(0,0), to=c(-2,3))
```
