## Flows on the line {#fixed-points}

<div style="float:right;">[![](www/icons/edit.png)](https://github.com/ProjectMOSAIC/MOSAIC-Calculus/blob/main/Block-6/B6-fixed-points.Rmd)</div>

::: {.underconstruction}
i. Classify fixed points as stable/unstable given the dynamics
i. Identify the dynamics of constant growth
i. Compute Euler solutions (format for expressing the system and the format of the result)
i. Analyze models in application contexts (for example Mayâ€™s Cows - a model of bistability in ecology)
i. Examples of linearization: Newton's Law of Cooling, Hooke's Law

[Last year's daily digitals](https://maa-statprep.shinyapps.io/142Z-DD-17) from DD-15 to about DD-20 
:::


```{r include=FALSE}
# Draw a one-dimensional phase space with arrows.
phase_line <- function(tilde, domain, narrows=15,
                       nix_dyn = FALSE, transform=I) {
  dyn <- makeFun(tilde)
  vname <- as.character(tilde[[3]])
  min_x <- min(domain[[1]])
  max_x <- max(domain[[1]])
  arrow_offset <- (max_x - min_x)/(3*narrows)
  arrow_x <- seq(min_x + arrow_offset, max_x - arrow_offset,
                 length=narrows)
  arrow_step <- dyn(arrow_x)
  max_len <- max(abs(arrow_step))
  arrow_step <- arrow_step/max_len
  arrow_step <- arrow_step * (max_x - min_x)/(1.0*narrows)
  ypts <- dyn(seq(min_x, max_x, length=200))
  yrange <- range(ypts) %>% extendrange()
  ymin <- pmin(0, min(yrange))
  ymax <- pmax(0, max(yrange))
  Arrows <- tibble(
    xstart = arrow_x,
    xend = arrow_x + sign(arrow_step)*transform(abs(arrow_step)),
    ystart = 0,
    yend = 0
  )
  
  if (nix_dyn) {
    P <- ggplot()
    the_theme <- theme_void()
  } else {
    P <- slice_plot(dyn(x) ~ x, domain)
    the_theme <- theme_minimal()
  }
  P %>%
    gf_lims(y = c(ymin, ymax)) %>%
    gf_hline(yintercept = ~ 0, color="gray", size=3, alpha=.5) %>%
    gf_segment(ystart + yend ~ xstart + xend, data = Arrows,
               color="blue", arrow = grid::arrow(end="last", length=unit(.6, "mm"), type="closed")) %>%
    gf_theme(the_theme) %>%
    gf_labs(y = paste0("d", vname, "/dt"))
}
```

The first chapter of this Block introduced a **framework** for modeling dynamics in continuous time: a dynamical state variables and dynamical functions giving the instantaneous change of each state variable as a function of the values of the state variables at that instant. The second chapter covered several methods of extracting a **solution** from the model, that is, a function of time for each of the state variables that is consistent with the differential equations. We looked at the solution in two ways: a **trajectory** in state space or a **time-series** graph.

Ultimately, our goal is to make models of real-world systems. These models can enhance our understanding of the mechanisms active in the real world. The models can also make predictions of various sorts. But you are not yet in a position to know what "various sorts" of predictions can mean or to see how to construct a dynamical model. To get you there, you'll need to learn about some general features of dynamical systems that allow us to think about them at a high level.

We start with the simplest sort of dynamical system: first-order systems, that is, ones with a single state variable. With a single variable, the state space is one-dimensional: the number line.

## The rules of the road

A physical analogy to give a better intuition about dynamics in a one-dimensional state space. We'll imagine that the state space is represented by a road, the instantaneous state being the location of a car along that road. 

On a real road, the motion of the car is set by the driver using 
the accelerator and brakes and constrained by other traffic and road conditions. In our state-space road, the velocity of the car is strictly dictated by an authoritarian government law: no exceptions. When the dictated speed is zero, the car will stand still and cannot start moving again. Ultimately, depending on the shape of the law, the car will head off to infinity or come to an eternal standstill. Two different cars can never collide on this road: if the cars are close together, they must be travelling at similar velocities. Cars can't pass one another in different directions. Passing requires that the two cars have opposite velocities: one positive and one negative.  If the mandated velocity at a point along the road is positive, every car that comes to that point must have the same positive velocity as it passes that point in the road.

The diagram in Figure \@ref(fig:road-rules) shows one possible format for describing the regulations for a road. The road is shown as a grey line. The red numbers are mile-markers alongside the road. The function graph shows the mandated speed at any point: you can read off the numerical value of the mandated speed on the y-axis. 

```{r road-rules, echo=FALSE, warning=FALSE}
f <- rfun( ~ x, seed=999)
xpts <- seq(-5,5,length=500)
offset <- mean(f(xpts))
scale <- sd(xpts)
speed  <- function(x) {
  raw <- 20*(f(x-10) - offset)/scale - 3* (x-9)
  # sign(raw)*sqrt(abs(raw))
  raw
}
Signs <- tibble::tibble(
  x = seq(0,20, by=2),
  y = 13,
  label = paste("Mile", x),
  angle = -sign(x - 9)*90
)
slice_plot(speed(x) ~ x, domain(x=c(0,20)), color="dodgerblue") %>%
  gf_text(y ~ x, label = ~ label, color="orange3", data = Signs, angle=~ angle) %>%
  gf_text(-10 ~ 1, label=c("West"), inherit=FALSE ) %>%
  gf_text(20 ~ 19, label=c("East"), inherit=FALSE ) %>%
  gf_hline(yintercept=0, color="black", alpha=0.3, size=3) %>%
  gf_labs(y = "Mandated speed (mph)", x="", title="County Road B") %>%
  gf_theme(panel.grid = element_blank(), axis.text.x = element_blank())
```

To better visualize the flow of traffic on the road, in Figure \@ref(fig:road-flow) we draw vectors on the road. The direction of each vector will be either east or west; the length of the vector gives the required speed for a car passing that point. 

```{r road-flow, echo=FALSE, fig.cap="The mandatory speed on the road."}
phase_line(speed(x) ~ x, domain(x=-2:20), nix_dyn=FALSE, 
           narrows=20, transform=sqrt) %>%
  gf_text(10 ~ -1, label=c("West"), inherit=FALSE, size=3) %>%
  gf_text(10 ~ 19, label=c("East"), inherit=FALSE, size=3, ) 
```

Cars arriving from the west are obliged to stop their journey at about $x=4$ where the arrows switch direction. Similarly, cars arriving from the east will be driving west, but their journey has a different destination,  mile 13,  where the velocity regulations change direction.  The easterners will be obliged to stop at the point where the left-facing arrows meet the right-facing ones. A car starting near mile 10 will be obliged to drive east but can go only to mile 13; a car starting at mile 7 will drive west until reaching mile 4.

This is a lot of detail in the shape of the dynamical function---I mean, the road regulations. So far as the consequences of the road regulations go, the situation is simpler: cars standing still at mile 4 or at mile 13, depending on where they started from.

Zooming in on the dynamics near mile 4 or 13 helps to show what happens as the cars approach those points. (Figure \@ref(fig:road-flow-zoom)) At either point, the action is similar. Cars coming from the west have to slow down as the arrows get smaller. Similarly for cars from the east. Where east meets west the cars are forced to a standstill; in order for the vectors to have different directions on the west end of the road than on the east end, the length of the vectors has to go to zero.

```{r road-flow-zoom, echo=FALSE, fig.cap="The road regulations near mile-markers 4 and 13. The fixed point is marked with a small dot.", fig.show="hold}
phase_line(speed(x) ~ x, domain(x=3.4:4.6), nix_dyn=FALSE, 
           narrows=20) %>% gf_labs(title="Near mile 4") %>%
  gf_point(0 ~ 4.043, color="magenta", size=1)
phase_line(speed(x) ~ x, domain(x=12.4:13.2), nix_dyn=FALSE, 
           narrows=20) %>% gf_labs(title="Near mile 13") %>%
  gf_point(0 ~ 12.762, color="magenta", size=1)
```

Such a point in the state space, where the flow arrows converge, is called a ***stable fixed point***. The "fixed" merely means that the cars come to a standstill. "Stable" means that all cars starting near the fixed point are heading toward that point. Many details of the dynamics near the fixed point have no role in the eventual outcome. For instance, the dynamical function near mile-marker 4 is concave down, while that at mile-marker 13 is concave up. In both cases the behavior of the system is the same: convergence at the stable fixed point.

::: {.takenote data-latex=""}
Newcomers understandably endow the car-on-road or bead-on-wire analogies to the state space of a first-order system with other familiar properties of the real world. For instance, a real-world wire has friction which needs to be overcome by applying a force. A real-world car has momentum which prolongs motion even after force has been applied. As you will see, a differential equation system that involves force and momentum requires a two-dimensional (or higher) state space.
:::

There is another fixed point on the road, but the behavior near it is different. Figure \@ref(fig:road-unstable-fp) zooms in on the situation near mile-marker 9. The outcome of the dynamics is very different than near miles 4 and 13. The fixed point near mile 9 is ***unstable***. This means that any cars starting near the fixed point will drive away. Slowly at first and then faster as they get farther from the fixed point.

```{r road-unstable-fp, echo=FALSE, fig.cap="An unstable fixed point in the road regulations."}
phase_line(speed(x) ~ x, domain(x=8:10), nix_dyn=FALSE, 
           narrows=20) %>% gf_labs(title="Near mile 9") %>%
  gf_point(0 ~ 9.05, color="magenta", size=1)
```

It's an interesting philosophical question what happens to a car starting exactly on the fixed point. Since the velocity vector there has zero length, the car must stand still. But if the car happens to move one jot away from the fixed point, it will start to speed up and move away from the fixed point.

The ideas of ***fixed points*** and their ***stability*** provides a much more concise description of the dynamical system: "There are stable fixed points near mile 4 and mile 13, as well as an unstable fixed point near mile 9."

It's worth pointing out a consequence of the mathematics of continuous functions: if a system with a continuous dynamical function has a region of state space with two different fixed points, there must be an unstable fixed point in between them. 

## Linearization

"Stable" and "unstable" provide a useful *qualitative* indication of the dynamics near a fixed point. An approximate *quantitative* solution can also be found.

Recall that any continuous function can be approximated locally by a low-order polynomial. For a function $g(x)$ with only one input,  "locally"  means "near $x^\star$," and  the polynomial will be $$g(x) \approx a + b \left[x-x^\star\right] + c \left[x-x^\star\right]^2 + \cdots$$
The coefficients $a, b, c, \cdots$ can be calculated from the value of the function and it's derivatives **at** $x^\star$:
$$a =  g(x^\star)\ \ \ \  b = \partial_x g(x^\star) \ \ \ \ c= \frac{1}{2} \partial_{xx} g(x^\star)\ \ \ \text{and so on.}$$
When $x^\star$ is a fixed point of the dynamics, then $g(x^\star) = 0$ so the approximating polynomial is
$$g(x) \approx b \left[x-x^\star\right] + c \left[x-x^\star\right]^2 + \cdots$$
If $x-x^\star$ is small enough, then the higher-power terms like $\left[x-x^\star\right]^2$ will be negligible and the approximation can be $$g(x) = \partial_x g(x^\star)\ \left[x-x^\star\right]\ .$$

To ***linearize a dynamical function*** near a fixed point requires two steps:

i. Solving task: Find a numerical value for the fixed point, that is, a value for $x^\star$ such that $g(x^\star) = 0$.
ii. Differentiating task: Evaluate the derivative $\partial_x g(x)$ at $x=x^\star$. (Another way of writing this is $\partial_x g(x)\left.{\Large\strut}\right|_{x=x^\star}$ or, more simply, $\partial_x g(x^\star)$.)

To find the solution to the differential equation near the fixed point requires additional a couple of additional steps:

iii. Translate the state variable $x$ into a new state variable $y = x - x^\star$. In terms of this new state variable, the approximate dynamics are $\partial_t y = b y$, where $b$ is the value found in step (ii). 

The solution to the differential equation in (iv) is $y(t) = A e^{bt}$.

iv. Find $A$ in the solution as $y_0 = x_0 - x^\star$, where $x_0$ is the initial condition of the state variable. So, $y(t) = (x_0 - x^\star) e^{bt}$.
v. Finally, translate the solution in (iv) back into terms of $x$. It will be $$x(t) = (x - x_0) e^{b t} + x^\star\ .$$
Thus, the solution requires only two pieces of information knowing $x^\star$ and $b = \partial_x g(x_0)$.

The stability of the fixed point is simply a matter of whether the exponential function in the solution is exponential growth (unstable) or exponential decay (stable). This is, of course, determined by the sign of the constant $b = \partial_x g(x_0)$: $$\partial_x g(x_0) > 0\ \ \  \implies \ \ \text{unstable}\\
\partial_x g(x_0) < 0 \ \ \ \ \implies\ \ \ \ \ \ \text{stable}$$

::: {.takenote data-latex=""}
It's critical to distinguish carefully between $x^\star$, which is the location of the fixed point being examined, and $x_0$, which is the initial condition of the state, that is, $x(t=0)$.
:::

::: {.example data-latex=""}
Let's return to the model of saving for retirement in Chapter \@ref(diff-eq-intro):
$$\partial_t V = r\, V + M\ .$$
The state variable here is named $V$. The dynamical function is $$g(V) = r\, V + M$$ where $r$ is the interest rate (say, 3% per year which is $r=0.03$ per year) and $M$ is the monthly contribution. To keep the units consistent, we set the units of $t$ to be years, of $r$ to be 1/years, of $V$ to be dollars and of $M$ to be dollars-per-year. So a monthly contribution of $1000 would come to 
$M=12000$ dollars-per-year.

Find the amount $V$ that will result from 30 years of savings with an initial condition $V_0 = 0$.

Step i) Find the fixed point. This is a value $V^\star$ such that
$$r\, V^\star + M = 0\ \ \ \implies \ \ \ V^\star = -M/r\ .$$
Step ii) Find the derivative of the dynamical function evaluated at the fixed point: Since $g(V)$ happens to be a straight-line function, we know the derivative is a constant. So $b = \partial_x g(V^\star) = r$.

Step iii) Translate the state variable into $y = V - V^\star$. The dynamics in terms of $y$ are $\partial_t y = b y$, which has a solution $y = A e^{bt}$.

Step iv) $A$ is the initial condition in terms of $y$. This will be $y_0 = V_0 - V^\star$. Since we stated that $V_0 = 0$ (no savings at the start), $y_0 = -V^\star$ and the solution is $$y(t) = -V^\star e^{bt} = \frac{M}{r} e^{rt}\ .$$

Step v) Translate the solution in step (iv) back into terms of $V(t)$. Since $y(t) = V(t) - V^\star$, this will be $V(t) = y(t) + V^\star$ or, $$V(t) = \frac{M}{r} e^{r t} + V^\star = \frac{M}{r} \left[ e^{r t} - 1\right]\ .$$
To get an idea of this retirement plan, that is, $r=3\%$ and $M=12000$ dollars-per-year, let's see how much you'll have after 30 years and 40 years.
```{r}
V <- makeFun((M/r)*(exp(r*t)-1) ~ t, r=0.03, M=12000)
V(30)
V(40)
```
After 40 years of contributions, your retirement account will have almost one-million dollars.

You could have accomplished the same calculation using `integrateODE()`, like this:
```{r}
Soln <- integrateODE(dV ~ r*V + M, V=0, M=12000, r=0.03,  
                     tdur=40)
Soln$V(30)
Soln$V(40)
```
:::

EXERCISES: 
+ some drill on setting up the solution near fixed points to linear and nonlinear equations, e.g. $\dot{x} = r x (1-x)$.
+ Which of these is a function and which is a constant: $V$, $V^\star$, and $V_0$.


## Nonlinearity

Systems with nonlinear dynamical functions can have multiple fixed points. The differential equation $\partial_t x = x(1-x)$ has two: one at $x^\star = 0$ and the other at $x^\star = 1$. The flow-field/dynamics-graph (Figure \@ref(fig:logistic-phase-line)) makes it clear that one of these is stable and the other unstable.

```{r logistic-phase-line, echo=FALSE, fig.cap="Flow field and dynamics function for $\\partial_t x = x (1-x)$. The fixed point at $x^\\star=0$ is unstable; that at $x^\\star =1$ is stable."}
phase_line(x*(1-x) ~ x, domain(x=-0.05:1.05), nix_dyn=FALSE) %>%
  gf_point(0 ~ 0, size=.1, color="blue") %>%
  gf_point(0 ~ 1, size=.1, color="blue") 
```
For the system in Figure \@ref(fig:logistic-phase-line), a  initial condition $x_0 = 0.05$ or any other small positive number will produce a trajectory that moves slowly to the right at first, then faster, then slows down again for asymptotically approaching the fixed point at $x=1$. In a time series plot, $x(t)$ is a sigmoidal function.

::: {.intheworld data-latex=""}
We have been using the differential equation $\partial_t x(1-x)$ as a mathematical equation, but the form has important applications in population modeling and ecology. When parameterized, the model becomes
$$\partial_t x = h(x) \equiv r x \left(1 - \frac{x}{K}\right)$$
For $x \ll K$, the dynamics are approximately $\partial_t x = rx$, which is the recipe for ***exponential growth***. Such growth is often seen in small populations. But "small" compared to what? To answer that, look at the situation for $x \approx K$. In this domain, the growth will be much smaller, because $(1 - x/K) \approx 0$. There's a fixed point at $x^\star = K$, and for $K < x$ the time derivative of $x$ is negative. 

In ecology, the population size that can just barely sustain itself without growth or decay is called the ***carrying capacity***. Putting these different behaviors together, $\partial_t x = h(x)$ is a model of growth of a population when the environment has a finite carrying capacity. The pattern of change in such an environment is called ***logistic growth***, but might as well be called "sigmoidal growth." (The function $f(x) = \frac{e^t}{1 + e^t}$ is called the "logistic function.")

In this problem, we're going to build a somewhat more complicated model of an ecosystem, based on the logistic growth model for grass. 

To turn a field of growing grass into an eco**system**, we're going to add grazing cows to the field. A grazing cow has an impact on a field. To simplify, consider a single cow. She eats until she's full, then takes time off to chew the cud with other cows and ruminate on the day's events. But, if grass is very scarce, she may not be able to consume all that she would otherwise eat. She'll be a hungry, ill-fed cow. 

When building a model, start by thinking what you want to use the model for. Imagine that we're interested in *sustainability*, that is, whether the cow/grass ecosystem is stable. And, since cows are raised for a purpose, we'd like to use the model to find out whether the cow would be well fed and how things would change if another cow were added to the field. Sustainability is a question about dynamics. Here, the system would be sustainable if the field produces more grass in a day than the cow (and her herd-mates if any) consumes consumes in a day.

We'll model a cow's consumption as a sigmoidal function consumption(v) of the amount of grass (v -- for "vegetation") available. Like this:

```{r cow-consumption, echo=FALSE, height=3, fig.cap="The amount of vegetation consumed by a cow in a day depends on the amount of vegetation available. At very low levels of vegetation ($v < 1/2$ ton), it's hard to find more to eat, so a slight increase in vegetation doesn't increase consumption by much."}
consumption <- makeFun((beta*v^2/(v0^2 + v^2))~ v, beta=0.1, v0=3)
slice_plot(consumption(v) ~ v, domain(v=c(0,15))) %>%
  gf_labs(y="Consumption (tons/day)", x="v: available biomass (tons)",
          title="Daily consumption by one cow")
```
The overall system is roughly analogous to the rabbit/fox model where we had rabbits as the food and foxes as the consumers. In the rabbit/fox system, we had one differential equation for the growth in the rabbit population density and another for the foxes. The rabbit dynamics consisted of two parts, the natural growth rate in the absence of foxes and the rate at which rabbits are taken by the foxes: $\partial_t r = 0.66\, r - 1.33\, r f$.

We'll model the dynamics of grass in much the same way. In the absence of cows the grass grows in an environment with a limited carrying capacity. (Carrying capacity reflects limits to the amount of water and the amount of sunlight and space.) Taking the carrying capacity of the field as 25 tons of biomass, we'll set the model for $v(t)$ to be 
$$ \partial_t v =  \frac{v}{3} \left(1-\frac{v}{25}\right)\ .$$


We now have two models for two different components of the ecosystem: the growth of vegetation and the daily consumption by a cow. It's time to put those components together into the overall model. But do we have everything we need?

There are potentially two state variables, the amount of vegetation and the number of cows.  To be analogous to that situation, we would need a model for the number of cows in the field. However, the context for the model suggests some changes here. First, the number of cows $n$ in the field is not set by the cow's natural reproduction, it's set by the farmer's decision. As well, at 9 months, a cow's gestation period is long relative to the potential changes in the amount of vegetation. (In contrast, rabbits have a gestation period of 1 month and foxes 2 months.)


The cow's consumption is one part of the dynamics. If there were no grass growing, the dynamics would be $$\partial_t G(v) = - H \times \text{consumption}(v)$$ where $H$ is the number of cows in the herd. `r mark(6330)`


 Subtracting daily consumption from daily growth of grass gives the rate of change of the biomass of grass. 

<p style="text-align:center">
<iframe frameborder="0" height="780px" loading="lazy"
        src="https://maa-statprep.shinyapps.io/Grazing_cows/"
        width="60%">
</iframe>
</p>
        
```{r cow-app, echo=FALSE, out.width="1%", fig.cap = "The graph can be made to display any of three functions:\n\n1. The intrinsic logistic model growth dynamics with no cows.\\2. The total consumption by the herd of cows.\\3. The **net growth**, which is the difference between (1) and (2)."}        
knitr::include_graphics("www/tiny-blank.png")
```








Many of the natural and constructed objects and systems that we encounter---buildings, bridges, airplanes, the orbits of satellites, heating systems, birds in flight, and so on---are more fully understood if seen as dynamical systems. That may seem strange; a building doesn't move (we hope!), an airplane stays in steady flight, the seasons have been steady in their progression for as long as records have been kept. And yet ... a building might be shaken and even destroyed by an earthquake, airplanes require pilots and control systems for steady flight. Even satellites in far Earth orbit can drift from their desired positions and attitudes and require control corrections.

A system is said to be in ***steady state*** when it stays put, unchanging. Another term often used to express such constancy is ***equilibrium*** which occurs when the various forces or processes acting on the system ***balance out.*** In the language of dynamical systems, the equilibrium state of a system is called a ***fixed point***.  Mathematically, this is a coordinate in the state space where all the right-hand sides of the differential equations equal zero. For a two-dimensional system with dynamics $$\partial_t x = f(x, y)\\\partial_t y = g(x,y)$$, a fixed point will be a particular value for the state which we'll write as $(x^\star, y^\star)$ where both $f(x^\star, y^\star) = 0$ and $g(x^\star, y^\star) = 0$.


## Second-order dynamics

Let's return to second-order dynamics such as the rabbit/fox system:
$$\partial_t r = \alpha r - \beta r f\\
\partial_t f = - \delta f + \gamma r f$$

A fixed point in a second-order system exists at a state where both of the differential equations evaluate to zero. These simple dynamical functions can be manipulated algebraically to show that there is one fixed point:

$$\alpha r^\star - \beta r^\star f^\star = 0 \ \ \ \implies\ \ \ f^\star = \frac{\alpha}{\beta}\\
\ \\
- \delta f^\star + \gamma r^\star f^\star = 0 \ \ \ \implies \ \ \ r^\star = \frac{\gamma}{\delta}$$

More generally, considering that the dynamical functions have two inputs, $r$, and $f$, we can see where each of the functions is zero by looking at the zero contour of each function individually. Where the zero contours cross, there is a fixed point.  Figure \@ref(fig:rabbit-fox-nullclines) shows the situation for the rabbit/fox system. These zero contours are called ***nullclines***. At any point on the rabbit nullcline, the flow arrows have zero component in the rabbit direction in state space. Similarly, at any point on the fox nullcline, the flow field has zero component in the fox direction.



```{r rabbit-fox-nullclines, echo=FALSE, fig.cap="Flow field for the rabbit/fox system. The rabbit nullcline } 
contour_plot(0.66*r - 1.33*r*f ~ r & f, domain(r=.1:2, f=0.05:1), contours_at = 0, contour_color = "magenta", filled = FALSE, labels=FALSE) %>%
  contour_plot(-f + f*r ~ r & f, contours_at=0, contour_color="blue", filled=FALSE, labels=FALSE ) %>%
vectorfield_plot(0.66*r - 1.33*r*f ~ r & f, 
                 1*f*r -1*f ~ r & f, 
                 domain(r=.1:2, f=0.05:1), npts=20, 
                 transform=I) %>%
  gf_labs(x="Rabbit density", y="Fox density")
```


```{r}
show_abcd <- function(a, b, c, d) {
  dx <- makeFun(a*x + b*y ~ x & y)
  dy <- makeFun(c*x + d*y ~ x & y)
  # contour_plot(dx(x,y) ~ x&y, contour_color="red", labels=FALSE, filled=FALSE,  
  #              contours_at=0, domain(x=-1:1, y=-1:1)) %>%
  #   contour_plot(dy(x,y) ~ x&y, contour_color="blue", labels=FALSE, filled=FALSE, 
  #                contours_at=0) %>%
    inequality_constraint(dy(x,y) < 0 ~ x&y, fill="blue", alpha=0.3, domain(x=-1:1, y=-1:1)) %>%
      inequality_constraint(dx(x,y) < 0 ~ x&y, fill="red", alpha=0.3, domain(x=-1:1, y=-1:1)) %>%
  vectorfield_plot((dx(x,y)) ~ x&y, sign(dy(x,y)) ~ x & y, transform=function(x) x^0.3) %>%
    gf_refine(coord_fixed())
    #vectorfield_plot(sign(dx(x,y)) ~ x&y, 0 ~ x & y, color="red") %>%
    #vectorfield_plot(0.001 ~ x&y, sign(dy(x,y)) ~ x&y, color="blue", transform=I)
   }

show_abcd(.5, 1, 1, -.7)
show_abcd(-.5, -1, 1, .7)
show_abcd(-1, -.5, -.2, -.7)
show_abcd(1, .5, -.2, -.7)
show_abcd(-1, -.5, .2, .7)
show_abcd(1, .5, .2, .7)
```

## Stability

hurricanes, tornados, orbits, sand dunes and beach ripples, Galloping Gurdy, ..., orbit around Lagrange point, 

## Linearization




::: {.intheworld data-latex=""}
Given a choice between a numerical and a symbolic solution to exactly the same problem, the symbolic solution is generally better: it's exact and it can incorporate parameters symbolically.


> *"Far better an approximate answer to the right question, which is often vague, than an exact answer to the wrong question, which can always be made precise."* -- John Tukey (1915-2000)
:::


## Exercises

`r insert_calcZ_exercise("XX.XX", "136TO6", "Exercises/ash-look-sofa.Rmd")`

`r insert_calcZ_exercise("XX.XX", "BbcPyk", "Exercises/finch-look-dish.Rmd")`

`r insert_calcZ_exercise("XX.XX", "9aVYdV", "Exercises/dolphin-hang-dish.Rmd")`

`r insert_calcZ_exercise("XX.XX", "rom1Q6", "Exercises/fir-lie-tv.Rmd")`

`r insert_calcZ_exercise("XX.XX", "9qOKUM", "Exercises/spruce-fall-mug.Rmd")`

`r insert_calcZ_exercise("XX.XX", "cAKQiT", "Exercises/hamster-dive-window.Rmd")`

`r insert_calcZ_exercise("XX.XX", "oKNNim", "Exercises/lobster-go-lamp.Rmd")`



## From 2020-2021

### Fixed points
An important strategy in creating and understanding models of dynamics involves **fixed points**.  A fixed point is a value of the state which the dynamics leave untouched. For finite-difference equation dynamics, $${\mathbf X}_{n+1} = g({\mathbf X}_n)$$

At a fixed point, "tomorrow's" value is the same as "today": ${\mathbf X}_{n+1} = {\mathbf X}_n$; the state doesn't change with $n$. 

A fixed point ${\mathbf X}^\star$ satisfies 
$${\mathbf X}^\star = g({\mathbf X}^\star)\ \ \ \mbox{or, said another way,}\ \ \ g({\mathbf X}^\star) - {\mathbf x^\star} = 0$$
"Fixed point" is a mathematical term. In the sciences, you will hear the term "equilibrium state," "steady state," "resting point," or "balance point." For example, chemistry has a concept of [chemical equilibrium](https://en.wikipedia.org/wiki/Chemical_equilibrium), a state where the concentration of reactants and products doesn't change. Finding such equilibria is an important task in many areas of science and engineering.

Some dynamical systems don't display any fixed points, e.g. the orbit of the Earth around the Sun. Others have one or more. We're going to treat them mathematically by analysis of the function $g()$ that governs the dynamics.

There are several ways to find fixed points. 

1. If you have a simple algebraic form for $g()$ you can solve $g(x) = x$ for $x$. For instance, suppose $g(x) \equiv 4 x (1-x)$. Then the fixed points satisfy $$x^\star = 4x^\star (1-x^\star)$$  This has two solutions: one at $x^\star = 0$ and the other at $x^\star = 3/4$.

```{r ffp-a, echo=FALSE, results="markup"}
askMC(
  "Consider the dynamical system $$x_{n+1} = 2 x_n + 3$$ To find the fixed point, re-write the equation as $x^\\star = 2 x^\\star + 3$ and solve for $x^\\star$. What is the fixed point $x^\\star$?",
  "+-3+" = "Right. Plug in $-3$ for $x^\\star$ in $2 x^\\star + 3$ and you get ... -3. ",
  "-1.5",
  "0", 
  "1.5",
  "3",
  random_answer_order = FALSE
)
```

```{r ffp-b, echo=FALSE, results="markup"}
askMC(
  "Consider the dynamical system $$y_{n+1} =  1/y_n + 9$$ To find the fixed point, re-write the equation as $y^\\star = 1/y^\\star + 9$ and solve for $y^\\star$. How many fixed points are there",
  0, 1, "+2+" = "Right, because the equation becomes $(y^\\star)^2 = 9$ which has two solutions, $y^\\star = \\pm 3$.", 3, 4, "an infinite number",
  random_answer_order = FALSE
)
```

```{r ffp-c, echo=FALSE, results="markup"}
askMC(
  "How come the first question used $x_n$ for the state while the second on used $y_n$?",
  "Because you can't write $1/x_n$",
  "Using $y_n$ is a mistake. Dear problem writer, Please be more careful in the future!",
  "+Because you can use any name you like for a variable, so long as you use it consistently. And using $x$ all the time gets tiring, to say nothing about how hard it makes to work with more than one variable at a time.+" = "It would have been fun to use names like $\\mbox{dog_hunger}_n$ or $\\mbox{snowfall}_n$. We used $y_n$ so that we don't freak you out. But $y$ is just a name like any other."
)
```



2. Numerical solving. If solving $g(x)=x$ is not so easy, then we can instead create a new function $h(x)\equiv g(x)-x$ and then solve for the zeros of $h()$.  The point of setting up the helper function $h()$ is that computer algorithms for finding zeros generally take a *function* as their input rather than an *equation*. 

```{r ffp-1, echo=FALSE, results="markup"}
askMC(
  "Consider the system $$x_{n+1} = 5 [\\cos(x_n)]^2$$ Where are the fixed points? (You can use the sandbox to solve the system numerically.)",
  "+$x^\\star \\in \\{1.086, 2.320, 3.681\\}$+",
  paste("$x^\\star \\in \\{", paste(round(sort(runif(4, 0.5, 4)), 4), collapse=", "), "\\}$"),
  paste0("$x^\\star \\in \\{", paste(round(sort(runif(4, 0.5, 4)), 3), collapse=", "), "\\}$"),
  paste("$x^\\star \\in \\{", paste(round(sort(runif(4, 0.5, 4)), 2), collapse=", "), "\\}$"),
  paste0("$x^\\star \\in \\{", paste(round(sort(runif(4, 0.5, 4)), 3), collapse=", "), "\\}$")
)
```

```{r ffp-2, exercise=TRUE, exercise.cap="Solving for zeros", exercise.nlines = 6, eval=FALSE}
g <- makeFun(4*x*(1-x) ~ x) #change this formula to answer the multiple choice question
findZeros(g(x) - x ~ x)
```


3. Graphically. Plot out the function $g(x) - x$ versus $x$. Find values of $x$ where the graph crosses zero. Each of these valuesis a fixed point $x^\star$.

For instance:
```{r ffp-3, exercise=TRUE, exercise.cap="Finding fixed points graphically", exercise.nlines=8, eval=FALSE}
dom <- domain(x = c(0,10))
g <- makeFun(x + sin(x) ~ x) 
slice_plot(g(x) - x ~ x, dom) 
```


4. By iteration. Sometimes you can identify a fixed point by iterating the dynamics starting from different initial conditions. The following sandbox iterates a system for 100 steps. The `tail(5)` function returns just the last 5 rows of the data table, making it easier to see where the state ended up after many iterations.

```{r ffp-4, exercise=TRUE, exercise.cap="Finding fixed points by iteration", exercise.nlines=8, eval=FALSE}
g <- makeFun(x + sin(x) ~ x)
Iterate(g, x0=.872, 100) %>% tail(5)
```
You can look for different fixed points by trying different values for $x0$. 

```{r fpp-4, echo=FALSE, results="markup"}
askMC(
  "Find the fixed points of $$g(x) \\equiv x + \\sin(x)$$ by picking several random initial conditions in the range $0 \\leq x \\leq 10$. Compare your results to the fixed points seen using the graphical method. Which of these fixed points does iteration **NOT** reveal? Hint: the initial condition is $x_0$, so this is the value you need to change.",
  "$x^\\star = \\pi$",
  "+$x^\\star = 2\\pi$+",
  "$x^\\star = 3\\pi$",
  random_answer_order = FALSE
)
```

### Fly dynamics

```{r fly_dyn_def, context="setup", echo=FALSE}
fly_dyn <- function(x, K=1e3, r=1.75e-4) {
  ifelse(x < K,
         0.01*x^2,
         0.01*K^2*exp(-r*(x - K)))
}
```

The year-to-year growth/decline in the number of flies in a mangrove swamp is modeled by the function `fly_dyn()`:
$$x_{t+1} = \mbox{fly_dyn}(x_t)$$

The sandbox shows the function and enables you to perform other calculations using it.

```{r mangrove1, exercise=TRUE, exercise.cap="Yearly fly population.", exercise.nlines=8, exercise.setup="fly-dyn-def"}
slice_plot(fly_dyn(x) ~ x, domain(x=c(0,6000)))
```

```{r mangrove2, echo=FALSE}
askMC(
  "At which of these values of $x_t$ do the dynamics have a fixed point? (Hint: How would you confirm that a given value is a fixed point?)",
  "+0, 100, 4981+",
  "0, 100, 121" = "When you give 121 as the input, do you get 121 as the output?",
  "0, 121, 5683",
  "0, 100, 5683" = "When you give 5683 as the input, do you get 5683 as the output?"
)
```

```{r mangrove3, echo=FALSE}
askMC(
  "Which one of these values for $x$ is an **unstable** fixed point?",
  0, "+100+", 121, 4981, 5683,
  random_answer_order = FALSE
)
```

An important vocabulary word in dynamics is *transient*. In everyday speech, this means something like "just passing through." It's the same in dynamics: that part of the trajectory which precedes stable, fixed behavior such as at a fixed point. Transients occur whenever a dynamical system has an initial state not on a stable, fixed state. They are also common in systems that are disrupted by some external force, for example in the recovery of an electrical power distribution grid after a disturbance such as an ice storm. After a sharp bang, the ringing in your ears is a transient. When you stand up too suddenly, the "stars" you see are a transient due to diminished blood flow. Turn on an oven? The transient is the warming up until the oven reaches the temperature setting. 

Although transients are ... well, transient, they can be very important. Key to the Wright Bros. success was their recognition that air turbulence elicits transients in attitude and that aircraft need control systems that can work fast enough for the craft to survive the transient. If you have driven a car with a broken suspension, you'll know that it can be hard to control after the transient caused by hitting a bump in the road.

Small disturbances often elicit transients that decay away exponentially. Such transients, like all exponentially decaying processes, can be characterized by a half life: the time it takes the transient to shrink to half its original value. (Not all transients decay exponentially, but that's a story for another course.)

Using the sandbox, iterate `fly_dyn()` for 50 years starting at $x_0 = 4500$. Here's the command to do this, which you'll have to copy to the sandbox.

```{r results="hide", eval=FALSE, echo=TRUE}
Trajectory <- Iterate(fly_dyn, x0=4500, n=50)
gf_point(x ~ n, data = Trajectory) %>%
  gf_line(alpha = 0.2)
```

```{r mangrove4, echo=FALSE}
askMC(
  "There is a transient that oscillates while exponentially approaching the fixed point. What is the half-life of the exponential transient?",
  "1 year",
  "3 years",
  "+6 years+",
  "12 years",
  "24 years",
  random_answer_order = FALSE
)
```

### Tree example

A tree provides a simple example of equilibrium. A living tree grows slowly, with essentially no change from day to day. The tree is usually in equilibrium with its surroundings. But there are disruptions that can place the tree out of equilibrium. The wind is a familiar disruption, changing the dynamics so that the tree no longer stands straight and still; it sways in the wind. A severe storm or a chain saw creates an opportunity for bigger disruption, removing the fixed point of upright posture and replacing it with an entirely different sort of fixed point. The steady, slow process of rot can weaken the equilibrium to the point where it no longer exists or is too weak to withstand the wind. The tree falls.

Mathematics provides several concepts for thinking about equilibrium and the loss of equilibrium. The idea of a **fixed point** is at the center of things. The idea of disruption also has a mathematical equivalent called "forcing." The slow change (as in the rot of a tree) leading to a dramatic, sometimes sudden, collapse is represented by a "bifurcation." We'll explore forcing and bifurcation later, when we've developed better tools and ways of thinking to understand dynamics.

Here we will examine the important topic of "stability." The word has a variety of related meanings in everyday life: a patient is stable when his or her condition is not worsening (or getting better), a chair is stable when it won't fall over, a stable personal relationship is much preferred to an unstable one, a person who is stable does not get upset or disturbed by a trivial incident.

In mathematics, "stability" is a property of dynamics near a fixed point. A fixed point is stable when an initial trajectory close enough to the fixed point leads to a trajectory that continues to get closer to the fixed point. A fixed point is unstable when initial conditions close to the fixed point lead to trajectories that tend away from the fixed point. 

In everyday life, we think about stability as a matter of how hard you can push something before it falls over. A coin standing on edge is not very stable in this sense, any palpable disturbance will cause it to fall over. But mathematically, stability is just about the response to infinitesimal disturbances. The coin standing on edge is mathematically stable. Large disturbances may lead to the state of a system leaving even a stable fixed point. Stability of mathematical fixed points is about *local* dynamics. The response to large disturbances is non-local or *global* dynamics, a much harder topic.

The sandbox provides space to explore stability via iteration.

```{r stb1-1, exercise=TRUE, exercise.cap="Stability sandbox", exercise.nlines = 6, eval=FALSE}
g <- makeFun(5*sin(x)^2 ~ x)
findZeros(g(x) - x ~ x)
Iterate(g, x0 = 0.0001, n=10)
```

The dynamical system $x_{n+1} = 5 [\sin(x_n)]^2$ has five fixed points. Use iteration to determine whether each fixed point is stable or unstable.

```{r stb1-2, echo=FALSE, results="markup"}
askMC(
  "Using iteration, is the fixed point at $x=0$ stable?", 
  "Yes",
  "No",
  random_answer_order = FALSE,
  right_one = "Yes"
)
```

```{r stb1-3, echo=FALSE, results="markup"}
askMC(
  "Using iteration, is the fixed point at $x=0.2027$ stable?", 
  "Yes",
  "No",
  random_answer_order = FALSE,
  right_one = "No"
)
```

```{r stb1-4, echo=FALSE, results="markup"}
askMC(
  "Using iteration, is the fixed point at $x=2.3802$ stable?", 
  "Yes",
  "No",
  random_answer_order = FALSE,
  right_one = "No"
)
```

```{r stb1-5, echo=FALSE, results="markup"}
askMC(
  "Using iteration, is the fixed point at $x=4.3408$ stable?", 
  "Yes",
  "No",
  random_answer_order = FALSE,
  right_one = "No"
)
```

```{r stb1-6, echo=FALSE, results="markup"}
askMC(
  "Using iteration, is the fixed point at $x=4.8726$ stable?", 
  "Yes",
  "No",
  random_answer_order = FALSE,
  right_one = "No"
)
```

### Stability

Previously, we examined the stability of fixed points by using iteration: start at an initial condition arbitrarily close (but not exactly on!) a fixed point and see if the trajectory tends toward or away from the fixed point.

Now we'll look at stability another way, by considering the shape of of the dynamical function near a fixed point. At this point in CalcZ, you're aware that "near" suggests local, and that we routinely model (continuous) functions in terms of the value at a point, the value of the derivative at the point, and the value of the 2nd derivative at the point.

The stability of a fixed point is determined in all but very special situations by the slope of the function at the fixed point. Here's the rule: 

> In the dynamical system $x_{n+1} = g(x_n)$ with a fixed point at $x^\star$, the stability of that fixed point depends only on the magnitude of $\left| \partial_x g(x^\star) \right|$. The rule is: 

> If $\left| \partial_x g(x^\star) \right| > 1$, the fixed point at $x^\star$ is **unstable**.

> If $\left| \partial_x g(x^\star) \right| < 1$, the fixed point at $x^\star$ is **stable**.

Notice that it doesn't matter what is the **sign** of $\partial_x g(x^\star)$; the fixed point will be stable or not depending just on the magnitude of the derivative.

```{r stb2-1, exercise=TRUE, exercise.cap="Stability sandbox", exercise.nlines = 6, eval=FALSE}
g <- makeFun(sin(x)^2 + 1 ~ x)
fixed_points <- findZeros(g(x) - x ~ x)
dg <- D(g(x) ~ x)

## Now, apply dg() to the fixed point(s)
dg(fixed_points)
```

```{r stb2-2, echo=FALSE, results="markup"}
askMC(
  "Calculate the derivative with respect to $x$ of $g(x) \\equiv  \\sin(x)^2 + 1$ at the fixed point at $x^\\star = 1.8972$. Is that fixed point stable?",
  "+Yes+",
  "No",
  random_answer_order = FALSE
)
```

Consider the simple dynamical system $$x_{n+1} = g(x_n) \equiv \frac{1}{2} x_n$$

This has a fixed point $x^\star = 0$. You can see this by plugging in $x^\star = 0$ every place that $x_n$ or $x_{n+1}$ appears in the equation describing the dynamics and confirming that the left side is indeed equal to the right side.

Is the fixed point stable? Calculate $\partial_x g(x^\star)$ and check whether it's absolute value is less than 1. If so, the fixed point is stable. Since $| \partial_x g(x^\star) | = \frac{1}{2} < 1$, the fixed point is stable.

Now consider $$x_{n+1} = g(x_n) \equiv 2 x_n$$ Again, this system has a fixed point $x^\star = 0$. Is it stable? Well, $\partial_x g(x^\star) = 2$. The magnitude $| \partial_x g(x^\star) |$ is clearly greater than 1, so the fixed point is *unstable*.

We could play this game for any number in place of the $\frac{1}{2}$ or $2$. It would quickly get boring, so better to deal with the question once and for all for all possible numbers. We will *parameterize* the system, replacing the quantity that has been $\frac{1}{2}$ or $2$ in the previous examples with a symbol that stands for "some number here":
$$x_{n+1} = \alpha\, x_n$$
Does this system have a fixed point and where is it? The dynamical function is $g(x) = \alpha x$, so solve $g(x) - x = \alpha x^\star - x^\star = 0$. This becomes $$(\alpha - 1) x^\star = 0$$ which implies that $x^\star = 0$ is a fixed point or, if $\alpha=1$, any value for $x^\star$ will satisfy the fixed-point condition.

It's a common style in mathematical discourse to use parameters rather than specific numbers so that we can look at the same time at all systems of the same "form." For instance, we can summarize the stability of fixed points in the system $x_{n+1} = \alpha x_n$ by saying,

- There is a single fixed point at $x^\star = 0$, regardless of $\alpha$.
- That fixed point is stable if $|\alpha| < 1$, otherwise it's unstable. (Pedantic: In the singular case where $|\alpha| = 1$, the fixed point is "neutrally stable" and all points are fixed points.)

The advantage of using parameters is that we can often find the location of fixed points and their stability once and for all *as a function of the parameters*, and then use observed or desired behavior to set conditions on the range of parameter values that will produce that behavior.

```{r s4-1, echo=FALSE, results="markup"}
askMC("Consider the parameterized dynamical system $$x_{n+1} = \\alpha x_n + \\beta$$ What is the location of the fixed points in terms of the parameters $\\alpha$ and $\\beta$?",
  "+$x^\\star = \\frac{\\beta}{1-\\alpha}$+",
  "$x^\\star = \\frac{\\alpha}{1-\\beta}$",
  "$x^\\star = 0$",
  "$x^\\star = \\beta / \\alpha$"
  )
```

```{r s4-2, echo=FALSE, results="markup"}
askMC("In the system $$x_{n+1} = \\alpha x_n + \\beta$$ what is the condition for the fixed point to be stable?",
  "+$|\\alpha | < 1$+",
  "$|\\alpha| < |\\beta|$",
  "$|\\alpha| < \\beta$",
  "$|\\beta| < 1$"
)
```

```{r s4-3, echo=FALSE, results="markup"}
askMC(
  "You are modeling a real-world system with $$x_{n+1} = \\alpha x_n + \\beta$$ and you observe that the system tends toward a fixed value $x^\\star = 3.82$. Which one of these gives possible values for $\\alpha$ and $\\beta$?",
  "+$\\beta = 1$ and $\\alpha = 1 - 1/3.82$+",
  "$\\beta = 1$ and $\\alpha = 1 + 1/3.82$",
  "$\\beta = 0.5$ and $\\alpha = 1 - 1/3.82$",
  "$\\beta = 0.5$ and $\\alpha = 1 + 1/3.82$"
)
```

```{r s4-4, echo=FALSE, results="markup"}
askMC(
  "Now consider the dynamical system $$x_{n+1} = x_n^2 + x_n + \\alpha$$ In terms of the parameter $\\alpha$, where is/are the fixed point/s?",
  "+$x^\\star = \\pm \\sqrt{\\alpha}$+",
  "$x^\\star = \\pm \\alpha$",
  "$x^\\star = \\pm 1/\\alpha$",
  "$x^\\star = \\pm 1/\\sqrt{\\alpha}$"
  )
```

```{r s4-5, echo=FALSE, results="markup"}
askMC(
  "Again looking at the dynamical system $$x_{n+1} = x_n^2 + x_n + \\alpha$$ what are the conditions in terms of the parameter $\\alpha$ for the fixed point to be stable?",
  "+$| \\, 2 \\alpha + 1 \\, | < 1$+",
  "$| \\alpha | < 1$",
  "$| \\alpha^2 + 2 \\alpha | < 1$",
  "$\\alpha^2 < | \\alpha |$"
  )
```

