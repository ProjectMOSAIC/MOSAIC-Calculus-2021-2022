[["diff-eq-intro.html", "Chapter 48 Differential equations 48.1 The language for change 48.2 State 48.3 Dynamics 48.4 State space and flow field 48.5 Exercises", " Chapter 48 Differential equations Explain the format in which we present dynamics as opposed to trajectories Find qualitative solutions from an initial condition Articulate the difference between state, dynamics, and trajectory Vocabulary Differential equation Dynamical function Initial condition (or, initial value or boundary value) State &amp; state variable &amp; state space Solution Time series (state variable versus time) Trajectory (Movement in the state space) Fixed point Flow field Euler integration (iteration) Examples Bank interest or sapling growth. Gompertz growth Logistic growth (e.g. population, or change in height of tree versus height). Pendulum Disease Rocket 48.1 The language for change Calculus is the dominant means of describing change. Developed initially in the 1600s as a means of relating planetary motion to the force of gravity felt on Earth, it nonetheless remained the way of describing heat, sound, and electromagnetism in the 1800s. It the 1900s, calculus was turned to representing the basic mechanisms of quantum mechanics. The beginning student may see calculus as consisting of manipulations and transformations (e.g. differentiation and integration). The first stages of learning calculus consists of applying such manipulations and transformations to textbook exercises. To use these observations productively in solving real-world problems, you need to have a way of describing the world and the mechanisms of the world in terms of calculus. For this, you need to start seeing calculus as a language for description. We’ll use four concepts of language in describing calculus: nouns, verbs, clauses, and sentences. A calculus noun is an object such as a function, scalar, vector, or matrix. A calculus verb is an operation such as differentiation and accumulation. Other verbs come from arithmetic and algebra: square roots, addition, multiplication, and so on. A calculus clause is the application of a verb to one or more nouns to produce a new noun. For instance, if the original noun is the function \\(x(t)\\) representing the position of an object in time, then the application of the verb \\(\\partial_t\\) to the function is a new function \\(\\partial_t\\, x(t)\\), which we interpret as velocity. A calculus sentence is an equation: a statement of the equivalence of two nouns. Natural languages such as English or Chinese are much more complicated. Calculus involves sentences such as “The color of John’s bike is blue,” where “is” stands for equality: \\[\\underbrace{\\text{The color of John&#39;s bike}}_{\\text{noun}}\\ \\underbrace{\\text{is}}_{=}\\ \\underbrace{\\text{blue.}}_{\\text{noun}}\\] In both calculus and natural languages, such sentences allow us to draw conclusions that may be useful or informative. For instance, combined with the sentence, “The bike I see is red,” a conclusion might be, “The bike I see is not John’s.” Early calculus sentences were often about positions, velocities, forces, and accelerations, for instance \\[F_\\text{air} = \\alpha v^2\\] which is a simple model of the force due to air resistance. In this Block, we’ll use the language of calculus to represent dynamics, situations of motion, growth, decay, and oscillation. This Chapter introduces some of the nouns involved. 48.2 State Here are a few of the situations we will construct calculus-language descriptions of: physics swing of a pendulum bobbing of a mass hanging from a string. a rocket shooting up from the launch pad commerce investment growth growth in equity in a house as a mortgage is paid up. (“Equity” is the amount of the value of the house that belongs to you.) biology growth of animal populations, including predator and prey. growth of a tumor growth of an organism or a crop. A model describing such situation has a basic component called the dynamical state, as in “the state of affairs,” or “his mental state,” or “the state of their finances.” One of the things you learn when you study a field such as physics or epidemiology or engineering is what constitutes a useful description of the dynamical state for different situations. As an example, consider the rather simple physical system of a pendulum. A pendulum, as you know, consists of a mass hanging from a rod or rope pivoting to another object such as the ceiling. In physics, you learn the essential elements of the pendulum system: the length of the rod, the gravitational acceleration. These aspects of the system are fixed, they don’t change in time. Although such characteristics may be important in describing the system, they are not elements of the dynamical state. The dynamical state consists of the aspects of the system that are changing in time, seen instantaneously. For instance, the angle that the pendulum makes from the vertical changes in time. Such changing aspects, seen at each instant of time, constitute the dynamical state. We say, for example, that angle-from-the-vertical is a state variable and that the state at any instant is the angle at that instant.. In a physics class, you learn that angle is not a complete description of state. You need also to know the velocity of the pendulum, described for instance as the velocity of the mass at the end of the pendulum. To be complete, the dynamical state of a system has to include all those changing aspects of the system that allow you to calculate from the state at this instant what the state will be at the next instant. For example, from the angle of the pendulum at an instant it’s not possible so say what the angle will be at the next instant. You need to know which way the pendulum is swinging and how fast. And you also need to know the relevant fixed aspects of the system, such as the length of the pendulum.1 Figuring out what constitutes the dynamical state requires knowledge of the mechanics of the system, e.g. the action of gravity, the constraint imposed by the pivot of the pendulum. You get that knowledge by studying the relevant field: electrical engineering, economics, epidemiology, etc. You also learn what aspects of the system change slowly enough that they can be considered fixed. But there are a few things we can say mathematically about states that provide a valuable clue about the state of any continuous-time system. If the change is monotonic, the state can consist of just a single element. If the change is non-monotonic, that is, oscillates back and forth, the state must have two or more elements. If the change is irregular, the state must have at least three elements. In this book, we will work almost exclusively with systems that have a one- or two-dimensional state. The methods you learn will be broadly applicable to systems with higher-dimensional state. One of the ways in which calculus is the language of change can be seen in the words used in this section. For instance, instantaneous, continuous-time, and monotonic are all words introduced in Block 1 of this book. What does it take to describe the dynamical state of an epidemic? News reports of the COVID pandemic usually focus on the number of new cases each day and the fraction of the population that has been vaccinated. But this is not adequate, even for a simple description of the dynamics. From a history of new-case counts over time (e.g. Figure 48.1) you can see that the number of new cases waxes and wanes. Knowing that the number of cases today is, say, 100 thousand doesn’t tell you what the number of cases will be in two weeks: 100 thousand is encountered both on the way up and on the way down. Figure 48.1: COVID-19 new-case counts in the US over the first two years of the pandemic. Source: [New York Times] 48.3 Dynamics The dynamics of a system is a description of how the individual components of the state change as a function of the entire set of components of the state. At any instant in time, the state is a set of quantities. We’ll use \\(x\\), \\(y\\), and \\(z\\) for the purpose of illustration, although most of our work in this introduction will be with systems that have just two state variables. The state can change in time. This implies that the evolving state as a function of time is a set of functions: \\(x(t)\\), \\(y(t)\\), and \\(z(t)\\) for our illustration. Sometimes these are called state variables because they vary in time. The dynamics of the system are described by another set of functions, one for each state variable. These functions—let’s call them \\(g_x()\\), \\(g_y()\\), and \\(g_z()\\) in our illustration—each take as inputs the value of the state variables. Thus, we have: \\[g_x(x, y, z)\\ \\ \\ \\ g_y(x, y, z)\\ \\ \\ \\ g_z(x, y, z)\\ .\\] We’ll call these dynamical functions, but they are perfectly ordinary functions. The term “dynamical function” is simply a way of reminding us the role they play in the mathematical description of the dynamics. Remember that \\(x\\), \\(y\\), and \\(z\\) are state variables, so they are all functions of time. At any instant in time, the values \\(x\\), \\(y\\), \\(z\\) have a specific value. Thus, at any instant in time, the functions \\(g_x(x, y, z)\\), \\(g_y(x, y, z)\\), and \\(g_z(x, y, z)\\) also have a specific, scalar value. If we wanted to make this perfectly explicit, we could write \\(g_x(x(t), y(t), z(t))\\), which makes it clear that the output of \\(g_x()\\) is a function of time. The framework for a dynamics model is that the rate of change in time of each state variable is specified by the corresponding dynamical function. Of course, we write the “rate of change in time” as \\(\\partial_t\\), so the rate of change of \\(x\\) is \\(\\partial_t x(t)\\), and similarly for the other state variables. The way to write mathematically that “the rate of change of \\(x(t)\\) is given by the appropriate dynamical function” is a set of equations: \\[\\partial_t x(t) = g_x(x(t), y(t), z(t))\\ \\, \\\\ \\partial_t y(t) = g_y(x(t), y(t), z(t))\\ \\, \\\\ \\partial_t z(t) = g_z(x(t), y(t), z(t))\\ .\\] This is practically impossible to read: all those \\((t)\\). So the convention is to omit the \\((t)\\): \\[\\partial_t x = g_x(x, y, z)\\\\ \\partial_t y = g_y(x, y, z)\\\\ \\partial_t z = g_z(x, y, z)\\] and leave it to the reader to remember that \\(x\\) is really \\(x(t)\\) and so on. Such equations are called differential equations. The dynamical functions \\(g_x()\\), \\(g_y()\\) and \\(g_z()\\) on the right-hand side of the equations represent the dynamics of the system. These functions will be different depending on what we are trying to model. The art of modeling a system that evolves in time is to find the right form for the dynamical functions. ::: {.takenote data-latex} Mathematically, a dynamical system consists of two things: The state variables, which is a set of quantities that vary in time. They dynamics, which is the set of dynamical functions, one function for each of the state variables. ::: A simple example is the dynamics of retirement-account interest. In a retirement account, you put aside money—this is called “contributing”—each month. The value \\(V(t)\\) of the account accumulates over time, both due to new monthly deposits and to the interest \\(r\\) earned on the current account value. If you are setting aside \\(M\\) dollars per month, the dynamics are: \\[\\partial_t V = r V + M\\ .\\] The left-hand side of this equation is boiler plate; there is a single state variable named \\(V\\) and we are describing how \\(V\\) varies with time, that is, we are describing \\(\\partial_t V\\). The description itself is on the right side of the equation. The description take the form of a dynamical function, which we could call \\(g(V)\\equiv rV + M\\). The dynamical function always takes the set of state variables as inputs. In this example, there’s just the one state variable \\(V\\), so \\(g_V()\\) has only one argument: \\(V\\). Of course, there can also be parameters in a dynamical function, like \\(r\\) and \\(M\\) here. For the sake of simplicity, we can imagine that the interest rate and monthly contribution are constants: they are not part of the dynamical state. This leaves \\(V\\) at any given time as the state variable. The dynamics tell the rate of change in the state variable, \\(\\partial_t V(t)\\) as a function of the current value \\(V(t)\\) of the state variable. The above differential equation, having just one component to the state, is sometimes called a first-order differential equation. Remember that the dynamical function is something that the modeler constructs from her knowledge of the system. A modeler might decide to incorporate more or fewer details of the real-world system. For instance, a model more faithful to what happens over the course of years of saving for retirement might include the monthly contribution \\(M(t)\\) changing with time. (If your income changes over the years, your contribution will likely change along with it.) Similarly, interest rates are notoriously variable over time. Still, these are not included in the dynamical state There’s a simple reason: we don’t have usually have any model describing how \\(r(t)\\) and \\(M(t)\\) change as a function of the state. That is, we can’t say how \\(r(t)\\) changes as a function of \\(V(t)\\), \\(r(t)\\), and \\(M(t)\\). Quantities such as interest rate and contribution amount are said to be exogenous meaning “outside the system.” (The word comes from the root “exo,” meaning “outside,” and “indigenous,” meaning “native to.”) Your retirement account doesn’t determine the interest rate; interest rate is something (from your perspective) that comes from outside, largely uncontrollable factors. Another example, found in physics textbooks, is the dynamics of the pendulum. In studying physics, you learn how to identify and keep track of the forces involved. Without getting involved much with the physics, we note that the oscillatory nature of pendulum movement means that there must be at least two state variables. We’ll take these to be the angle \\(\\theta(t)\\) of the rod with respect to the vertical, and the angular velocity \\(v_\\theta(t)\\) telling how the velocity changes with time. Since there are two state variables, there must be two dynamical functions. For a pendulum, these functions can be developed from the general rule \\(F = m a\\) and the geometry of the pendulum; they are \\(\\partial_t v_\\theta(t)\\). They are: \\[\\partial_t \\theta(t) = g_\\theta(\\theta, v_\\theta) = v_\\theta\\\\ \\partial_t v_\\theta(t) = g_{v_\\theta}(\\theta, v_\\theta) = - \\sin(\\theta) \\] Why did you bother to define a state variable \\(v_\\theta\\) when it is, by definition, exactly the same as \\(\\partial_t \\theta(t)\\)? Even though the dynamical equation \\(\\partial_t \\theta(t) = v_\\theta\\) is a calculus tautology, we need always to be explicit about what are the two quantities in the dynamical state. The first of the two dynamical equations comes for free from basic calculus concepts. The second equation, however, is about the physics, the relationship between forces and acceleration. There is a style of writing dynamics equations that discards such tautologies. For example, the pendulum dynamics are often written \\[\\partial_{tt} \\theta(t) = - \\sin(\\theta)\\ .\\] This sort of equation, containing a second-order derivative, is called a second-order differential equation. It’s exactly equivalent to the pair of first order equations, one for \\(\\partial_t \\theta(t)\\) and one for \\(\\partial v_\\theta(t)\\). We’ll return to this style in Chapter 55. We are avoiding this style because it obscures the fact that there are two state variables: \\(\\theta(t)\\) and \\(v_\\theta(t)\\), Example 48.1 Consider the population of two interacting species, say rabbits and foxes. As you know, the relationship between rabbits and foxes is rather unhappy from the rabbits’ point of view even if it is fulfilling for the foxes. Many people assume that such populations are more or less fixed: that the rabbits are in a steady balance with the foxes. In fact, as any gardener can tell you, some years there are lots of rabbits and others not: an oscillation. Just from this fact, we know that the dynamical state must have at least two components. In a simple, but informative, model, the two components of the dynamical state are \\(r(t)\\) and \\(f(t)\\), the population of rabbits and foxes respectively. In the absence of foxes, the dynamics of rabbits are exponential growth; each successive generation is larger than the previous one. This can be described by a dynamical equation \\(\\partial_t r(t) = \\alpha r(t)\\), where \\(\\alpha\\) is a fixed quantity that describes rabbit fecundity. Similarly, in the absence of food (rabbits are fox food), the foxes will starve or emigrate, so the dynamical equation for foxes is very similar \\(\\partial_t f(t) = - \\gamma f(t)\\), where \\(\\gamma\\) is a fixed quantity that indicates the rate at which foxes die or emigrate. Of course, in real ecosystems there are many other quantities that change and that are relevant. For instance, foxes eat not only rabbits, but birds and frogs and earthworms and berries. And the diet of rabbits eat weeds and grass (which is generally in plentiful supply), but also the gardener’s flowers and carrots (and other vegetables). Growth in the rabbit population leads to decrease in available flowers and vegetables, which in turn leads to slower growth (or even population decline) for rabbits. In the spirit of illustrating dynamics, we’ll leave out these important complexities and imagine that the state consists of just two numbers: how many rabbits there are and how many foxes. The dynamics therefore involve two equations, one for \\(\\partial_t r\\) and one for \\(\\partial_t f\\), usually written: \\[\\partial_t r = \\alpha\\, r - \\beta\\, f r\\\\ \\partial_t f = \\delta\\, r f - \\gamma\\, f\\] Keep in mind that \\(r\\) is a function of time, as is \\(f\\). But instead of writing them as \\(r(t)\\) and \\(f(t)\\), we use the shorthand \\(r\\) and \\(f\\). How are you supposed to know that \\(f\\) stands for a function of time but \\(\\beta\\) and \\(\\gamma\\) are constant parameters? The clue is given by the left-hand sides of the differential equations, \\(\\partial_t r\\) and \\(\\partial_t f\\). If we are taking the derivative of \\(f\\) with respect to \\(t\\), it must be that \\(f\\) is a function of \\(t\\). That there is no differential equation involving \\(\\partial_t \\beta\\) is the way we know that \\(\\beta\\) isn’t part of the dynamical state. The quantities \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), and \\(\\delta\\) are parameters quantify the biology of the system: the reproduction rate of rabbits, the need of foxes for food (rabbits) in order to reproduce, the hunting success of foxes, and the death or emigration of foxes in response to a shortage of food. Coming up with this description of dynamics requires knowing something about rabbits and foxes. The particular forms used, for instance the interaction term \\(r f\\), coming from modeling experience. When we write such dynamics here, the point is to illustrate some of the forms commonly used to represent real-world phenomena. For instance, the interaction term is well named because it is about the literal, biological interaction of foxes and rabbits, for better (\\(+ \\delta r(t) f(t)\\)) or for worse (\\(-\\gamma r(t) f(t)\\)) depending on which species we are looking at. 48.4 State space and flow field A helpful representation of dynamics for the purpose of developing intuition is to represent the instantaneous state as a point in a graphical frame and the dynamics as a field of vectors showing how, for each possible state, the state changes. For instance, in the Rabbit-Fox dynamics, the state is the pair \\((r, f)\\) and the state space is the coordinate plane spanned by \\(r\\) and \\(f\\). The present state of the system might be any point in the state space. But if we know the present state, the dynamical functions evaluated at the present state tell us how the state changes over a small increment in time. The step over a small increment of time can be represented by a vector. Let’s illustrate with the Rabbit-Fox system, whose dynamical equations are given above. The dynamical functions take a position in state space as input. Each of the functions returns a scalar. To make a plot, we need numerical values for all the parameters in those equations. The vector field corresponding to the dynamics is called a flow, as if it were a pool of swirling water. Figure 48.2 shows the flow of the rabbit/fox system. Figure 48.2: The dynamics of the rabbit/fox system shown as a vector field over the state space. The parameters have been set, for the purpose of illustration, to \\(\\alpha = 2/3\\), \\(\\beta = 4/3\\), \\(\\gamma = 1\\), and \\(\\delta = 1\\). Staying with the analogy to a pool of swirling water or the currents in a river, you can place a lightweight marker such as a leaf at some point in the flow and follow its path over time. This path—position in state space as a function of time—is called the trajectory of the flow. There are many possible trajectories, depending on where you place the leaf. In Chapter 33 we considered the path followed by a robot arm. In that chapter, we separated out the \\(x\\)- and \\(y\\)-components of the arm’s position over time, calling them functions \\(x(t)\\) and \\(y(t)\\). Analogously, the the decomposition of a trajectory from an initial condition in the flow—this would be \\(r(t)\\) and \\(f(t)\\) for the rabbit/fox system—gives us the solution to the differential equation. Each component of the solution is called a time series and is often plotted as a function of time, for instance \\(r(t)\\) versus \\(t\\). From the flow field, you can approximate the trajectory that will be followed from any initial condition. Starting from the initial condition, just follow the flow. You already have some practice following a flow from your study of the gradient ascent method of optimization described in Chapter 23. At the argmax, the gradient is nil. Thus, the gradient ascent method stops at the argmax. We’ll see an analogous behavior in dynamical systems: any place where the flow is nil is a potential resting point for the state, called a fixed point. Example 48.2 Let’s return to the pendulum and examine its flow field. We’ll modify the equations just a little bit to include air resistance in the model. Air resistance is a force, so we know it will appear in the \\(\\partial_t v_\\theta(t)\\) equation. A common model for air resistance has it proportional in size to the square of the velocity and with a direction that is the opposite of the velocity. In a differential equation, the model of air resistance can be written as \\(- \\alpha\\, L\\, \\text{sign}(v(t))\\ v(t)^2\\), where \\(\\text{sign}()\\) is a piecewise function that has the value \\(+1\\) when the argument is positive and \\(-1\\) when the argument is negative. \\(L\\) is the length of the pendulum. \\[\\partial_t \\theta = v_\\theta\\\\ \\partial_t v_\\theta = - \\sin(\\theta) - \\alpha\\,L\\, \\text{sign}(v)\\ v^2\\] Note that we’ve dropped the \\((t)\\) in \\(\\theta(t)\\) and in \\(v_\\theta(t)\\). Whenever you have a state variable, you know that it’s a function of time and so the explicit \\((t)\\) is often omitted for the sake of conciseness. Figure 48.3 shows the flow field of the pendulum. Also shown is a trajectory and the two time series corresponding to that trajectory. Figure 48.3: The flow field of a pendulum with air resistance. From the initial condition (marked by \\(\\color{red}{\\text{x}}\\)), a trajectory is sketched out for \\(0 \\leq t \\leq 20\\). The individual components of that trajectory are graphed as time series. The pendulum was started out by lifting it to an angle of \\(45^\\circ\\) and giving it an initial upward velocity. The bob swings up for a bit before being reversed by gravity and swinging toward \\(\\theta = 0\\) and beyond. Due to air resistance, the amplitude of swinging decreases over time. 48.5 Exercises Exercise XX.XX: DtLAhm Question A If today is \\(n\\), what is the day after tomorrow?     \\(n-1\\)︎✘ \\(n-1\\) is yesterday.       \\(n\\)︎✘ \\(n\\) is today.       \\(n+1\\)︎✘ \\(n+1\\) is tomorrow.       \\(n+2\\)\\(\\heartsuit\\ \\)       \\(n=3\\)︎✘ Question B If today is \\(n\\), what is the day one week from now?     \\(7n\\)︎✘        \\(n + 1 week\\)︎✘ Although \\(n\\) stands for “today”, \\(n\\) is a pure number.       \\(n+7\\)\\(\\heartsuit\\ \\) Question C If today is \\(n\\), what is the day one week ago?     \\(-7 n\\)︎✘        \\(n - 1\\) week︎✘ Although \\(n\\) stands for “today”, \\(n\\) is a pure number.       \\(n-7\\)\\(\\heartsuit\\ \\) Question D Given \\({\\mathbf S}_{n+1} = g({\\mathbf S}_n)\\), what is \\({\\mathbf S}_{n+3}\\) ? \\(g(g(g({\\mathbf S}_n)))\\)Good.  \\(3 g({\\mathbf S}_n)\\)︎✘ \\(3 g({\\mathbf S}_n)\\) is “three times \\({\\mathbf S}_{n+1}\\)”, not \\({\\mathbf S}_{n+3}\\). \\(g({\\mathbf S}_n)^3\\)︎✘ \\(g({\\mathbf S}_n) + 2 {\\mathbf S}_{n}\\)︎✘ Question E Given \\({\\mathbf S}_{n+1} = g({\\mathbf S}_n)\\), which of these is not \\({\\mathbf S}_{n+1}\\) ? \\(g(g(g({\\mathbf S}_{n-2})))\\)︎✘ \\(g({\\mathbf S}_{n-1})\\)Excellent! This is \\({\\mathbf S}_{n}\\). \\(g(g({\\mathbf S}_{n-1}))\\)︎✘ \\(g(g(g(g(g(g(g(g({\\mathbf S}_{n-7}))))))))\\)︎✘ These 8 applications of \\(g()\\) will take \\({\\mathbf S}_{n-7}\\) up to \\({\\mathbf S}_{n+1}\\) Exercise XX.XX: mJRDLy Question A Given the system \\({\\mathbf S}_{n+1} = g( {\\mathbf S}_n)\\) with \\(g(S) \\equiv 5 + S/2\\), which of these is a trajectory of the system? {16, 13, 11.5, 10.75, 10.375, 10.1875, 10.09375}Good.  {16, 8, 4, 2, 1}︎✘ {5, 7.5, 10, 12.5, 15}︎✘ {0, 5, 10, 15, 20, 25}︎✘ Question B Given the system \\({\\mathbf S}_{n+1} = g( {\\mathbf S}_n)\\) with \\(g(S) \\equiv 5 + S/2\\), which of these is NOT a trajectory of the system? {0, 5, 7.5, 8.75, 9.375, 9.6875, 9.84375, 9.921875, 9.9609375, 9.98046875, 9.990234375}︎✘ {1, 5.5, 7.75, 8.875, 9.4375, 9.71875, 9.859375, 9.9296875, 9.96484375, 9.982421875, 9.9912109375}︎✘ {-4, 3, 6.5, 8.25, 9.125, 9.5625, 9.78125, 9.890625, 9.9453125, 9.97265625, 9.986328125}︎✘ {10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10}︎✘ {4, 7, 10, 13}Good.  Exercise XX.XX: DzIhgb Question A Use the sandbox above to construct 50 steps of the dynamics of \\(g(x) \\equiv -0.8 x + 2\\) starting at \\(x_0 = 10\\). Which of these best describes the graph \\(x_n\\) versus \\(n\\)? (Hint: It’s always best to try to figure out the command on your own. If you get stuck, press the ‘Solution’ button in the sandbox.) A steady exponential decay to about \\(x=3\\).︎✘ An oscillating exponential growth.︎✘ An oscillating exponential decay to about \\(x=1.1\\).Correct.  A sine wave with period \\(P=\\pi\\).︎✘ Exercise XX.XX: 9mSE8t Question A For the arithmetic sequence with \\(x_0 = 2\\) and \\(b=3\\), what is the numerical value \\(x_{100}\\)?     203︎✘        230︎✘        302\\(\\heartsuit\\ \\)       320︎✘        Not enough information given.︎✘ Question B For the geometric sequence with \\(x_0 = 2\\) and \\(\\alpha = \\frac{1}{2}\\), what is the numerical value \\(x_{10}\\)? 1/1028︎✘ 1/512Correct. \\(2 \\times \\frac{1}{2}^{10} = 2 / 1024 = 1/512\\) 512︎✘ 1028︎✘ Not enough information given.︎✘ Question C For the affine sequence with \\(x_0 = 2\\) and \\(\\alpha = \\frac{1}{2}\\) and \\(b=10\\), what is the numerical value of \\(x_{100}\\)? (These answers are shown to only one decimal point.) Hint: What is \\(\\alpha^{100}\\)?     20.0\\(\\heartsuit\\ \\)       -20.0︎✘        \\((1/2)^{100}\\)︎✘        0.0︎✘ Exercise XX.XX: FUIt1Q A debit card is a way to make withdrawals from a bank account. Funds in the account earn interest. In the economic environment of 2021, the interest rate is practically zero. But to make it possible to see the growth on a graph, we will stipulate it to be 4% per year. But if the account is in debt, then the debt grows at a much faster rate, perhaps 15% per year. Suppose the amount in the bank account is \\(m\\) (in dollars) and time is \\(t\\) (in years). If \\(m\\) is positive, you are earning interest. If negative, you are in debt and the debt will grow. Which of the following graphs reflects the dynamics of the system? Figure 48.4: Scenarios A and B Figure 48.5: Scenarios C and D On the graph paper below, sketch out the modifications of the bank-card dynamics described. Identify any fixed points by marking them on the graph and say if they are stable or unstable. In addition to the normal bank-card dynamics, your employer makes a steady retirement deposit into your account at the rate of $100 per year. Your darling aunt looks at your account balance. If you have less than $300 in your account, she will add money daily at a rate of $100 per year. Otherwise, she does nothing. Exercise XX.XX: Amzsqx We will be using a handful of Greek letters in our mathematical notation. You should learn these by heart: \\(\\alpha\\) : alpha (lowercase) \\(\\beta\\) : beta (lowercase) \\(\\gamma\\) : gamma (lowercase) \\(\\delta\\) : delta lowercase \\(\\lambda\\) : lambda (lowercase) \\(\\Lambda\\) : lambda (uppercase) \\(\\omega\\) : omega (lowercase) \\(\\xi\\) : xi (lowercase), pronounced “ex-eee” \\(\\eta\\) : eta (lowercase) The last two of these, \\(\\xi\\) and \\(\\eta\\) are the Greek equivalents to the familiar \\(x\\) and \\(y\\). We’ll see \\(\\xi\\) and \\(\\eta\\) as arguments to functions that we will quickly be re-scaling and renaming \\(x\\) and \\(y\\). On a piece of paper, write out each of the following Greek letters and, alongside it, the name of the letter. \\(\\gamma\\) \\(\\beta\\) $ \\(\\xi\\) \\(\\Lambda\\) \\(\\lambda\\) \\(\\eta\\) \\(\\alpha\\) Exercise 24.20: uifJjv Recall the medieval math problem about rabbits, which we wrote as a dynamical system \\[x_{n+1} = x_n + y_n\\\\y_{n+1} = x_n \\ \\ \\ \\ \\ \\ \\ \\ \\ \\] Rewrite this system in matrix form \\[{\\mathbf X}_{n+1} = {\\mathbf A} \\cdot {\\mathbf X}_n\\ \\ \\ \\text{where}\\ \\ {\\mathbf X}_n \\equiv \\left[\\begin{array}{c}x_n\\\\y_n\\end{array}\\right]\\] Here are several candidates for the matrix \\({\\mathbf A}\\) that implements the rabbit dynamics: \\[{\\mathbf A}_1 \\equiv \\left[\\begin{array}{cc}1 &amp; 1 \\\\ 0 &amp; 1\\end{array}\\right], \\ \\ {\\mathbf A}_2 \\equiv \\left[\\begin{array}{cc}1 &amp; 0 \\\\ 0 &amp; 1\\end{array}\\right], \\ \\ {\\mathbf A}_3 \\equiv \\left[\\begin{array}{cc}1 &amp; 0 \\\\ 1 &amp; 1\\end{array}\\right], \\\\ {\\mathbf A}_4 \\equiv \\left[\\begin{array}{cc}1 &amp; 1 \\\\ 1 &amp; 1\\end{array}\\right], \\ \\ {\\mathbf A}_5 \\equiv \\left[\\begin{array}{cc}1 &amp; 1 \\\\ 1 &amp; 0\\end{array}\\right], \\ \\ {\\mathbf A}_6 \\equiv \\left[\\begin{array}{cc}1 &amp; 0 \\\\ 1 &amp; 0\\end{array}\\right]\\ \\] Question A Which of the candidates will implement the rabbit dynamics? \\({\\mathbf A}_1\\)︎✘ \\({\\mathbf A}_2\\)︎✘ \\({\\mathbf A}_3\\)︎✘ \\({\\mathbf A}_4\\)︎✘ \\({\\mathbf A}_5\\)Nice!  \\({\\mathbf A}_6\\)︎✘ If you want to iterate the system \\({\\mathbf X}_{n+1} = {\\mathbf A}\\, {\\mathbf X}_n\\), you can use the Iterate() operator, handing it the matrix \\({\\mathbf A}\\) as argument \\(A=\\). Use the sandbox to create a matrix named A corresponding to the rabbit dynamics from the initial condition \\((1, 0)\\). (Note: the matrix that’s given by default is just a placeholder. It’s not the correct rabbit-dynamics matrix.) # enter your matrix here A &lt;- matrix(c(0.5, 1, 1, 0), nrow=2, byrow=TRUE) A # print the matrix so you can confirm you have it right Iterate(A = A, x0 = c(1, 0), n=10) Once you have your matrix \\({\\mathbf A}\\) correctly defined for the rabbit dynamics, and have confirmed the trajectory is what it should be, replace the initial condition (1, 0) with this one: (0.5247311, -0.8506508) That’s a funny initial condition for modeling rabbits, because you can’t have fractional rabbits and especially you can’t have negative rabbits. But that initial condition—even if it’s not about rabbits—produces a very special kind of dynamics. Question B Iterate the rabbit matrix \\({\\mathbf A}\\) from the initial condition \\((0.5247311, -0.8506508)\\). (Double check that you have entered it exactly as spelled out here.) The rabbit population starting at initial condition \\((1, 0)\\) grew in an unbounded way. What happens when you use the funny initial condition instead? The fixed point at (0,0) becomes stable.︎✘ The stability of the fixed point depends only on the \\({\\mathbf A}\\) matrix, not on the initial conditions. The x value oscillates and grows, then gets smaller again.︎✘ The x value oscillates and gets smaller, then grows without bound.Excellent!  The x value oscillates around and around, without getting larger in magnitude.︎✘ This behavior may seem strange now. You’ll understand it better when we introduce a powerful way of looking at matrix dynamics: eigenvalues and eigenvectors. More generally, since the rod has mass and the pendulum bob is not a single point, you need to know the distribution of mass along the pendulum, from which you can calculate quantities such as the moment of inertia.↩︎ "],["solve-DE.html", "Chapter 49 Finding a solution 49.1 The flow field 49.2 Euler method 49.3 Symbolic solutions 49.4 Exercises", " Chapter 49 Finding a solution Idea of accumulation Numerical solution: Euler method and iteration Analytic solution: Ansatze and confirming a solution Some special cases, separable equations Laplace transforms As you saw in the previous chapter, a differential equation relates the derivative of a function to the function itself, for instance \\[\\partial_t x(t) = x(t)\\,(1-x(t))\\ .\\] Solving a differential equation means to find a function \\(x(t)\\) that is consistent with the equation. This chapter is about techniques for finding solutions. It’s tempting—but not usually possible—to apply the symbolic anti-differentiation techniques from Block 3 to the problem. After all \\[\\int \\partial_t x(t) dt = x(t)\\,\\] as described in the “fundamental theorem of calculus”. Following this logic, we would translate the equation to \\[x(t) = \\int x(t)\\, (1-x(t))dt\\ .\\] But in order to carry out the anti-differentiation, we would need to know \\(x(t)\\) itself, which is the function we are trying to find. Nonetheless, it’s common to refer to integrating a differential equation, but this should be broadly understood as accumulating the increments \\(\\partial_t x(t)\\) starting at some initial condition \\(x(t_0)\\), even if that accumulation is not carried out by symbolic anti-differentiation. In this chapter we’ll introduce four different techniques to accumulating a solution to a differential equation or a pair of such equations. First, we’ll look again at the graphical method of “following the flow” in a plot of the flow field. This technique is mainly of use for developing intuition about the dynamics. Second, we’ll develop a simple Euler method for accumulating a solution. Third, we’ll explore how to take a guess about the solution and, when the guess is good enough, refine that into an actual solution. This is called the method of ansëtze. Fourth, and briefly, we’ll look at some of the situations where symbolic anti-differentiation can be used. This includes a very brief introduction to transform methods. A differential equation like \\[\\partial_t x(t) = x(t)\\,(1-x(t))\\] is very busy typographically. One reason is the repeated \\((t)\\) which play no role other than to state explicitly that \\(x\\) is a function of \\(t\\). A convenient shorthand simply replaces \\(x(t)\\) to make the “is a function of \\(t\\)” implicit. Thus the equation appears as \\[\\partial_t x = x (1-x)\\ .\\] It’s the reader’s responsibility, knowing that he or she is working with a differential equation, to remember that \\(x\\) is a function of \\(t\\). An even more concise notation, originated by Isaac Newton, is to replace the \\(\\partial_t\\) with a simple \\(\\dot{\\ }\\). With this notation the equation looks like \\[\\dot{x} = x (1-x)\\ ,\\] about as simple as it gets. This dot notation is even more expressive when working with second-order differential equations involving second derivative. In the dot notation, \\(\\partial_{tt}\\) is written \\(\\ddot{\\ }\\). 49.1 The flow field With a pair of differential equations, as with the pendulum or the rabbit-fox model, each equation gives one component of the change in state. To draw the flow field, pick one point at a time from the state space, and calculate the right-hand sides of the differential equation from each equation. If the parameters in the model have been assigned numerical values, the result of evaluating the right-hand sides will be two numbers. A case in point is the rabbit-fox model where the state variables are \\(r\\) and \\(f\\). The differential equations are \\[\\partial_t r = 0.66 r - 1.33 r f\\\\ \\partial_t f = -f + rf\\\\ \\] To draw the flow arrow at, say, \\(r=2, f=1/4\\), plug those values into the right-hand side: \\[\\partial_t r = 1.33 - 0.66 = 0.66\\\\ \\partial_t f = -0.25 + 0.5 = 0.25\\ .\\] Since \\(r\\) has units of rabbit density, \\(\\partial_t\\) has units rabbit density per day (or some other time unit). Similarly \\(\\partial_t f\\) has units of fox density per day. The coordinate axis of rabbit-fox state space have units of rabbit density and fox density. We can’t therefore plot rabbit density per day and fox density per day in the state space. However, the ratio \\(\\frac{\\partial_t f}{\\partial_t r}\\) has units fox density per rabbit density. These are the units of a slope in the state space. Centered at coordinate \\((r=2, f = 1/4)\\), draw an sloping line segment. Given the values \\(\\partial_t f = 0.25\\) and \\(\\partial_t f = 0.66\\), the segment should have slope \\(0.25/0.66 = 0.379\\). Also, place an arrowhead on the segment. You can decide which end of the segment it goes by noting the signs of \\(\\partial_t f\\) and \\(\\partial_t r\\). Both are positive in this example, so the arrowhead should point up and to the right. This flow arrow is drawn in Figure 49.1. Figure 49.1: The flow arrow for the state value \\((r=2, f=1/4)\\). To draw the entire flow field, repeat this process at many other points in the state space. To trace out the trajectory, select the initial condition for the system. Then follow the flow, taking only a small step in state space. The next step should be in the direction of the flow arrow at the end of the previous step. The trajectory you draw will be only a sketch, but it can be effective for developing intuition. Figure 49.2 shows a semi-automated version of the go-with-the-flow method. The computer has been used to draw the arrows. When you click in the plot, the computer also undertakes calculation of the trajectory. Figure 49.2: The flow field for the rabbit/fox dynamics. Click at an initial state to generate the trajectory from that state. Regretably, from such a sketch of the trajectory, you can’t easily construct \\(r(t)\\) and \\(f(t)\\) for time-series plots. Also, you don’t get a sense of how slow or fast the flow is going. Click at different initial conditions in the flow and you will see different trajectories, each of which is a closed loop. But the shape of the trajectory doesn’t tell you whether it takes a long time or a short time to complete a loop. The next section will show you how the computer constructed the trajectory and how we can get information on the speed of the flow. 49.2 Euler method Recall from Block 2 the limit definition of the derivative: \\[\\partial_t x(t) = \\lim_{dt \\rightarrow 0} \\frac{x(t + dt) - x(t)}{dt}\\ .\\] We’re going to use this definition to develop a very general way to solve differential equations: the Euler method. From the differential equations, we already know \\(\\partial_t x(t)\\), so we don’t have to worry about whether the limit exists; it does. So we’ll disregard the limit except to note that \\(dt\\) must be small. How small? Pick \\(dt\\) to be small enough that the result wouldn’t change in any substantial way if we used an even smaller time increment, say \\(dt/10\\). Our starting point for solving each differential equation is to re-write it as a finite difference. To illustrate, we’ll solve the equation \\(\\partial_t x = x (1 - x)\\), which is often called the logistic equation. Applying the finite difference definition, we get \\[\\frac{f(t + dt)- f(t)}{dt} = x (1-x)\\\\\\text{implying}\\\\ \\ \\\\ \\underbrace{f(t + dt)}_{\\text{future state}} = \\underbrace{f(t)}_{\\text{current state}} +\\ \\ \\ \\underbrace{x (1-x) dt}_{\\text{step}}\\] We call this last equation the Euler formula. To use this, we start at the initial condition, say \\(x(t=0) = 0.2\\). This initial condition gives us the first row of a tabular representation of the function \\(x(t)\\): time state 0 0.2 Next, pick a value for \\(dt\\) that we will use for all the following steps, each of which will add a new row to the table. For the example, we’ll set \\(dt = 0.1\\). When we have constructed the whole table we can go back and check whether that was small enough. To fill in the next row, we apply the Euler formula. Sine \\(dt = 0.1\\), the next time step will be \\(0.1\\). Plug in the current state—which is 0.2 right now—to calculate the future state. The step will be \\(0.2 (1-0.2)\\, dt = \\color{brown}{0.016}\\). Add this step to the current state to get the future state. The table now looks like this: time state 0.0 \\(0.2\\) 0.1 \\(0.2 + \\color{brown}{0.016} = \\color{blue}{0.216}\\) The next step will bring us to time \\(0.2\\). Use the Euler formula, pluggin in the value of the present state, \\(\\color{blue}{0.216}\\), to find the step. Here that will be \\(0.216 (1-0.216)\\, dt = \\color{magenta}{0.0169.}\\). Now the table looks like time state 0.0 \\(0.2\\) 0.1 \\(0.2 + \\color{brown}{0.016} = \\color{blue}{0.216}\\) 0.2 \\(\\color{blue}{0.216} + \\color{magenta}{0.0169} = 0.2329\\) Add as many rows to the table as you like; the process will be the same. You will recognize this as an iterative process, as discussed in Chapter 32. Example 49.1 As is so often the case, it’s wise to think about carrying out processes in terms of fundamental tasks accomplished by calculus operations—evaluate, differentiate, anti-differentiate, solve, find argmax, iterate. The obvious choice for integrating differential equations is “anti-differentiate,” but as described previously, the techniques we covered in Block 3 are not sufficient for the task. Instead, we use iteration to solve differential equations. In this example we’re going to use the software you have already seen, Iterate(), to carry out the task. In practice, however, you will use a special form of Iterate() called integrateODE() that makes use of interpolation techniques to give a more precise answer. To implement the iteration to solve \\(\\partial_t x = x (1-x)\\), we need to create a function that takes the current state as input and produces the next state as output. Our one-step function can be this: next_step &lt;- function(t, x, dt=0.1) { t &lt;- t + dt x &lt;- x + x*(1-x)*dt c(t=t, x=x) # return value } Notice that we wrote next_step() with an input slot for \\(dt\\). This will not be part of the state being iterated, just a parameter that allows us easily to explore different values for \\(dt\\). Use Iterate() to carry out the iteration of next_step(). Note that we use the fargs argument to Iterate() to pass our selected value for dt to the function next_step(). We’ll run the iteration for 100 steps. With \\(dt=0.1\\), those 100 steps will 10 units of time. Soln &lt;- Iterate(next_step, x0=c(t=0, x=0.2), n=100, fargs=list(dt=0.1)) n t x 0 0.0 0.2000000 1 0.1 0.2160000 2 0.2 0.2329344 … and so on … 99 9.9 0.9998595 100 10.0 0.9998736 We can now plot the time series \\(x\\) vs \\(t\\): Figure 49.3: The time series by the Euler method with \\(dt=0.01\\). In the previous example using Iterate() to solve a differential equation, the output of the iteration was a data frame containing values for the solution at discrete times: 0, 0.1, 0.2, and so on. A data table is a perfectly good way to represent a function, but it’s handier to have a function in a form that operations like slice_plot() and D() can be applied to. Another way to look at things is that, mathematically, the solution to a differential equation should be a continuous-time function. Fortunately, we have at hand the interpolation techniques covered in Chapter 33 to carry out the construction of a continuous-time function from a tabular representation. The R/mosaic function integrateODE() connects together the iteration and interpolation to provide a solution that is in the form of continuous-time function(s). Use the R/mosaic function integrateODE() to solve differential equations numerically. It is a specialized function that handles sets of first-order differential equations, but any high-order differential equation can be separated into a set of first-order equations. To illustrate, this command will solve the differential equation \\(\\partial_t x = x (1-x)\\) that we took on in the previous example with Iterate(). Soln2 &lt;- integrateODE(dx ~ x*(1-x), x = 0.2, tdur=list(from=0, to=10, dt=0.01)) The first argument is a tilde expression, but in a form that’s different from from that used in functions such as D() or contour_plot(), etc. To the left of the tilde is a single name composed of the state variable—x here—prefixed by a d. The d is just a reminder that we are describing not x itself, but \\(\\partial_t\\ \\mathtt{x}\\). On the right of the tilde is the function from the differential equation, in this case, \\(x(1-x)\\). The next argument is the initial condition. We’re starting the integration at \\(x=0.2\\). Finally, the argument named tdur= consists of a description of the starting and ending times and the time-step size \\(dt\\). The output of integrateODE() is an R structure that is new to us. It contains the function created by integrateODE() which you refer to by name (x) using a special form of R punctuation $. In other words, Soln2$x will be a function, which you can plot like any other function, for instance: slice_plot(Soln2$x(t) ~ t, domain(t=0:10)) An important feature of integrateODE() is its ability to handle sets of first-order differential equations. For instance, the rabbit/fox system \\[\\partial_t r = 0.66\\, r - 1.33\\, r f\\\\ \\partial_t f = -f + rf\\] will be integrated by this command: Eco_soln &lt;- integrateODE( dr ~ 0.66*r - 1.33*r*f, df ~ -f + r*f, r = 2, f = 0.5, #initial conditions tdur=list(from=0, to=5, dt=0.1)) You can plot the time series using slice_plot() slice_plot(Eco_soln$r(t) ~ t, domain(t=0:5)) %&gt;% gf_labs(title=&quot;Rabbits&quot;) slice_plot(Eco_soln$f(t) ~ t, domain(t=0:5)) %&gt;% gf_labs(title=&quot;Foxes&quot;) Figure 49.4: Times series of the rabbit and fox densities. To plot the trajectory, use the traj_plot() function. Unlike slice_plot(), which creates a time series plot, traj_plot() shows the trajectory. traj_plot(f(t) ~ r(t), Eco_soln, nt=10) 49.3 Symbolic solutions Occasionally it is possible to integrate a differential equation using symbolic techniques. This is particularly true for differential equations that are linear. The example we will handle here is the first-order linear differential equation \\[\\partial_t x = a\\, x\\ .\\] An advantage of symbolic solutions is that parameters can be handled symbolically. A method we will use repeatedly in this block is called the “method of ansätze.” An ansatz (singular of the German “ansätze”) is, in this context, a guess for the solution. Since differential equations have been a central part of science for more than 200 years, you can imagine that a large library of equations and their solutions has been assembled. For the equations that are most frequently used and that can be solved symbolically, the solutions are already known. Thus, the “guess” for the solution can be a very well informed guess. Let’s see how this works for \\(\\partial_t x = a\\, x\\). From experience, the ansatz will be an exponential function of time, which we can write \\(x(t) \\equiv A e^{\\omega t}\\). We don’t yet know what is the value of \\(\\omega\\) or \\(A\\), so we plug the ansatz into both the left and right sides of the differential equation to work it out. Plugging in the ansatz, translates the differential equation to a new form: \\[\\underbrace{A \\omega e^{\\omega t}}_{\\partial_t x(t)}\\ =\\ \\underbrace{a A e^{\\omega t}}_{a x(t)}\\ .\\] Cancelling out the terms that appear on both sides of the equation gives \\[\\omega = a\\ \\ \\ \\text{which implies}\\ \\ \\ x(t) = A e^{a t}\\ .\\] The ansatz substitution didn’t give any result at all for \\(A\\). That is to say, unlike \\(\\omega\\), the \\(A\\) is not determined by the differential equation itself. This means that \\(A\\) must be related to the initial condition. Setting \\(t=0\\) gives \\(x(0) = A\\), so in this simple differential equation, \\(A\\) is the initial condition. A technique that doesn’t involve such guesses can work for differential equations that are separable. This is mainly valuable, now that there are libraries of symbolic solutions to the common differential equations that have them, as a way of demonstrating to students where the solution comes from. We’ll demonstrate by integrating \\(\\partial_t x = x (1-x)\\). The method is made more plausible by using the Leibnizian notation for derivatives, with which the differential equation has this form: \\[\\frac{dx}{dt} = x(1-x)\\ .\\] The Leibnizian notation can be interpreted as the ratio of two differentials: \\(dx\\) and \\(dt\\) in this case. The idea of separating the differential equation is to algebraically move all the \\(x\\) terms to the left side of the equation and all the \\(t\\) terms to the right and then to integrate each side of the equation. \\[dx = x(1-x) dt \\ \\ \\ \\implies \\ \\ \\ \\frac{1}{x(x-1)}dx = dt\\ \\ \\ \\implies\\ \\ \\ \\int\\frac{1}{x(x-1)}dx = \\int dt .\\] The integral on the right side, \\(\\int dt\\), should be easily recognizable, giving \\(\\int dt = t + F\\), where \\(F\\) is the “constant of integration.” The integral on the left side may not be as familiar, but the person solving this problem for the second time will remember that \\[\\frac{1}{x(1-x)} = \\frac{1}{x} + \\frac{1}{1-x}\\] as you can confirm by putting the right side over a common denominator. Each of \\(1/x\\) and \\(1/(1-x)\\) have integrals that are logs: \\(\\int dx/x = \\ln(x) + D\\) and \\(\\int dx/(1-x) = - \\ln(1-x) + E\\). Putting the equation back together again, produces \\[\\ln(x) + D - \\ln(1-x) + E = t + F\\ .\\] At this point, move all the constants of integration over to the right side and consolate them into a single constant of integration \\(C\\). At the same time, collect together the two logarithmic terms, giving: \\[\\ln\\left(\\frac{x}{1-x}\\right) = t + C\\ .\\] Exponentiate both sides to get: \\[\\frac{x}{1-x} = \\underbrace{e^C}_{A} e^t\\ .\\] Since \\(e^C\\) is just a constant, we’ll write it more simply as \\(A\\). Now we have \\[x = Ae^t - x A e^t \\ \\ \\implies\\ \\ \\ x (1 + Ae^t) = Ae^t\\] which gives our solution \\[x = \\frac{Ae^t}{1 + Ae^t}\\ .\\] To find the initial condition symbolically, plug in \\(t=0\\), giving \\(x_0 = A/(1+A)\\) or, equivalently \\(A = x_0/(1-x_0)\\). Our previous examples used \\(x_0 = 0.2\\), for which \\(A = 0.2/0.8 = 0.25\\). Graphing this solution gives us the familiar sigmoid: Symb_soln = makeFun(A*exp(t)/(1 + A*exp(t)) ~ t) slice_plot(Symb_soln(t, A=0.2) ~ t, domain(t=-5:10)) Not all differential equations can be separated in this way, and even for those that can, the integrals may not be tractable. So this route to a solution is not a general-purpose one, unlike the Euler method. Still, the Euler method gives only an approximate solution, so with Euler we need to take care that the approximation is close enough for the purpose at hand. In this case, we have both an Euler solution (with \\(dt=0.1\\)) and a symbolic solution. Figure 49.5 shows the difference between the two solutions, which ideally should be zero. To show more of the time domain of the solution, we’ll reset the initial condition to \\(x_0 = 0.01\\). This corresponds to \\(A = 1/99\\). Figure 49.5: The difference between the Euler and the symbolic solution to \\(\\partial_t x = x (1-x)\\) as a fraction of the symbolic solution. At the worst, the Euler solution is off by 1.5 parts in one-million. 49.4 Exercises Exercise XX.XX: Z3Mq3G Figure 49.4 shows time series for the rabbit and fox population density starting at the initial condition \\(r=2, f=0.5\\) for the first 5 time units thereafter. The fox graph looks like a hump function, the rabbit graph show a little uptick near \\(t=5\\). Using the R/mosaic commands given in the text to make Figure 49.4, integrate the equations from \\(t=0\\) to \\(t=15\\) and plot the time series for both rabbits and foxes. A. Using the time-series plots, estimate the period of the cyclic oscillations. - What is the period of the fox population cycle? - How large in amplitude (peak to trough) is the fox population cycle? - How do the cycle period and amplitude for the rabbits compare to those for the foxes? B. Change the initial condition from \\(r=2, f=0.5\\) to \\(r=1, f=0.5\\) and plot the time series. - What is the period of the fox population cycle? - How large in amplitude (peak-to-trough) is the fox population cycle? Exercise XX.XX: Ul19SO Figure 49.5 shows the difference between the symbolic solution to \\(\\partial_t x = x (1-x)\\) and the Euler solution. The figure shows that the Euler solution (with \\(dt=0.1\\)) has an approximation error that’s small. The worst case is when \\(t \\approx 3\\) at which point it is less than 1.5 parts per million. Another good way to quantify this is the decimal place at which the calculated solutions differ. Euler &lt;- integrateODE(dx ~ x*(1-x), x=0.01, tdur=list(from=0, to=20, dt=0.1)) Symb_soln = makeFun(A*exp(t)/(1 + A*exp(t)) ~ t, A=1/99) Symb_soln(3) ## [1] 0.1686648 Euler$x(3) ## [1] 0.1686645 The approximation error occurs in the seventh decimal point. A. How large can \\(dt\\) be to keep the approximation error in the fourth decimal place of the answer. B. How large can \\(dt\\) be to keep the approximation error in the second decimal place of the answer. Exercise XX.XX: jd6HE8 The differential equation \\(\\partial_t x = a x\\) is so commonly encountered that you should simply memorize the solution: \\[x(t) = A e^{a t}\\] which you can recognize as exponential growth (or decay, if \\(a &lt; 0\\)) from an initial condition \\(x_0 = A\\). Exponential growth is considered fast, but there are far faster forms of growth. To illustrate, consider the differential equation \\[\\partial_t x = a x^2\\ .\\] This can be interpreted in terms of a model of the size of the flame as one lights a match. Think of the flame as a ball of hot gas of radius \\(x\\); the gas include oxygen (O_2_), nitrogen, and carbon dioxide, as well as a vapor of the combustible material such as the potassium chlorate of the match head. Within the ball of flame, O_2_ reacts with the cumbustible material to produce the products of combustion and heat. Needless to say, this reaction eliminates the O_2_ in the ball. But O_2_ can diffuse into the ball from outside. The O_2_ infusion rate available in this way is proportional to the surface area of the ball, that is, \\(a x^2\\). Thus the differential equation models the growth of the flame ball. The match-flame equation is one that can be separated into parts: all the \\(x\\) components on one side, the \\(t\\) on the other. That is: \\[\\underbrace{\\frac{dx}{dt} = a x^2}_{\\text{original DE}}\\ \\ \\ \\implies \\underbrace{\\frac{dx}{x^2} = a dt}_{\\text{separated DE}}\\] Integrating both sides of the separated equation will produce \\(a t + C\\) on the right side. A. Integrate the left side of the separated equation and use that to find a relationship between \\(x\\) and \\(a t + C\\). B. The constant of integration, \\(C\\), will reflect the initial condition. Plug in \\(t=0\\) and calculate from the relationship in (A) what is \\(C\\) in terms of \\(x_0\\). C. Replace \\(C\\) in your relationship with the expression in terms of \\(x_0\\) you found in (B). Confirm that this is \\[x(t) = \\frac{1}{a t - 1/x_0}\\ .\\] D. \\(x(t)\\) has a vertical asymptote. Find it. E. Use integrateODE() to integrate the original differential equation. You will have to pick some numerical value for \\(a\\) and \\(x_0\\). Take care to make \\(dt\\) small enough. You’ll know that \\(dt\\) is small enough when you get the approximately same solution using \\(dt/10\\). F. Describe in everyday words what the solution says and how big the ball of flame becomes. The model \\(\\partial_t x = a x^2\\), like all models, includes some features of the real-world system and excludes others. In this case, once the ball reaches a critical diameter, there is no longer enough combustion product to continue the reaction at the rate depicted in the model. If you watch a match being lit, you will see both the explosion and the eventual exhaustion of the combustion material. "],["flow-on-line.html", "Chapter 50 Flows on the line 50.1 The rules of the road 50.2 Linearization 50.3 Nonlinearity", " Chapter 50 Flows on the line Classify fixed points as stable/unstable given the dynamics Identify the dynamics of constant growth Compute Euler solutions (format for expressing the system and the format of the result) Analyze models in application contexts (for example May’s Cows - a model of bistability in ecology) Examples of linearization: Newton’s Law of Cooling, Hooke’s Law Last year’s daily digitals from DD-15 to about DD-20 The first chapter of this Block introduced a framework for modeling dynamics in continuous time: a dynamical state variables and dynamical functions giving the instantaneous change of each state variable as a function of the values of the state variables at that instant. The second chapter covered several methods of extracting a solution from the model, that is, a function of time for each of the state variables that is consistent with the differential equations. We looked at the solution in two ways: a trajectory in state space or a time-series graph. Ultimately, our goal is to make models of real-world systems. These models can enhance our understanding of the mechanisms active in the real world. The models can also make predictions of various sorts. But you are not yet in a position to know what “various sorts” of predictions can mean or to see how to construct a dynamical model. To get you there, you’ll need to learn about some general features of dynamical systems that allow us to think about them at a high level. We start with the simplest sort of dynamical system: first-order systems, that is, ones with a single state variable. With a single variable, the state space is one-dimensional: the number line. 50.1 The rules of the road A physical analogy to give a better intuition about dynamics in a one-dimensional state space. We’ll imagine that the state space is represented by a road, the instantaneous state being the location of a car along that road. On a real road, the motion of the car is set by the driver using the accelerator and brakes and constrained by other traffic and road conditions. In our state-space road, the velocity of the car is strictly dictated by an authoritarian government law: no exceptions. When the dictated speed is zero, the car will stand still and cannot start moving again. Ultimately, depending on the shape of the law, the car will head off to infinity or come to an eternal standstill. Two different cars can never collide on this road: if the cars are close together, they must be travelling at similar velocities. Cars can’t pass one another in different directions. Passing requires that the two cars have opposite velocities: one positive and one negative. If the mandated velocity at a point along the road is positive, every car that comes to that point must have the same positive velocity as it passes that point in the road. The diagram in Figure ?? shows one possible format for describing the regulations for a road. The road is shown as a grey line. The red numbers are mile-markers alongside the road. The function graph shows the mandated speed at any point: you can read off the numerical value of the mandated speed on the y-axis. To better visualize the flow of traffic on the road, in Figure 50.1 we draw vectors on the road. The direction of each vector will be either east or west; the length of the vector gives the required speed for a car passing that point. Figure 50.1: The mandatory speed on the road. Cars arriving from the west are obliged to stop their journey at about \\(x=4\\) where the arrows switch direction. Similarly, cars arriving from the east will be driving west, but their journey has a different destination, mile 13, where the velocity regulations change direction. The easterners will be obliged to stop at the point where the left-facing arrows meet the right-facing ones. A car starting near mile 10 will be obliged to drive east but can go only to mile 13; a car starting at mile 7 will drive west until reaching mile 4. This is a lot of detail in the shape of the dynamical function—I mean, the road regulations. So far as the consequences of the road regulations go, the situation is simpler: cars standing still at mile 4 or at mile 13, depending on where they started from. Zooming in on the dynamics near mile 4 or 13 helps to show what happens as the cars approach those points. (Figure 50.2) At either point, the action is similar. Cars coming from the west have to slow down as the arrows get smaller. Similarly for cars from the east. Where east meets west the cars are forced to a standstill; in order for the vectors to have different directions on the west end of the road than on the east end, the length of the vectors has to go to zero. Figure 50.2: The road regulations near mile-markers 4 and 13. The fixed point is marked with a small dot. Such a point in the state space, where the flow arrows converge, is called a stable fixed point. The “fixed” merely means that the cars come to a standstill. “Stable” means that all cars starting near the fixed point are heading toward that point. Many details of the dynamics near the fixed point have no role in the eventual outcome. For instance, the dynamical function near mile-marker 4 is concave down, while that at mile-marker 13 is concave up. In both cases the behavior of the system is the same: convergence at the stable fixed point. Newcomers understandably endow the car-on-road or bead-on-wire analogies to the state space of a first-order system with other familiar properties of the real world. For instance, a real-world wire has friction which needs to be overcome by applying a force. A real-world car has momentum which prolongs motion even after force has been applied. As you will see, a differential equation system that involves force and momentum requires a two-dimensional (or higher) state space. There is another fixed point on the road, but the behavior near it is different. Figure 50.3 zooms in on the situation near mile-marker 9. The outcome of the dynamics is very different than near miles 4 and 13. The fixed point near mile 9 is unstable. This means that any cars starting near the fixed point will drive away. Slowly at first and then faster as they get farther from the fixed point. Figure 50.3: An unstable fixed point in the road regulations. It’s an interesting philosophical question what happens to a car starting exactly on the fixed point. Since the velocity vector there has zero length, the car must stand still. But if the car happens to move one jot away from the fixed point, it will start to speed up and move away from the fixed point. The ideas of fixed points and their stability provides a much more concise description of the dynamical system: “There are stable fixed points near mile 4 and mile 13, as well as an unstable fixed point near mile 9.” It’s worth pointing out a consequence of the mathematics of continuous functions: if a system with a continuous dynamical function has a region of state space with two different fixed points, there must be an unstable fixed point in between them. 50.2 Linearization “Stable” and “unstable” provide a useful qualitative indication of the dynamics near a fixed point. An approximate quantitative solution can also be found. Recall that any continuous function can be approximated locally by a low-order polynomial. For a function \\(g(x)\\) with only one input, “locally” means “near \\(x^\\star\\),” and the polynomial will be \\[g(x) \\approx a + b \\left[x-x^\\star\\right] + c \\left[x-x^\\star\\right]^2 + \\cdots\\] The coefficients \\(a, b, c, \\cdots\\) can be calculated from the value of the function and it’s derivatives at \\(x^\\star\\): \\[a = g(x^\\star)\\ \\ \\ \\ b = \\partial_x g(x^\\star) \\ \\ \\ \\ c= \\frac{1}{2} \\partial_{xx} g(x^\\star)\\ \\ \\ \\text{and so on.}\\] When \\(x^\\star\\) is a fixed point of the dynamics, then \\(g(x^\\star) = 0\\) so the approximating polynomial is \\[g(x) \\approx b \\left[x-x^\\star\\right] + c \\left[x-x^\\star\\right]^2 + \\cdots\\] If \\(x-x^\\star\\) is small enough, then the higher-power terms like \\(\\left[x-x^\\star\\right]^2\\) will be negligible and the approximation can be \\[g(x) = \\partial_x g(x^\\star)\\ \\left[x-x^\\star\\right]\\ .\\] To linearize a dynamical function near a fixed point requires two steps: Solving task: Find a numerical value for the fixed point, that is, a value for \\(x^\\star\\) such that \\(g(x^\\star) = 0\\). Differentiating task: Evaluate the derivative \\(\\partial_x g(x)\\) at \\(x=x^\\star\\). (Another way of writing this is \\(\\partial_x g(x)\\left.{\\Large\\strut}\\right|_{x=x^\\star}\\) or, more simply, \\(\\partial_x g(x^\\star)\\).) To find the solution to the differential equation near the fixed point requires additional a couple of additional steps: Translate the state variable \\(x\\) into a new state variable \\(y = x - x^\\star\\). In terms of this new state variable, the approximate dynamics are \\(\\partial_t y = b y\\), where \\(b\\) is the value found in step (ii). The solution to the differential equation in (iv) is \\(y(t) = A e^{bt}\\). Find \\(A\\) in the solution as \\(y_0 = x_0 - x^\\star\\), where \\(x_0\\) is the initial condition of the state variable. So, \\(y(t) = (x_0 - x^\\star) e^{bt}\\). Finally, translate the solution in (iv) back into terms of \\(x\\). It will be \\[x(t) = (x - x_0) e^{b t} + x^\\star\\ .\\] Thus, the solution requires only two pieces of information knowing \\(x^\\star\\) and \\(b = \\partial_x g(x_0)\\). The stability of the fixed point is simply a matter of whether the exponential function in the solution is exponential growth (unstable) or exponential decay (stable). This is, of course, determined by the sign of the constant \\(b = \\partial_x g(x_0)\\): \\[\\partial_x g(x_0) &gt; 0\\ \\ \\ \\implies \\ \\ \\text{unstable}\\\\ \\partial_x g(x_0) &lt; 0 \\ \\ \\ \\ \\implies\\ \\ \\ \\ \\ \\ \\text{stable}\\] It’s critical to distinguish carefully between \\(x^\\star\\), which is the location of the fixed point being examined, and \\(x_0\\), which is the initial condition of the state, that is, \\(x(t=0)\\). Example 50.1 Let’s return to the model of saving for retirement in Chapter 48: \\[\\partial_t V = r\\, V + M\\ .\\] The state variable here is named \\(V\\). The dynamical function is \\[g(V) = r\\, V + M\\] where \\(r\\) is the interest rate (say, 3% per year which is \\(r=0.03\\) per year) and \\(M\\) is the monthly contribution. To keep the units consistent, we set the units of \\(t\\) to be years, of \\(r\\) to be 1/years, of \\(V\\) to be dollars and of \\(M\\) to be dollars-per-year. So a monthly contribution of $1000 would come to \\(M=12000\\) dollars-per-year. Find the amount \\(V\\) that will result from 30 years of savings with an initial condition \\(V_0 = 0\\). Step i) Find the fixed point. This is a value \\(V^\\star\\) such that \\[r\\, V^\\star + M = 0\\ \\ \\ \\implies \\ \\ \\ V^\\star = -M/r\\ .\\] Step ii) Find the derivative of the dynamical function evaluated at the fixed point: Since \\(g(V)\\) happens to be a straight-line function, we know the derivative is a constant. So \\(b = \\partial_x g(V^\\star) = r\\). Step iii) Translate the state variable into \\(y = V - V^\\star\\). The dynamics in terms of \\(y\\) are \\(\\partial_t y = b y\\), which has a solution \\(y = A e^{bt}\\). Step iv) \\(A\\) is the initial condition in terms of \\(y\\). This will be \\(y_0 = V_0 - V^\\star\\). Since we stated that \\(V_0 = 0\\) (no savings at the start), \\(y_0 = -V^\\star\\) and the solution is \\[y(t) = -V^\\star e^{bt} = \\frac{M}{r} e^{rt}\\ .\\] Step v) Translate the solution in step (iv) back into terms of \\(V(t)\\). Since \\(y(t) = V(t) - V^\\star\\), this will be \\(V(t) = y(t) + V^\\star\\) or, \\[V(t) = \\frac{M}{r} e^{r t} + V^\\star = \\frac{M}{r} \\left[ e^{r t} - 1\\right]\\ .\\] To get an idea of this retirement plan, that is, \\(r=3\\%\\) and \\(M=12000\\) dollars-per-year, let’s see how much you’ll have after 30 years and 40 years. V &lt;- makeFun((M/r)*(exp(r*t)-1) ~ t, r=0.03, M=12000) V(30) ## [1] 583841.2 V(40) ## [1] 928046.8 After 40 years of contributions, your retirement account will have almost one-million dollars. You could have accomplished the same calculation using integrateODE(), like this: Soln &lt;- integrateODE(dV ~ r*V + M, V=0, M=12000, r=0.03, tdur=40) Soln$V(30) ## [1] 583841.2 Soln$V(40) ## [1] 928046.8 EXERCISES: + some drill on setting up the solution near fixed points to linear and nonlinear equations, e.g. \\(\\dot{x} = r x (1-x)\\). + Which of these is a function and which is a constant: \\(V\\), \\(V^\\star\\), and \\(V_0\\). 50.3 Nonlinearity Systems with nonlinear dynamical functions can have multiple fixed points. The differential equation \\(\\partial_t x = x(1-x)\\) has two: one at \\(x^\\star = 0\\) and the other at \\(x^\\star = 1\\). The flow-field/dynamics-graph (Figure 50.4) makes it clear that one of these is stable and the other unstable. Figure 50.4: Flow field and dynamics function for \\(\\partial_t x = x (1-x)\\). The fixed point at \\(x^\\star=0\\) is unstable; that at \\(x^\\star =1\\) is stable. For the system in Figure 50.4, a initial condition \\(x_0 = 0.05\\) or any other small positive number will produce a trajectory that moves slowly to the right at first, then faster, then slows down again for asymptotically approaching the fixed point at \\(x=1\\). In a time series plot, \\(x(t)\\) is a sigmoidal function. ::: {.intheworld data-latex=\"“} We have been using the differential equation \\(\\partial_t x(1-x)\\) as a mathematical equation, but the form has important applications in population modeling and ecology. When parameterized, the model becomes \\[\\partial_t x = h(x) \\equiv r x \\left(1 - \\frac{x}{K}\\right)\\] For \\(x \\ll K\\), the dynamics are approximately \\(\\partial_t x = rx\\), which is the recipe for exponential growth. Such growth is often seen in small populations. But”small\" compared to what? To answer that, look at the situation for \\(x \\approx K\\). In this domain, the growth will be much smaller, because \\((1 - x/K) \\approx 0\\). There’s a fixed point at \\(x^\\star = K\\), and for \\(K &lt; x\\) the time derivative of \\(x\\) is negative. In ecology, the population size that can just barely sustain itself without growth or decay is called the carrying capacity. Putting these different behaviors together, \\(\\partial_t x = h(x)\\) is a model of growth of a population when the environment has a finite carrying capacity. The pattern of change in such an environment is called logistic growth, but might as well be called “sigmoidal growth.” (The function \\(f(x) = \\frac{e^t}{1 + e^t}\\) is called the “logistic function.”) In this problem, we’re going to build a somewhat more complicated model of an ecosystem, based on the logistic growth model for grass. To turn a field of growing grass into an ecosystem, we’re going to add grazing cows to the field. A grazing cow has an impact on a field. To simplify, consider a single cow. She eats until she’s full, then takes time off to chew the cud with other cows and ruminate on the day’s events. But, if grass is very scarce, she may not be able to consume all that she would otherwise eat. She’ll be a hungry, ill-fed cow. When building a model, start by thinking what you want to use the model for. Imagine that we’re interested in sustainability, that is, whether the cow/grass ecosystem is stable. And, since cows are raised for a purpose, we’d like to use the model to find out whether the cow would be well fed and how things would change if another cow were added to the field. Sustainability is a question about dynamics. Here, the system would be sustainable if the field produces more grass in a day than the cow (and her herd-mates if any) consumes consumes in a day. We’ll model a cow’s consumption as a sigmoidal function consumption(v) of the amount of grass (v – for “vegetation”) available. Like this: Figure 50.5: The amount of vegetation consumed by a cow in a day depends on the amount of vegetation available. At very low levels of vegetation (\\(v &lt; 1/2\\) ton), it’s hard to find more to eat, so a slight increase in vegetation doesn’t increase consumption by much. The overall system is roughly analogous to the rabbit/fox model where we had rabbits as the food and foxes as the consumers. In the rabbit/fox system, we had one differential equation for the growth in the rabbit population density and another for the foxes. The rabbit dynamics consisted of two parts, the natural growth rate in the absence of foxes and the rate at which rabbits are taken by the foxes: \\(\\partial_t r = 0.66\\, r - 1.33\\, r f\\). We’ll model the dynamics of grass in much the same way. In the absence of cows the grass grows in an environment with a limited carrying capacity. (Carrying capacity reflects limits to the amount of water and the amount of sunlight and space.) Taking the carrying capacity of the field as 25 tons of biomass, we’ll set the model for \\(v(t)\\) to be \\[ \\partial_t v = \\frac{v}{3} \\left(1-\\frac{v}{25}\\right)\\ .\\] We now have two models for two different components of the ecosystem: the growth of vegetation and the daily consumption by a cow. It’s time to put those components together into the overall model. But do we have everything we need? There are potentially two state variables, the amount of vegetation and the number of cows. To be analogous to that situation, we would need a model for the number of cows in the field. However, the context for the model suggests some changes here. First, the number of cows \\(n\\) in the field is not set by the cow’s natural reproduction, it’s set by the farmer’s decision. As well, at 9 months, a cow’s gestation period is long relative to the potential changes in the amount of vegetation. (In contrast, rabbits have a gestation period of 1 month and foxes 2 months.) The cow’s consumption is one part of the dynamics. If there were no grass growing, the dynamics would be \\[\\partial_t G(v) = - H \\times \\text{consumption}(v)\\] where \\(H\\) is the number of cows in the herd. Subtracting daily consumption from daily growth of grass gives the rate of change of the biomass of grass. Figure 50.6: The graph can be made to display any of three functions: The intrinsic logistic model growth dynamics with no cows.\\2. The total consumption by the herd of cows.\\3. The net growth, which is the difference between (1) and (2). Examples of linearization: Newton’s Law of Cooling, Hooke’s Law "],["flow-on-plane.html", "Chapter 51 Flows on the plane 51.1 Generic behaviors 51.2 Linearization 51.3 Exercises", " Chapter 51 Flows on the plane Let’s return the rabbit/fox system as an example of flow. Since there are two state quantities, \\(r\\) and \\(f\\), the state space \\((r, f)\\) is a plane. At each point in the state space, the flow vector gives the direction and speed of motion. Like all vectors, a flow vector has only two properties: the direction and length. The speed of motion is the length of the flow vector. The flow itself is a vector field. This is an assignment of a vector to each point of the state space. Graphically, we depict a flow field by selecting a grid of points in the state space, finding the flow vector for each grid point, and drawing those vectors positioned at their respective grid points. Figure 51.1: The flow field has a vector at each point in state space but we can draw only a few if the plot is to be legible. Zooming in on a region produces more detail. Recall from Block 5 that it’s conventional to specify a vector by giving a coordinate pair for the tip of the vector with the understanding that the tail is at the origin. For the rabbit/fox system, the tip’s coordinate is \\(\\left({\\Large\\strut} g_r(r, f),\\ g_f(r, f)\\right)\\). This notation is potentially confusing, because the letters \\(r\\) and \\(f\\) appear in so many places. Each each vector in Figure ?? is drawn at a particular point, say \\((r=0.96, f=0.48)\\). At that point, evaluate the dynamical functions: \\(g_r(r=0.96, f=0.48) = 0.0207\\) and \\(g_r(r=0.96, f=0.48)= 0.941\\). A fixed point of the dynamics is a point in the state space where the dynamical functions both evaluate to zero. It’s convenient to mark fixed points as the intersection of zero contours of the dynamical functions. Figure 51.2 shows these zero contours (red for rabbits, blue for foxes) laid on top of the flow field. Such zero contours of dynamical functions are called nullclines. (The word means “zero slope”. “Null” corresponds to zero and “cline” is the root of words like “incline” or “decline.”) Figure 51.2: Flow field and nullclines for the rabbit/fox dynamics. Due to the nature of fixed points, if the initial condition is at the intersection of the nullclines the state will not change. But is the fixed point stable or unstable. As you will see, in two and higher dimensional dynamical systems, there is more than one kind of stability and more than one kind of instability. These different kinds of stability and instability have a direct correspondence to different kinds of behavior in real-world systems. Very near the fixed point, dynamics are approximately linear. We’ll return to a quantitative analysis of this in Chapter 53. Our objective here is to show that there are several generic types of behavior and that the stability of dynamics near the fixed point has to be one of a handful of different types. 51.1 Generic behaviors On a nullcline of a dynamical variable \\(x\\), the \\(x\\)-component of the flow must be zero. The flow will point to positive \\(x\\) on one side of the nullcline and negative \\(x\\) on the other. This is really nothing more than saying that on one side of a zero contour the function value is positive and on the other side negative. We’ll indicate this on the following diagrams by shading the positive side of the nullcline with the same color as the nullcline itself. Figure 51.3 shows the nullclines of a linear system on separate plots. Notice that flow in the shaded side of the \\(x\\) (red) nullcline the flow always has a positive component to the right. Similarly, in the shaded side of the \\(y\\) (blue) nullcline, the flow always has a positive component to the right. Figure 51.3: The nullclines of a linear dynamical system near the fixed point. \\(x\\) nullcline is red, \\(y\\) nullcline is blue Placing both nullclines on the same plot divides the region near the fixed point into four parts. This is generic behavior. Unless the two nullclines are exactly the same as each other, the two nullclines split the region into four quadrants. Figure 51.4: Four quadrants of linear dynamics near the fixed point. We can identify the quadrants by their color—white, red, blue, purple. In each quadrant, the “compass direction” of all flow vectors point to one quadrant of the compass: white to the south-west, red to the south-east, blue to the north-west, and purple to the north-east. This particular linear flow is unstable. Notice that any initial condition in the purple quadrant will lead to a NE trajectory, away from the fixed point. Similarly, any initial condition in the white quadrant leads to a SW trajectory, again away from the fixed point. For an initial condition in the red or blue quadrants, the flow will take the trajectory into either the white or purple quandrants. The initial part of the trajectory may be towards the fixed point, but as soon as the trajectory crosses into white or purple territory, the trajectory leads away from the fixed point. So, the overall flow is unstable. This particular type of instability, where the initial path might be toward the fixed point but eventually leads away from it, is called a saddle. The flow is analogous to the movement of a marble placed on a horse saddle; it might start to roll toward the center of the saddle, but eventually it will roll off to the side. All linear flows will lead to this quadrant structure. Another feature of the structure is that the white quadrant must always be opposite to the purple, and the red opposite to the blue. This allows us to enumerate the different possible types of stability. A very compact summary of the dynamics shows just the four compass directions and the relative positions of the quadrants. For instance, \\[\\begin{array}{c|c} \\color{red}{\\searrow} &amp; \\color{purple}{\\nearrow}\\\\\\hline \\color{gray}{\\swarrow} &amp; \\color{blue}{\\nwarrow} \\end{array}\\ ,\\] corresponds to the saddle flow seen in the previous flow field. There are, altogether, eight possible configurations: $ \\[\\begin{array}{cccc} \\text{saddle} &amp; \\text{saddle} &amp; \\text{saddle} &amp; \\text{saddle} \\\\ \\begin{array}{c|c} \\color{red}{\\searrow} &amp; \\color{purple}{\\nearrow}\\\\\\hline \\color{gray}{\\swarrow} &amp; \\color{blue}{\\nwarrow} \\end{array} &amp; \\begin{array}{c|c} \\color{gray}{\\swarrow} &amp; \\color{red}{\\searrow} \\\\\\hline \\color{blue}{\\nwarrow} &amp; \\color{purple}{\\nearrow} \\end{array} &amp; \\begin{array}{c|c} \\color{blue}{\\nwarrow} &amp; \\color{gray}{\\swarrow} \\\\\\hline \\color{purple}{\\nearrow} &amp; \\color{red}{\\searrow} \\end{array} &amp; \\begin{array}{c|c} \\color{purple}{\\nearrow}&amp; \\color{blue}{\\nwarrow}\\\\\\hline \\color{red}{\\searrow} &amp; \\color{gray}{\\swarrow} \\end{array} \\\\ \\ \\\\ \\begin{array}{c|c} \\color{red}{\\searrow} &amp; \\color{gray}{\\swarrow}\\\\\\hline \\color{purple}{\\nearrow} &amp; \\color{blue}{\\nwarrow} \\end{array} &amp; \\begin{array}{c|c} \\color{purple}{\\nearrow}&amp; \\color{red}{\\searrow} \\\\\\hline \\color{blue}{\\nwarrow}&amp; \\color{gray}{\\swarrow} \\end{array} &amp; \\begin{array}{c|c} \\color{blue}{\\nwarrow}&amp; \\color{purple}{\\nearrow} \\\\\\hline \\color{gray}{\\swarrow}&amp; \\color{red}{\\searrow} \\end{array}&amp; \\begin{array}{c|c} \\color{gray}{\\swarrow}&amp; \\color{blue}{\\nwarrow} \\\\\\hline \\color{red}{\\searrow}&amp; \\color{purple}{\\nearrow} \\end{array}\\\\ \\text{center} &amp; \\text{orbit} &amp; \\text{source} &amp; \\text{orbit} \\end{array}\\] $ Saddles are unstable, although the trajectory might approach the fixed point at first. A source is unstable; any trajectory heads away from the fixed point. A center is stable; any trajectory heads toward the fixed point. As for the orbits, one in a clockwise direction and the other counter-clockwise, we can’t yet say from this simple theory whether they are stable or unstable. The orbit we have already met, the rabbit-fox dynamics, has counter-clockwise trajectories that form closed loops. This is called neutral stability. Figure 51.5: The rabbit/fox system has orbits that are neutrally stable. 51.2 Linearization For dynamical systems with two state variables, constructing a linear approximation to dynamics near a fixed point follows a similar procedure to that with one-state-variable systems. Locate the fixed point. Construct the first-order polynomial approximation to each of the dynamical functions at the fixed point. For instance, the pendulum system has state variables \\(\\theta\\) and \\(v\\) with dynamics \\[\\partial_t \\theta = g_\\theta(\\theta, v) = v\\\\ \\partial_t v = g_{v}(\\theta, v) = - \\sin(\\theta) \\] There is a fixed point at \\(\\theta = 0\\), \\(v=0\\): this is just the situation of a pendulum hanging down that has no motion. The dynamical function \\(g_\\theta(\\theta, v) = v\\) is already in first-order polynomial form. The other dynamical function, \\(g_v(\\theta, v) = - \\sin(\\theta)\\) is nonlinear. The first order polynomial approximation centered on the fixed point will be \\[g_v(\\theta, v) \\approx \\underbrace{\\color{magenta}{g_{v}(0, 0)}}_0 + \\underbrace{\\color{magenta}{\\partial_\\theta g_v(0, 0)}}_{-\\cos(0)}\\ \\theta + \\underbrace{\\color{magenta}{\\partial_v g_v(0, 0)}}_0\\, v\\] The term \\(g_v(0, 0) = 0\\) because we are evaluating \\(g_v()\\) at a fixed point. The term \\(\\partial_v g_v(0, 0) = 0\\) because \\(g_v()\\) does not depend on \\(v\\). We’ll use \\(u\\) and \\(w\\) as the dynamical variables in the linear approximation in order to avoid confusion with the original, nonlinear equations. The linearized dynamics are therefore: \\[\\partial_t u = \\ \\ w\\\\ \\partial_t w = - u\\] ## Warning in contour_plot(-sin(theta) ~ theta &amp; v, contours_at = 0, contour_color ## = &quot;blue&quot;, : No dependence of function on y variable. Contour labels may be ## misplaced. ## Warning in validate_domain(domain, free_args): Using -5 to 5 in domain for ## missing domain names. ## Warning in validate_domain(domain, free_args): Missing domain names: theta, v ## Warning in contour_plot(., v ~ theta &amp; v, contours_at = 0, contour_color ## = &quot;red&quot;, : No dependence of function on y variable. Contour labels may be ## misplaced. ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. ## Scale for &#39;fill&#39; is already present. Adding another scale for &#39;fill&#39;, which ## will replace the existing scale. ## Warning: Removed 76 rows containing missing values (geom_segment). Figure 51.6: Flow field, nullclines, and trajectories of the pendulum (black) and the linearized pendulum (magenta) from three different initial conditions. Given a choice between a numerical and a symbolic solution to exactly the same problem, the symbolic solution is generally better: it’s exact and it can incorporate parameters symbolically. “Far better an approximate answer to the right question, which is often vague, than an exact answer to the wrong question, which can always be made precise.” – John Tukey (1915-2000) 51.3 Exercises Exercise XX.XX: s5x504 Figure 51.6 shows a flow field of the pendulum system and three pairs of trajectories, one pair for each of three initial conditions. Each trajectory starts at \\(t=0\\) and ends at \\(t=6\\). A. Read the three different initial conditions from the graph. B. The dark gray trajectories are for the original (nonlinear) pendulum system while the \\(\\color{magenta}{\\text{magenta}}\\) trajectories are for the linearized dynamics. Describe in words the differences in the trajectories for the nonlinear and the linearized dynamics. C. The Which does the flow field correspond to: the nonlinear or linearized dynamics. Exercise XX.XX: ePqij6 Describe the stability of each of the following flows. "],["modeling-dynamics.html", "Chapter 52 Modeling dynamics 52.1 Exercises", " Chapter 52 Modeling dynamics Models leading to flow fields Objectives/topics Apply modeling techniques (from block 2) local low order polynomials Predatory/Prey (flow fields and the phenomena of the trajectories) SIR (flow fields and the phenomena of the trajectories) The differences between these two models Additional models and flow fields (catch up day) Objectives/topics (Richardson’s arms race model and conflict model, action potentials) Numerics, look at the trajectories Exercise: insert_calcZ_exercise(\"XX.XX\", \"iRZfBY\", \"Exercises/walnut-tell-pot.Rmd\") Analysis of phase plane with nullclines There are a few differential-equation forms that show up again and again in modeling problems. We’re going to introduce them to you here and, later, show you the solutions. The proportional growth/decay model: \\(\\dot{x} = a x\\) Simple population growth. The population is a function of time: \\(x(t)\\). Growth at any instant is proportional to the instantaneous population. For instance a population growing at 3% per year will have \\(a \\approx 0.03\\) with units 1/year. Radioactive decay. The amount of the radioactive substance is a function of time: \\(x(t)\\). For example, phosphorus-32 (that is, \\(^{32}\\)P) has a half life of 14 days. The differential equation is \\(\\dot{x} = -a x\\) with \\(a \\approx 0.049\\) with units 1/day. Change proportional to difference: \\(\\dot{x} = - a (x - x_\\text{fixed})\\) Newton’s Law of Cooling is about how a hot (or cold) object comes into equilibrium with the ambient temperature. For instance, you might have a cup of coffee at \\(200^\\circ\\)F in a room at \\(70^\\circ\\)F. Unless you drink it, the coffee will cool with time until it reaches the room’s temperature. In this setting, \\(x_\\text{fixed} = 70^\\circ\\)F. The value of \\(a\\) depends on how insulated the cup is (and details of evaporation, etc.). But if the coffee reaches very near to room temperature in 60 minutes, \\(a \\approx 0.5\\) with units 1/minute. Question A What are the units of the output of \\(x(t)\\)?     degrees F per minute︎✘        degrees F\\(\\heartsuit\\ \\)       1/minute︎✘        1/degrees F︎✘ Question B What are the units of \\(\\dot{x}\\)?     degrees F per minute\\(\\heartsuit\\ \\)       degrees F︎✘        1/minute︎✘        1/degrees F︎✘ Question C What is \\(x\\)? the room temperature︎✘ the initial temperature of the coffee︎✘ the instantaneous coffee temperature as a function of timeNice!  the fixed rate at which the coffee cools︎✘ the instantaneous rate at which the coffee cools as a function of time︎✘ Question D What is \\(\\dot{x}\\)? the room temperature︎✘ the initial temperature of the coffee︎✘ the instantaneous coffee temperature as a function of time︎✘ the instantaneous rate at which the coffee cools as a function of timeRight!  Limited growth, e.g. \\(\\dot{x} = r x (1-x/k)\\) The proportional-growth model will lead to \\(x(t)\\) increasing without limit. Sometimes that’s a good model over short times, before \\(x(t)\\) has a chance to get unrealistically big. But over long periods of time, something’s gotta give. Population with a “carrying capacity.” For \\(t\\) when \\(x(t)\\) is very small, the population growth is well approximated by the usual proportion-growth model. For intermediate \\(t\\), the population has grown to a large enough size that it is consuming a substantial fraction of the available resources and population growth slows. When the population reaches the “carrying capacity” the growth stops (e.g. birth rate = death rate). Question E If the units of \\(x(t)\\) is, say, rabbits, what is the units of \\(k\\)?     rabbits\\(\\heartsuit\\ \\)       rabbits per day︎✘        rabbits per week︎✘        rabbits per year︎✘ Question F Suppose the units of \\(\\dot{x}\\) is, rabbits per month, what is the units of \\(r\\)?     1/month\\(\\heartsuit\\ \\)       rabbits per month︎✘        months per rabbit︎✘        rabbits per month-squared︎✘ Question G Even without finding the full solution \\(x(t)\\) to the differential equation, you can figure out how big the population will be when growth falls to zero. How big?     \\(k\\)\\(\\heartsuit\\ \\)       \\(k/r\\)︎✘        \\(r/k\\)︎✘        \\(1/r\\)︎✘ 52.1 Exercises Exercise XX.XX: 5DVPWG This activity makes use of the following app: Click on the picture of the app and it will open in a new browser tab. Arrange that new tab side-by-side with the one where you are reading this. To solve a differential equation with the Euler method, you need two things: The differential equation itself. Several choices are available in the selector on the left side of the app. On the right side of the equation is the dynamics(x) function. An initial condition \\(x(0)\\). You can select this with the slider. You will also need A stepsize \\(h\\). So long as this is “small enough,” the specifics don’t really matter. How Euler works The first row of the table shows the situation at \\(t=0\\). At that time, the value of \\(x\\), that is \\(x(t=0)\\) is the initial condition that you set with the slider. In the following, whenever we write \\(x(t)\\) we mean \\(x\\) at the time in the last row of the table. Knowing the value of \\(x(t)\\) the instantaneous value of \\(\\partial_t x\\) can be found by plugging \\(x(t)\\) into the dynamics() function. Now that we know \\(\\partial_t x\\), we know how fast \\(x\\) is changing. Multiply this rate of change by \\(h\\) to get the total change of \\(x\\) for the next step. Add a new row to the table at \\(t+h\\) with the \\(x\\)-value from the previous row added to the total change of \\(x\\) from that previous row. Loop back to (a) each time the “step” button is pressed. Select \\(\\partial_t x = -0.5 x\\) as the differential equation to solve. Press “step” several times. After each step, try to understand from the table and graphs why the new row added to the table is what it is. Question A For \\(\\partial_t x = -0.5 x\\), which of these best describes the shape of the solution? (You’ll get a better picture if you set x(0) to, say, 8.) linear decay to zero︎✘ linear growth from zero︎✘ exponential decay to zeroExcellent!  exponential growth from zero︎✘ exponential decay to \\(x = 5\\)︎✘ exponential growth from \\(x = 5\\)︎✘ Question B For the differential equation \\(\\partial_t x = +0.5 x\\), which of these best describes the shape of the solution? (You’ll get a better picture if you set x(0) to, say, 1.) linear decay to zero︎✘ linear growth from zero︎✘ exponential decay to zero︎✘ exponential growth from zeroExcellent!  exponential decay to \\(x = 5\\)︎✘ exponential growth from \\(x = 5\\)︎✘ Question C For the differential equation \\(\\partial_t x = -0.4\\,(x - 5)\\), which of these best describes the shape of the solution when the initial condition is \\(x=1\\)? linear decay to zero︎✘ linear growth from zero︎✘ exponential decay to zero︎✘ exponential growth from zero︎✘ exponential decay to \\(x = 5\\)Correct.  exponential growth from \\(x = 5\\)︎✘ Question D For the differential equation \\(\\partial_t x = -0.4\\,(x - 5)\\), which of these best describes the shape of the solution when the initial condition is \\(x=9\\)? linear decay to zero︎✘ linear growth from zero︎✘ exponential decay to zero︎✘ exponential growth from zero︎✘ exponential decay to \\(x = 5\\)Right!  exponential growth from \\(x = 5\\)︎✘ Question E For the differential equation \\(\\partial_t x = 2\\,x\\,(1-x/8)\\), which of these best describes the shape of the solution when the initial condition is \\(x=1\\)? linear decay to \\(x=8\\)︎✘ exponential decay to \\(x=8\\)︎✘ exponential growth from zero followed by exponential decay to \\(x=8\\)Nice!  exponential decay to zero followed by exponential growth to \\(x=8\\)︎✘ Exercise XX.XX: L6hTUu Consider a hay field that has just been harvested in the middle of summer. The grass has been cut short and the weather is still conducive to growth. What’s going to happen? The grass will grow back, a very simple model of which will be \\(\\partial_t G(t) \\equiv C\\). This rate, \\(\\partial_t G(t)\\), corresponds to the grass growing back at a constant rate. Imagine we measure this rate as tons of biomass per day, and measure time \\(t\\) in days. Question A To model the everyday real world of growing grass, should \\(C\\) be positive or negative? positiveGood.  negative︎✘ The amount of grass would be decreasing. This is not what we ordinarily think of as “growing” zero︎✘ \\(\\partial_t G(t) = 0\\) implies no change at all. Question B What units does the output \\(G(t)\\) have? tons per day︎✘ These are the units of \\(C\\) and therefore, because of the equality, of \\(\\partial_t G(t)\\). We’re asking about the units of \\(G(t)\\), not \\(\\partial_t G(t)\\). tonsExcellent!  days︎✘ This is the unit of the input \\(t\\), not the output \\(G(t)\\). tons/day^2︎✘ Question C Which of these equations best describes the trajectory of the growing grass under the \\(\\partial_t G(t) = C\\) dynamics?     \\(G(t) = G(0) + C\\)︎✘        \\(G(t) = G(0) + C t\\)\\(\\heartsuit\\ \\)       \\(G(t) = G(0)\\sin(t/C)\\)︎✘        \\(G(t) = G(0) t + C\\)︎✘ Question D According to the dynamics \\(\\partial_t G(t) = C\\), what will \\(G(t)\\) look like (without future harvesting)? Growth until the field is choked up with grass.︎✘ Growth without limit.Right!  Oscillating growth and decline as the seasons pass.︎✘ This might be the case in the real world, but the simple model does not incorporate seasonality. There are two obvious shortcomings of the model \\(\\partial_t G(t) = C\\). First, when the amount of grass is very small (think little spouts spread widely apart) growth should me smaller than when the grass is plentiful. Second, at some point the grass is so dense that further growth is impossible, so \\(\\partial_t G(t)\\) falls to zero (or even negative). The maximum amount of biomass that can be sustained by the field is called the grass’s carrying capacity. The standard simple model for a system with growth to a carrying capacity is \\[\\partial_t G(t) = r G(t)(K-G(t))\\] This model is famous and has a name: logistic growth. Question E The logistic growth model has two fixed points. What are they? \\(G=0\\) and \\(G=K\\)Right!  \\(G=0\\) and \\(G=1/K\\)︎✘ Plug \\(1/K\\) into the dynamics in place of \\(G\\). Do you get \\(\\partial_t G = 0\\)? \\(G = \\pm K\\)︎✘ Plug \\(-K\\) into the dynamics in place of \\(G\\). Do you get \\(\\partial_t G=0\\)? \\(G=0\\) and \\(G=-K\\)︎✘ Plug \\(-K\\) into the dynamics in place of \\(G\\). Do you get \\(\\partial_t G=0\\)? Question F Which of these stories best describes the trajectory of the logistics growth version of \\(G(t)\\) starting with \\(G(0)\\) very small but positive? The grass grows slowly at first, then gradually growth speeds up and stays high.︎✘ The grass grows rapidly at first then declines gradually to no growth.︎✘ The grass grows slowly, then grows faster until it reaches a biomass where the growth rate declines steadily to zero.Good.  Here are three graphs. Question G Which of the graphs represents a possible trajectory \\(G(t)\\)? A︎✘ BExcellent!  C︎✘ This is a graph of dynamics, not the trajectory. Look at the x-axis label. none of them︎✘ Exercise XX.XX: VCWRBs You and your older cousin are on a road trip. She rented a car that has not only “cruise control” (a technology from the 1970s that holds a constant speed without driver intervention) but also “car following,” that keeps the car a set distance \\(D\\) behind the car in front. Your cousin, knowing that you are a CalcZ student, asks you how the “car following” system works. First, define some terms. You tell your cousin to denote the current, instantaneous distance from the car ahead as \\(\\xi\\). You point out that when \\(\\xi - D &gt; 0\\), you’re a greater distance than \\(D\\) from the car ahead and therefore the velocity should be increased so you catch up. On the other hand, when you’re too close (\\(\\xi &lt; D\\)) you should decrease your velocity. The car-following system automates this, the relationship being \\(\\partial_t \\xi = b (\\xi - D)\\). Your cousin has never encountered a name like \\(\\xi\\) so you decide to simplify. “Let \\(x = \\xi - D\\), so \\(x\\) is positive if you are too far behind, zero when you’re at the right distance, and negative if you are too far ahead.” Conveniently \\(\\partial_t x = \\partial_t \\xi\\), so you can write down the automatic relationship in terms of \\(x\\): \\(\\partial_t x = b x\\) with \\(b\\) a positive number, such as 1. Question A Where is the fixed point of the dynamics \\(\\partial_t\\, x = b x\\)? \\(x=D\\)︎✘ No, it should be \\(\\xi=D\\), which means that \\(x=0\\). \\(x=0\\)Excellent!  \\(\\xi = 0\\)︎✘ This corresponds to zero distance between you and the car in front of you. Not what we want! There’s no fixed point.︎✘ Question B Is the fixed point of \\(\\partial_t\\, x = b x\\) (with \\(b &gt; 0\\)) stable? Yes, that’s why we can leave it to the automatic system.︎✘ True, we would want the automatic system to show stable fixed point behavior, but that’s not what’s happening here. No, the solution grows exponentially as \\(e^{bt}\\).Correct.  Yes, the solution decays exponentially as \\(e^{bt}\\)︎✘ But since \\(b &gt; 0\\), this wouldn’t be exponential decay but growth. Something’s wrong with the system you’ve sketched out. You want a stable following distance, doing the right thing if the car ahead speeds up or slows down, but your system is unstable. Question C Which of the following rules will have a stable fixed point at \\(x=0\\)? \\(\\partial_t\\, x = -b x\\) (with \\(b &gt; 0\\))Correct.  \\(\\partial_t\\, x = b^2 x\\)︎✘ The coefficient on \\(x\\) is still positive, so this system is unstable. \\(\\partial_t\\, x = b x^2\\)︎✘ This system is stable for disturbances that make \\(x &lt; 0\\), but unstable for disturbances that make \\(x &gt; 0\\). \\(\\partial_t\\, x = 0 x\\)︎✘ In this system, \\(x\\) doesn’t change. The word “feedback” is used to describe systems where the change in the state is a function of the state. “Negative feedback” is when the change is negative when the state is positive, as in \\(\\partial_t\\, x = -b\\, x\\). Negative feedback is desirable when you want to keep things stable. “Positive feedback” is when the change is the same sign as the state, as in \\(\\partial_t\\, x = b\\, x\\) and makes things unstable. – "],["equilibria.html", "Chapter 53 Equilibrium and transient 53.1 One state variable 53.2 Two state variables", " Chapter 53 Equilibrium and transient Fixed points of nonlinear systems in the phase plane Objectives/topics Determine fixed points and linearize the system around the fixed points Flow field of the linear approximation Matrix representation of the flow field Iteration of matrices Many of the natural and constructed objects and systems that we encounter—buildings, bridges, airplanes, the orbits of satellites, heating systems, birds in flight, and so on—are more fully understood if seen as dynamical systems. That may seem strange; a building doesn’t move (we hope!), an airplane stays in steady flight, the seasons have been steady in their progression for as long as records have been kept. And yet … a building might be shaken and even destroyed by an earthquake, airplanes require pilots and control systems for steady flight. Even satellites in far Earth orbit can drift from their desired positions and attitudes and require control corrections. A system is said to be in steady state when it stays put, unchanging. Another term often used to express such constancy is equilibrium which occurs when the various forces or processes acting on the system balance out. In the language of dynamical systems, the equilibrium state of a system is called a fixed point. Mathematically, this is a coordinate in the state space where all the right-hand sides of the differential equations equal zero. For a two-dimensional system with dynamics \\[\\partial_t x = f(x, y)\\\\\\partial_t y = g(x,y)\\], a fixed point will be a particular value for the state which we’ll write as \\((x^\\star, y^\\star)\\) where both \\(f(x^\\star, y^\\star) = 0\\) and \\(g(x^\\star, y^\\star) = 0\\). An important vocabulary word in dynamics is transient. In everyday speech, this means something like “just passing through.” It’s the same in dynamics: that part of the trajectory which precedes stable, fixed behavior such as at a fixed point. Transients occur whenever a dynamical system has an initial state not on a stable, fixed state. They are also common in systems that are disrupted by some external force, for example in the recovery of an electrical power distribution grid after a disturbance such as an ice storm. After a sharp bang, the ringing in your ears is a transient. When you stand up too suddenly, the “stars” you see are a transient due to diminished blood flow. Turn on an oven? The transient is the warming up until the oven reaches the temperature setting. Although transients are … well, transient, they can be very important. Key to the Wright Brothers success was their recognition that air turbulence elicits transients in attitude and that aircraft need control systems that can work fast enough for the craft to survive the transient. If you have driven a car with a broken suspension, you’ll know that it can be hard to control after the transient caused by hitting a bump in the road. Small disturbances often elicit transients that decay away exponentially. Such transients, like all exponentially decaying processes, can be characterized by a half life: the time it takes the transient to shrink to half its original value. (Not all transients decay exponentially, but that’s a story for another course.) In this chapter, we’ll study the quantitative response to dynamical systems with a fixed point when the state is perturbed by some outside force. Our focus will be on linear or linearized dynamical functions, which are generally an excellent description of dynamics near a fixed point. 53.1 One state variable Linear systems with one state variable have simple dynamics: \\[\\partial_t y = k y\\] which has a fixed point at \\(y^\\star = 0\\). Even dynamics like \\(\\partial_t x = k x + b\\) can be easily transformed into this simple form; the fixed point is \\(x^\\star = - b/a\\) and defining \\(y \\equiv x - x^\\star\\) gives the \\(\\partial_t y = k y\\) form. The solution is also simple: \\(y(t) = y_0\\ e^{kt}\\), where \\(y_0\\) is the initial condition on \\(y\\). If the parameter \\(k &lt; 0\\), the dynamics are exponential decay to the fixed point. If \\(0 &lt; k\\), the dynamics are exponential growth away from the fixed point. 53.2 Two state variables If the state variables \\(x\\) and \\(y\\) are measured with respect to a fixed point, the differential equation of the linear or linearized system is: \\[\\partial_t x = a x + b y\\\\ \\partial_t y = c x + d y\\] Exponentials are an important form of ansatz for linear differential equations. To show why, let’s review the solution to \\(\\partial_t x = k x\\), but assume that all we know is that the solution is an exponential function of time: \\(x(t) = A e^{\\lambda t}\\) and that we don’t yet know the parameters \\(A\\) or \\(\\lambda\\). As usual for an ansatz, we plug it into both sides of the differential equation, giving \\[\\partial_t A e^{\\lambda t} = k A e^{\\lambda t}\\ \\ \\implies \\lambda A e^{\\lambda t} = k A e^{\\lambda t}\\ \\ \\implies \\lambda = k\\ .\\] Now we know the value of \\(\\lambda\\). What about \\(A\\)? Evaluate the solution at \\(t=0\\). This gives \\(x(0) = A e^{\\lambda 0} = A\\). So we know \\(A\\) is the initial condition \\(x(0)\\) (which we usually abbreviate \\(x_0\\)). We’ll try the same approach with the two-state variable system, but we’ll start with a special case where some of the parameters \\(a, b, c\\), and \\(d\\) are zero. \\[\\require{cancel}\\text{Simplification:}\\ \\ \\ \\ \\ \\begin{array}{cccc}\\partial_t x = &amp;\\cancel{ax} &amp; + &amp; b y\\\\\\partial_t y = &amp;c x&amp; + &amp; \\cancel{dy}\\end{array}\\ .\\] We’re going to modify the equations a little, specifically, we’ll take the derivative with respect to time of both sides of the top equation, giving: \\[\\begin{array}{cccc}\\partial_{tt} x = &amp; &amp; &amp; b\\ \\partial_{t\\ } y\\\\\\partial_{t\\ } y = &amp;c x&amp; &amp; \\end{array}\\ .\\] Substitute in the value for \\(\\partial_t y\\) from the bottom equation to get a single, second-order differential equation: \\[ \\partial_{tt} x = b\\, c\\, x\\ .\\] Plug in the usual ansatz, \\(x(t) = A e^{\\lambda t}\\) to get \\[\\lambda^2 A e^{\\lambda t} = b\\,c\\, A e^{\\lambda t}\\ \\ \\ \\implies\\ \\ \\ \\ \\lambda = \\pm \\sqrt{\\strut b\\,c}\\] The \\(\\pm\\) is the interesting part here. If, say, \\(b=1\\) and \\(c=1\\), there are two values for \\(\\lambda\\) that will be consistent with the differential equation: \\(\\lambda_1 = 1\\) and \\(\\lambda_2 = -1\\). Either of these will produce a solution that satisfies the differential equation: \\(x_1(t) = A e^{\\lambda_1 t}\\) or \\(x_2(t) = B e^{\\lambda_2 t}\\). So which of the two possibilities is it? Since everything about the differential equation is linear, any linear combination of the two possibilities will also satisfy the equation. So we can conclude that \\[x(t) = A e^{\\lambda_1 t} + B e^{\\lambda_2 t}\\ .\\] What are \\(A\\) and \\(B\\)? That depends on the initial condition. Evaluate both sides of the equation at \\(t=0\\) to get \\[x(0) = A e^{\\lambda_1 0}+ B e^{\\lambda_2 t} = A + B\\ .\\] At this point, you need to look back at the original system of equations. There are two state variables \\(x\\) and \\(y\\) and therefore we need to specify two components of the initial condition. If \\(x(0)\\) is interpreted as the initial position, then following the example of the pendulum we can look to the velocity \\(\\partial_t x\\) as the second component of the initial condition. From \\(x(t)\\) we can easily calculate the velocity: \\[\\partial_t x(t) = \\lambda_1 A e^{\\lambda_1 t} + \\lambda_2 B e^{\\lambda_2 t}\\ .\\] Again, evaluate this at \\(t=0\\) to get a second equation for the initial condition the pair being $$ \\[\\begin{array}{rcrcr}x(0) &amp; =&amp; A &amp; + &amp; B\\\\\\partial_t x(0) &amp; = &amp; \\lambda_1 A &amp; + &amp; \\lambda_2 B\\end{array}\\]          = .$$ From Block 5, we know how to solve such matrix equations. So, given the initial values \\(x(0)\\) and \\(\\partial_t x(0)\\), we can find an exact, quantitative solution to the differential equation. Example 53.1 Let’s look at the flow field, some trajectories and their time series for the system \\[\\partial_t x = b y\\\\\\partial_t y = c x\\] for \\(b=1\\) and \\(c=2\\). Figure 53.1: Three trajectories from the system \\[\\begin{array}{ccc}\\partial_t x = y\\\\\\partial_t y = 2 x\\end{array}\\] Each of these trajectories starts out by heading toward the fixed point at (0,0). Then, each turns and heads away toward \\(\\pm \\infty\\) from the fixed point, Figure 53.2: The time series \\(x(t)\\) for the three different trajectories in Figure 53.1. Each of the time series is similar, first showing exponential decay toward 0 then exponential growth toward \\(\\pm \\infty\\). The initial conditions for the black and \\(\\color{magenta}{\\text{magenta}}\\) trajectories are very similar. You can imagine a trajectory starting between those initial conditions that would go down the middle of the “trumpet.” This trajectory would be exponential decay toward 0, but would be hard to see since \\(x=0, y=0\\) is an unstable fixed point (a saddle). The initial condition for the black trajectory is \\(x(0)=0.72\\) and \\(y(0)=\\partial_t x(0) = -1\\), while for the \\(\\color{magenta}{\\text{magenta}}\\) trajectory it is \\(x(0)=0.70\\) and \\(y(0)=\\partial x(0) = -1\\). Let’s find each trajectory as a separate linear combination \\(A e^{\\lambda_1 t} + B e^{\\lambda_2 t}\\). The equations to solve are \\[\\left[\\begin{array}{cc}1 &amp; 1\\\\\\lambda_1 &amp; \\lambda_2\\end{array}\\right] \\left[\\begin{array}{C}A\\\\ B\\end{array}\\right] = \\left[\\begin{array}{C}x(0)\\\\ \\partial_t x(0)\\end{array}\\right] .\\] By plugging in the parameters \\(a=0\\), \\(b=1\\), \\(c=2\\), \\(d=0\\) in the dynamical functions, we find that \\[\\lambda = \\pm \\sqrt{\\strut 2} \\approx \\pm 1.4142 \\ .\\] Therefore, we solve \\[\\left[\\begin{array}{cc}1 &amp; 1\\\\1.4142 &amp; -1.4142\\end{array}\\right] \\left[\\begin{array}{C}A\\\\ B\\end{array}\\right] = \\left[\\begin{array}{C}x(0)\\\\ \\partial_t x(0)\\end{array}\\right] .\\] M &lt;- cbind(rbind(1, 1.4142), rbind(1, -1.4142)) b_black = rbind(0.72, -1) b_magenta = rbind(0.70, -1) qr.solve(M, b_black) ## [,1] ## [1,] 0.006443219 ## [2,] 0.713556781 qr.solve(M, b_magenta) ## [,1] ## [1,] -0.003556781 ## [2,] 0.703556781 The two trajectories are therefore \\[x_\\text{black}(t) = 0.0064 e^{1.4142 t} + 0.7136 e^{-1.4142}\\\\ \\color{magenta}{x_\\text{magenta}(t)} = -0.00356 e^{1.4142 t} + 0.70356 e^{-1.4142 t}\\] For both trajectories, the initial amplitude of the decaying exponential is much larger than for the growing exponential. That’s why the time series decay toward zero initially. But as \\(t\\) grows, the exponential growth become much more important. For the black trajectory, the exponential growth has a positive coefficient, so the growth is toward \\(\\infty\\). But for the \\(\\color{magenta}{\\text{magenta}}\\) trajectory, the exponential growth as a negative coefficient, thus that trajectory grows toward \\(-\\infty\\). The method we used to solve the simplified problem also works for the original problem \\[\\begin{array}{cccc}\\partial_t x = &amp;ax &amp; + &amp; b y\\\\\\partial_t y = &amp;c x&amp; + &amp; dy\\end{array}\\ .\\] Step 1: Differentiate with respect to \\(t\\) both sides of the top equation, giving \\[\\begin{array}{cccc}\\partial_{tt} x = &amp;a\\, \\partial_t x &amp; + &amp; b\\, \\partial_t y\\\\\\partial_t y = &amp;c x&amp; + &amp; dy\\end{array}\\ .\\] Step 2: Use the second equation to substitute for \\(\\partial_t\\, y\\) in the top equation, giving \\[\\partial_{tt} x = a \\partial_t x + b\\left(\\strut c x + dy\\right) = a\\, \\partial_t x + b\\, c\\, x + b\\, d\\, y\\] Step 3: One more substitution. From the original top equation, we know \\[y = \\frac{\\partial_t x - a x}{b}\\ .\\] Plug this in for \\(y\\) in the result from Step 2, giving \\[\\partial_{tt} x = a\\, \\partial_t x + b\\, c\\, x + b\\, d\\, \\frac{\\partial_t x - a x}{b} = \\left(\\strut a + d\\right)\\ \\partial_t x + \\left(\\strut b c - a d\\right)\\] Step 4: Use the ansatz \\(x(t) = e^{\\lambda t}\\). This produces \\[\\lambda^2 e^{\\lambda t}= (a + d) \\lambda e^{\\lambda t}+ \\left(\\strut bc - ad\\right)e^{\\lambda t} \\ \\ \\ \\implies\\ \\ \\ \\lambda^2 = (a + d) \\lambda + \\left(\\strut bc - ad\\right)\\] which can be solved for \\(\\lambda\\): \\[\\lambda = \\left(a + d\\right) \\pm \\sqrt{\\left(a - d\\right)^2 + 4 b c}\\] Again, the \\(\\pm\\) is the interesting bit here. There are two simple solutions that satisfy the differential equation: \\(x_1(t) = e^{\\lambda_1 t}\\) and \\(x_2(t) = e^{\\lambda_2 t}\\). In addition, any linear combination \\(A e^{\\lambda_ t} + B e^{\\lambda_2 t}\\) of these simple solutions will satisfy the differential equations. Once we know \\(\\lambda_1\\) and \\(\\lambda_2\\), the situation is identical to the simplified version. Again, knowing the initial condition \\(x(0)\\) and \\(\\partial_t x(0)\\) allows us to find the coefficients in the linear combination by solving the matrix equation \\[\\left[\\begin{array}{cc}1 &amp; 1\\\\\\lambda_1 &amp; \\lambda_2\\end{array}\\right] \\left[\\begin{array}{C}A\\\\ B\\end{array}\\right] = \\left[\\begin{array}{C}x(0)\\\\ \\partial_t x(0)\\end{array}\\right] .\\] "],["eigenvalues-eigenvectors.html", "Chapter 54 Eigenvalues, eigenvectors 54.1 Exercises", " Chapter 54 Eigenvalues, eigenvectors Eigenvalue/Eigenvector analysis Objectives/topics Understand the geometry of the flow (what an eigenvector looks like in terms of the flow, as it emerges from the image of the flow field) Trajectories as linear combinations of eigenflows Show that starting on an eigenvector stays on an eigenvector. The time series will be either a growing exponential or a decaying exponential, depending on the sign of \\(\\lambda\\). Graphic showing the dynamics for a circle of initial conditions from last year???? 54.1 Exercises EXERCISES: Give numbers for \\(abcd\\) and \\(x(0)\\) and \\(\\partial_t x(0)\\). Find the eigenvalues and \\(A\\) and \\(B\\). "],["second-order-de.html", "Chapter 55 Force-balance equations", " Chapter 55 Force-balance equations Calculus of second order differential equations Objectives/topics Force balance equations Equivalence to phase plane description Exponential Ansatz (solution is made up of exponentials, which one?) Complex eigenvalues "],["forcing-and-resonance.html", "Chapter 56 Forcing and resonance", " Chapter 56 Forcing and resonance Harmonic Oscillator Objectives/topics Complex exponentials and their equivalency to sinusoids Sinusoids with exponential amplitudes (damping) Relation to the real and complex parts of the eigenvalues Forcing and resonance "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
