# Notation & computing

<div style="float:right;">[![](www/icons/edit.png)](https://github.com/ProjectMOSAIC/MOSAIC-Calculus/blob/main/Preliminaries/02-notation.Rmd)</div>

```{r include=FALSE}
book_file_name <- "preliminaries/02-notation.html"
```

> *The ideas which are here expressed so laboriously are extremely simple .... The difficulty lies, not in the new ideas, but in escaping from the old ones, which [branch]^[Original word: "ramify"], for those brought up as most of us have been, into every corner of our minds.* --- J. M Keynes, 1936, [*The General Theory of Employment, Interest, and Money*](files.ethz.ch/isn/125515/1366_KeynesTheoryofEmployment.pdf), 1936

In addition to the specialized words we will use to express concepts and uses of calculus, we will also make extensive use of mathematical and computer-language notation. This chapter introduces you to the notation we'll be using. 

One goal of good notation is to make clear which of these object types it is referring to. Another goal is to build on what you already know about how mathematics is written. For historical reasons these two goals are sometimes in conflict. 

Yet another goal for notation has to with the central role of computing in the contemporary technical environment. Ideally, the mathematical notation we use should extend directly to computer-language notation. But in practice there is an incompatibility stemming from two sources:

1. Traditional mathematical notation makes extensive use of spatial arrangement, as for instance in $\frac{3}{4}$ or $x^{-3}$ or $\sqrt[4]{\strut y^2 - 6}$. For those familiar with it, this notation can be both concise and beautiful. But it was developed in an era of parchment and pen, without any inkling of keyboards and the strictly linear sequence of characters so widely used in written communication. Most mainstream computer languages are based on keyboard input.

2. Traditional mathematical notation was developed for communicating between *people* and, like everyday language, has gaps and ambiguities that get sorted out (not always correctly) by human common sense. Computer languages, on the other hand, need to be precise, unambiguous, and interpreted by machines.

We'll attempt to use mathematical notation in a way that limits the conflict between tradition and computer notation. This conflict is particularly acute when it comes to the idea of an "equation," so widely used in high-school mathematics but not a component of mainstream computer languages.

## Functions, inputs, and quantities

Our style of notation will be to give functions and their inputs *explicit names*. The basic principle is that a function name is a sequence of letters followed by an empty pair of parentheses, for instance $\sin()$ an $\ln()$.

Traditional mathematical notation writes many functions both without a name and without the parentheses. Examples that you have likely seen are $x^2$, $\sqrt{\strut x}$, and $e^x$. If we were to absolutely impose the name/parentheses principle we would refer to these functions as, say, square() and sqrt() and exp(). Notice that the $x$ is not part of the name.

Sometimes will will use names like square() just to emphasize the point that we are talking about a function. But for the most part we will stick to the traditional form because it is ubiquitous and recognizable by most readers. 

The name/parentheses notation, like exp() or sin() allows us to avoid having to write $x$ as the indicator of where the input to the function goes. That's helpful because, after all, the actual input might be something completely different from $x$.

Still, there are times in which we do need to state the name of the input to functions. One of these is when ***defining a function***. To define a function, we will use an expression like
$$g(y) \equiv y \cos(y)\ .$$
On the left of the $\equiv$ goes the name of the function, with the name of the input(s) in parentheses.  On the right of $\equiv$ goes a formula for computing the output from the input. This formula is written in terms of the input name given on the left side of the definition.

In situations where there is just one input to a function, as in $g()$ above, we could use any name for the input. For instance, all of these are exactly equivalent to the definition for $g()$ given above:

$$g(x) \equiv x \cos(x)\\
g(z) \equiv z \cos(z))\\
g(zebra) \equiv zebra\ \cos(zebra)$$

We'll tend to avoid hard-to-read input names like $zebra$. Instead, we'll mostly use :

- $\large x$ or $\large y$ or $\large z$. 
- $\large t$. This name is typically used when the input is meant to be ***time***. So if we were creating a function to represent the relationship between time (of day) and outdoor brightness, we might use this notation: $\text{brightness}(t)$

Other input names we will use often in this book include $u$, $v$, $w$, following the 17th-century convention introduced by Newton that input names come from the end of the alphabet. But we won't shy away from more descriptive names, like $T$ for "temperature" or $V$ for volume, or even $\text{altitude}$ (which describes itself). 

When a function has more than one input, the input names serve to indicate where each input goes in the formula defining the calculation.  For instance:
$h(x, y) \equiv x^2 e^y\ .$
$h()$ is a completely different function than, say,
$f(x, y) \equiv y^2 e^x$. 

You may have noticed that we've used the names $f()$, $g()$, and $h()$ a lot. Consider these names to be the equivalent of pronouns in English like "this", "that", "it", and so on. Function names like $f()$ or $F()$ will be used when we need to refer to a function for a moment: a sentence, a paragraph, a section. 

We will also have many occasions where we need to give a name to a quantity. Of course, a quantity is different from a function; functions are ***relationships*** between quantities.

For example, we will use names for quantities that are ***parameters*** in a function, like:
$$g(x) \equiv a x^2 + b x + c\. $$ Here, $x$ is the name given to the input to $g()$, while $a$, $b$, and $c$ are names for other quantities involved in the formula.

Again following Newton's convention, names for quantities will come from the beginning of the alphabet. We will often need more names than the alphabet can readily supply. $a$, $b$, $c$, and $d$ are unambiguous. But with $e$ we have a potential ambiguity with the exponential function. And, as we've seen, $f()$, $g()$, and $h()$ are being used as pronouns for functions.

So we will often use subscripts to expand the set of available names, as in 
$$h(x) \equiv a_0 + a_1 x + a_2 x^2 + a^3 x^3\ .$$ 
We will also use subscripts and non-numeric superscripts with input names to identify specific, isolated input quantities that are significant in some way. So you'll see $x_0$ or $y^\star$. For instance, such notation will be used for an input value where the function output is zero.

## Function output

We will often ***apply a function to *** specific input quantities in order to produce an output from the function. An equivalent phrase is ***evaluate a function on*** an input. For instance, to apply the function $g()$ to the input quantity 3, any of the following mathematical expressions might be used:
$$g(3)\ \ \ \text{or}\ \ \ \ g(x=3) \ \ \ \text{or}\ \ \ \ g(x)\left.\Large\strut\right|_{x=3}\ .$$
Remember that $g(3)$ or its equivalents are not themselves functions. They are the quantity that results from applying a the function to an input quantity.

## Computing notation

- Use the word "argument" to refer to the input to a function.

- Bound parameters listed as arguments to the function with default values

- Unbound parameters need to be specified as inputs when evaluating the function.


::: {.takenote}
A notation like $g(3)$ is called ***functional notation***. As you've seen, $g()$ is the name of the function, $3$ is the value of the input, and the parentheses are punctuation that keeps the expression organized and readable. 

You have even more experience with ***infix notation*** for functions that take two inputs. Examples are `3 + 4` or `2^3`. The function names here are `+` and `^` respectively. There are no parentheses; the function names are used to separate the two inputs. 
:::



## R/mosaic

Things that are specific to R/mosaic:

Use of tilde expressions to represent formulas.

Listing parameters are arguments to functions.


- assignment
- formulas and tilde-expressions
- functions from formulas: `makeFun()`
- examples other ways to make functions
- functions to scalars: `Zeros`, `ArgM`




## Parentheses

::: {.why  data-latex=""}
In writing $\line(x) \equiv a [x - x_0]$ I used ***square braces*** $\left[\strut\ \right]$ rather than parentheses $\left(\strut\ \right)$ to surround $x - x_0$. Either could be used and there is no difference in meaning. In traditional mathematical notation, either serves to demarcate a sub-expression. We'll be using parentheses very extensively in expressions like $\line(x)$, so it's nice to have a visual break. 
:::



## Applying functions to inputs

## Words for using functions

Throughout this course, I use the words ***inputs*** and ***output*** to refer to what is handed off to a function and what is received back as the result. But "handed off" is a metaphor and not a clear naming of what we mean when we use a function. This section simply gives some vocabulary to describe various aspects of using functions. The concept of functions is so fundamental in mathematics and computing, that there are many synonyms for each aspect. It helps to be aware of these synonyms since different people will write about functions in different---but equivalent!---ways.  `r mark(540)`

In everyday speech, an "argument" is a discussion between people with differing views. But in computing, ***argument*** means something else entirely: it is a synonym for "input to a function." It's good to have a concrete image in mind, so I'll suggest thinking of a computer printer as an analogy for a function. A computer printer takes several different kinds of input: electricity, paper, ink or toner, instructions transmitted via cable or wireless connection. Each of these inputs arrives at the printer through a particular interface: the electrical supply cord, a tray for holding paper, a tank or cartridge for ink, a radio receiver. These interfaces are the different inputs---or, to use the other word, arguments---of the printer. 

Common sense tells you that you shouldn't put toner in the paper tray, or connect the electrical supply cord to the ink tank. You have to provide the right kind of stuff to each input interface in order to get the anticipated output from the printer. 

Our pattern-book functions all have a single input. With such functions it's appropriate to speak of "the input to" or "the argument of" the function. In general, the functions we will construct for modeling purposes with have multiple inputs or arguments. For instance, the function $g(x, y) \equiv e^x \sin(y)$ has both an "x-input" and a "y-input". You can just as well say "the x-argument of g()" or the "y-argument of g()," or even the "first argument of g()" and the "second argument of g()." Whether you use the preposition "of" or "to" is a matter of personal style; either will do.

The act of employing a function to produce the output that corresponds to a given set of inputs is much like "printing a file." Of course, the word "printing" is not the right choice for mathematical or computational functions. Instead, there are several equivalent phrases in common use:

i. "***Apply*** a function to arguments.
ii. "Invoke a function." 
iii. "Evaluate a function." 
iv. "Run a function."

In (ii) and (iv), there is an implicit "on its arguments." But any application/evaluation/running of a function necessarily involves giving specific values for the inputs. 

The difference between "a function" and "applying a function" is much the same as the difference between a printer and "printing a document," or a screwdriver and "driving (or extracting) a screw, or, for wizard-world fans, the difference between a "spell" and the act of "casting a spell." 

In R/mosaic, the application of a modeling function like `g()` (defined in an earlier paragraph) to its two arguments looks like `g(5, pi)` with the two arguments separated by a comma. It might also look like `g(z, pi)`, or even `g(x=z, y=pi)` or `g(y=pi, x=z)` where the use of the argument names save us the trouble of remembering which argument came first in the definition.  `r mark(550)`

When applying a function of **one** argument, refrain from using the argument name. It's unnecessary since you can hardly get the order of arguments wrong and, depending on who wrote the software for the function, they might not have used `x` as the name of the argument.

It's another matter when you are ***defining*** a function. For instance, $$g(x, y) \equiv e^x \sin(y)$$ does **not** mean "apply $g()$ to the arguments $x$ and $y$." Instead, it means, "I'm setting up $g()$ as a function, a kind of promise in the future that whenever you write $g(3, \pi)$ or something similar, the defined function will be applied to those arguments. But for now, you don't need to do any arithmetic or other calculation, just remember that you've made a promise named $g()$."

In R/mosaic, using a ***tilde-expression*** signals that you are asking for the same kind of promise to do something when the time for it comes. 



## Formulas in R

<!-- moved two exercise files inline: 
chicken-chew-screen.Rmd (was exercise 3.6)
dolphin-toss-candy.Rmd (was 3.7) -->

You're familiar to some extent with traditional mathematical notation for formulas. Yet in applied work, you will often need to translate such formulas into computer notation. This book is written using R, but particularly when mathematical formulas are involved, commands are similar across many computer languages, so what you learn will be applicable to any other languages such as Python or MATLAB.

The first high-level computer language was FORTRAN, released in 1957. The name stands for "formula translation." FORTRAN enabled arithmetic operations to be written in a way very nearly that of traditional notation. Until then, computer programs were written using alpha-numeric codes that were meaningless to a casual reader. We unfortunately still use the term "computer code" to refer to programs, despite 70-years progress in improving legibility. 

The best way to learn to implement mathematical formulas in a computer language is to read examples and practice writing them. 

Here are some examples:

Traditional notation | R notation 
---------------------|-------------
$3 + 2$              | `3 + 2`
$3 \div 2$           | `3 / 2`
$6 \times 4$         | `6 * 4`
$\sqrt{\strut4}$     | `sqrt(4)`
$\ln 5$              | `log(5)`
$2 \pi$              | `2 * pi`
$\frac{1}{2} 17$     | `(1 / 2) * 17`
$17 - 5 \div 2$      | `17 - 5 / 2`
$\frac{17 - 5}{\strut 2}$   | `(17 - 5) / 2`
$3^2$                | `3^2`
$e^{-2}$             | `exp(-2)`


Each of these examples has been written using numbers as inputs to the mathematical operations. The syntax will be exactly the same when using an input name such as `x` or `y` or `altitude`, for instance `(x - y) / 2`. In order for that command using `x` and `y` to work, some meaning must have been previously attached to the symbols. We'll come back to this important topic on another day.

Read through the above table of examples several times. Note down any that you find at all confusing. Then cover up the right side of the table and write down the R expression for each item on the left side. Similarly, cover up the left side of the table and translate the R expression into traditional notation.

::: {.scaffolding  data-latex=""}
Open a `r sandbox_link()` and, one at a time, write and run the R expression for each of these traditional-notation expressions. We give the numerical result for each of the traditional expressions to let you confirm that your R version is correct.

i. $(16 - 3)/2$ gives result `r (16-3)/2`
ii. $\sqrt{\frac{19}{3}}$ gives `r sqrt(19/3)`
iii. $\cos(\frac{2 \pi}{3})$ gives `r cos(2 * pi / 3)`
iv. $\pi^3 + 2$ gives `r pi^3 + 2`
v. $\pi^{3+2}$ gives `r pi^(3+2)`

:::

Once you have a grasp of how to render traditional-notation formulas into R, read these few principles to help consolidate your understanding.

i. Computer languages generally, and R in particular, involve expressions that are written in a typewriter format: one conventional character after another in a straight line. There are no superscripts or subscripts used. So, $\frac{1}{3}$ will be written `1/3`. The equivalent of $\sqrt{7}$ is `sqrt(7)`.
ii. Parentheses:
    a. When an opening parenthesis directly follows a name, as in `sqrt(`, it means that the named operation is to be ***applied*** to the quantity inside the parentheses. So `sqrt(7)` means "take the square root of 7" and `log(10)` means "take the (natural) logarithm of 10." The common mathematical functions typically take only one input. We'll stick with those for now.
    b. When an opening parenthesis does not directly follow a name, as in `6 - (2+3)`, the parentheses stand for ***grouping*** in exactly the same way as in traditional notation. For instance, $(6 + 15) / 3$ is translated as `(6 + 15) / 3`.
iii. Multiplication and exponentiation are often written traditionally in terms of the relative position of quantities. So $(3 + 2)\pi$ means to multiply 5 times $\pi$, even though there is no multiplication sign being written. Similar, $\pi^{3 + 2}$ means to raise $\pi$ to the fifth power. There is no "exponentiation sign" used, just the positioning of $3+2$ as a superscript: $^{3+2}$. In R (and almost every computer language) multiplication and exponentiation **must be written explicitly**. The quantities $(3 + 2)\pi$ and $\pi^{3 + 2}$ would be translated as `(3 + 2) * pi` and `pi^(3+2)`. 
    
One additional note: All these examples can be written with a single line of code, as is true for many short formulas. Later on, we'll encounter longer formulas that *could* be written on a single line but are more ## $=$, $\equiv$, $\rightarrow$, `<-` {#foursigns}

The $=$ sign carries a lot of weight in high-school notation. Too much weight. It is used for several meanings that ought to be distinguished one from another. Combining them all into one symbol leads to confusion and error.

**Meaning 1**: "Is defined to be ..."  

We use $\equiv$ in mathematical notation and `<-` in R. The notation in R is a bit simpler than the mathematical notation: it is a way of giving something a name. 
```r
name <- something
```
If the "something" is a function, you will see that on the left side of `<-`, for instance by use of the `makeFun()` operator in `h <- makeFun(x^2 ~ x)`. The left side is simply a name.

In math notation, the equivalent would be written $h(x) \equiv x^2$. The left side isn't exactly a name. It's a name followed by parentheses in which are the names being used in the algorithm.

Keep in mind that in writing about functions, we will generally provide a hint that the name refers to the function, writing $h()$ or `h()`. The parentheses aren't part of the name; the name here is $h$. But the parentheses remind us that $h$ is a function. `r mark(650)`

**Meaning 2**: "Happens to be ..."  

The acceleration due to gravity is often given the name $g$. On Earth's surface, it happens to be $9.8 \text{m}/\text{s}^2$. In our math notation, we will use the equal sign for this narrow meaning, as in $g=9.8\text{m}/\text{s}^2$. In R we will use `=`. 

**Meaning 3**: "Gets closer and closer to ..."

Calculus is about relationships: the connection between two (or more) things. So you will hear phrases like, "As $x$ increases, $f(x)$ decreases." Or, in everyday experience, "As it gets more humid, the weather becomes more uncomfortable." Or, "slower is safer," or "the spicier the better" or "the heavier the blanket, the warmer I'll be." (One of the important uses of ***derivatives*** in calculus is to represent such statements quantitatively. But that's a subject for the next Block.)

In calculus, sometimes you have to distinguish between "$x$ is zero" and "$x$ gets closer and closer to zero." We'll need this when we want to say, "It gets smaller and smaller, but doesn't disappear entirely." The symbol for "gets closer and closer to" is $\rightarrow$, as in $x \rightarrow 0$

::: {.takenote  data-latex=""}
In reading math, take care to notice which of $=$, $\rightarrow$, or $\equiv$ is being used. The sign has something important to say and is intended to help you make sense of what you read.
:::
readable when spread over two or more consecutive lines. 




## Exercises

`r insert_calcZ_exercise(5.1, "TKWEW", "Exercises/convention-drill.Rmd")`

`r insert_calcZ_exercise(5.2, "LDNE", "Exercises/function-notation.Rmd")`

`r insert_calcZ_exercise("5.3", "kZG5Fj", "Exercises/puppy-build-radio.Rmd")`

`r insert_calcZ_exercise("5.4", "aeOnO5", "Exercises/horse-sing-drawer.Rmd")`

`r insert_calcZ_exercise("5.5", "ooJK5d", "Exercises/pine-light-mug.Rmd")`



<!-- basic R instructions -->
`r insert_calcZ_exercise("3.5", "BXCA4", "Exercises/fish-sees-tree.Rmd")`


<!-- when things go wrong -->
`r insert_calcZ_exercise("XX.XX", "BaEJkS", "Exercises/seahorse-take-pen.Rmd")`

## More details on R functions {#R-function-details}

::: {.why  data-latex=""}
Some readers may have encountered R previously in a statistics or data science course. Those readers will be wondering what is the purpose of `makeFun()`. Experienced programmers know that the way you make functions in R is by using the `function` keyword. For instance:
```{r}
f <- function(x) { 3 + 2*x }
```

That's a completely correct and legitimate way to define a function in R and in most settings is the universal practice.

We developed `makeFun()` to handle a situation where computers, in their insistence on avoiding ambiguity, will do something that is not what the person familiar with math notation is likely to suspect. The problem comes up in something as simple as
```{r}
g <- function(x) { m*x + b }
```
In traditional math notation, $g(x) \equiv m x + b$, we are usually silent on where parameters like $m$ and $b$ are coming from. And, to be honest, you don't have to worry about this **until you try to evaluate the function**. `r mark(630)`

If you evaluate, say, the command $g(3)$, the R system knows how to find the right values for $m$ and $b$. If there are no such objects in the appropriate places in the R system, an error message will be generated. The rules that computer languages follow in tracking down symbols that aren't in the argument list are called ***scoping rules***. Scoping is an advanced programming concept and different languages use different rules. 

For those few whose programming background includes an understanding of scoping here's an explanation. The ordinary scoping rules in R would make undefined parameters like $m$ and $b$ in a function definition have bindings in the environment in which the function was defined. This would typically be the global environment, an unsatisfactory arrangement it would be difficult to customize an individual function or invocation of a function to use a specific value for the parameters. `makeFun()` is arranged to add any parameters in the function algorithm to the argument list. The `makeFun()` command creates a function with 3 arguments.
```{r}
makeFun(m*x + b ~ x)
```
The point of the `~ x` part of the tilde expression is simply to name which arguments should come first. To evaluate the function, you'll have to provide values for `m` and `b`. But some operations on a function---differentiation and anti-differentiation, in particular---can be done without having to specify parameter values. For those of you who know what differentiation or anti-differentiation are, here is an example:
```{r}
D(m*x + b ~ x)
antiD(m*x + b ~ x)
```

Sometimes you have particular numerical values in mind for the parameters. For instance, if you are modeling the trajectory of a ball, you will undoubtedly need to make use of gravitational acceleration at the Earth's surface, which is $9.8 \text{m}/\text{s}^2$. You might prefer not to include the specific number 9.8 in your function definitions so that you can use the same functions to model a ball's trajectory on Mars. But since most balls are thrown on Earth, maybe it's not worthwhile to insist that the value 9.8 be specified every time the function is used. You can have it both ways by using `g` as the parameter name and instruct R to set `g` to 9.8 *unless otherwise specified*. The function will look like this: `r mark(640)`

```{r}
ball_velocity <- makeFun(g*t + t0 ~ t, g = 9.8, t0 = 0)
# For Earth: falling 3 seconds from a standstill
ball_velocity(3)
# For Earth when the ball has an initial upward velocity of 10 m/s
ball_velocity(3, t0 = -10)
# For Mars ...
ball_velocity(3, t0 = -10, g = 3.711)
```
:::

Depending on the computer language things can be handled in one way or another. (For experienced computer programmers: This is the issue of ***scope*** and can be complex in its own right.) `r mark(580)`

In the software used in *MOSAIC Calculus* (R/mosaic, which is the R language augmented with the `mosaic` package of extensions), we will take a simple-to-use approach. It works like this: 

> All modeling functions we construct with R/mosaic will list parameters formally as ***arguments*** to the function.

It is as if we wrote in traditional notation $$g(x, m, b) \equiv m x + b$$

There is also a way to give default numerical values to parameters so that you can write $g(3.5)$ and the computer will know where to find the parameter values. In writing about formulas using math notation, we'll extend the traditional notation to write, for instance, $g(x, m=2, b=3) \equiv m x + b$.

In R/`mosaic`, we would construct a mathematical function like $g()$ using the `makeFun()` function:

```r
g <- makeFun(m*x + b ~ x, m=2, b=3)
```

You could also write 

```r
g <- makeFun(m*x + b ~ x)
```
but this notation means that you will have to give specific numerical values for the `m` and `b` inputs whenever you evaluate `g()`. There won't be any default values for the "parameters-as-inputs" `m` and `b`.  `r mark(590)`

<!-- Relevant Blog post: CalculusBlog/post-formal-arguments.Rmd -->


## *MOSAIC Calculus* naming conventions



Any name in the R language can refer to any sort of object. We will use the *MOSAIC Calculus* naming conventions in our use of R, so that the ability you develop to read math notation should help reading R **and vice versa**. `r mark(630)`

R/mosaic provides additional clues to distinguish between quantities and functions.

Almost all the time we will create a function using `makeFun()`. So when you see an R expression starting as `name <- makeFun(`tilde expression`)` you know for sure the name refers to a function.

As we get deeper into calculus, you will meet additional R operators that generate functions. We'll introduce these in good time, but for someone reviewing the course, these include `D()`, `antiD()`, `compose()` and `iterate()`.


