# Data and data graphics

<div style="float:right;">[![](www/icons/edit.png)](https://github.com/ProjectMOSAIC/MOSAIC-Calculus/blob/main/Preliminaries/06-data-and-data-graphics.Rmd)</div>

```{r include=FALSE}
book_file_name <- "preliminaries/06-data-and-data-graphics.html"
```




## Data frames

frame, case, variable, row, column

accessing and basic operations
- built-in data frames, by name
- names(), head(), 
- URLs, might use files, but only occasionally

::: {.takenote}
We use the word ***variable*** to refer to a column of a data frame.
When refering to a quantity that is an input to a function, we use "input" or "argument" (they're equivalent)
:::

Before modern computing, tables were one of the primary means to describe functions. People working with calculus needed a reference collection of books containing tables for the functions they used. `r mark(420)`

With computers, we have better and faster ways to get the output of a function from the input. Still, modelers often use recorded data to construct functions. Tables are perhaps the most widely used method for storing and accessing data, although electronic spreadsheets are used today instead of printed tables.

Even today, a table can be a nice way to describe a function when we are interested in the output from only a handful of the possible inputs. 

Conceptually, it's helpful to keep in mind that every pattern-book function is just a way of organizing information that could have been stored in a table. 

You will not have to generate tabular descriptions of functions to follow this book. It's much more convient to implement the function in software so that the output can easily be displayed for any given inputs. On the other hand, in this book we'll often use data in tabular form to create a modeling function. There's little point in introducing this until you have some additional calculus concepts, so be patient.


## Discrete vs continuous

This is calculus, so we'll be working with continuous inputs. Tables have discrete inputs.

- Spliner, smoother, fitting, as examples of turning discrete into continuous.

## Tables and functions

We will be using formulas extensively, but best if you can visualize functions generally as something that's not necessarily a formula. This section gives another perspective on how to describe and think about a function. Remember, functions ***take inputs*** and ***return the corresponding output***. Any arrangement that accomplishes this (and ensures  the same output is always returned for a given input) is a function, even if arithmetic is nowhere in sight. For example, a simple and useful framework for organizing information is the ***table***, generally set up as an array of rows and columns. A table can be thought of as a function, despite it not containing any formulas or arithmetic: it relates one or more columns (the input) to another column (the output).

 For instance, here is a table about several internal combustion engines of various sizes:

```{r engine-table, echo=FALSE, fig.cap="Various attributes of internal combustion engines, from the very small to the very large."}
set.seed(104)
if (knitr::is_latex_output()) {
  knitr::kable(sample(Engines, size=8) %>%
                select(Engine, mass, BHP, RPM, bore, stroke) %>%
                arrange(mass))
} else {
  knitr::kable(sample(Engines, size=8) %>%
                select(Engine, mass, BHP, RPM, bore, stroke) %>%
                arrange(mass),
              rownames=FALSE, autoHideNavigation=TRUE) %>%
    kableExtra::kable_styling()
}
```

Each row of the table reports on one, specific engine. Each column is one attribute of an engine. Using such tables can be easy. For example, if asked to report how fast the engine named "Enya 60-4C" spins, you would go down to the Enya 60-4C row and over to the "RPM" column and read off the answer: 11,800 revolutions per minute (RPM).

A table like this describes the general relationships between engine attributes. For instance, we might want to understand the relationship (if any) between RPM and engine mass, or relate the diameter (that is, "bore") and depth (that is, "stroke") of the cylinders to the power generated by the engine. Any single entry in the table doesn't tell us about such general relationships; we need to consider the rows and columns as a whole. `r mark(310)`

If you examined the relationship between engine power (`BHP`) and bore, stroke, and RPM, you will find that (as a rule) the larger the bore and stroke, the more powerful the engine. That's a ***qualitative*** description of the relationship. Most educated people are able to understand such a qualitative description. Even if they don't know exactly what "power" means, they have some rough conception of it.

Often, we're interested in having a ***quantitative*** description of a relationship such as the one (bore, stroke) $\rightarrow$ power. Remarkably, many otherwise well-educated people are uncomfortable with the idea of using quantitative descriptions of a relationship: what sort of language the description should be written with; how to perform the calculations to use the description; how to translate between data (such as in the table) and a quantitative description; how to translate the quantitative description to address a particular question or make a decision.








## A bureaucratic analogy {#bureaucratic}

You'll have many opportunities to work with functions defined by formulas. Here, the emphasis is that functions are really just a way of storing a correspondence of inputs to outputs and that formulas need have nothing to do with it except as one way of describing the pattern. Instead of a formula, imagine a long corridor with a sequence of offices, each identified by a room number. The input to the function is the room number. To ***evaluate*** the function for that input, you knock on the appropriate door and, in response, you'll receive a piece of paper with a number to take away with you. That number is the output of the function. `r mark(320)`

This will sound at first too simple to be true, but ... In a mathematical function each office gives out exactly the same number every time someone knocks on the door. Obviously, being a worker in such an office is highly tedious and requires no special skill. Every time someone knocks on the worker's door, he or she writes down the *same* number on a piece of paper and hands it to the person knocking. What that person will do with the number is of absolutely no concern to the office worker.

The utility of such functions depends on the artistry and insight of the person who creates them: the ***modeler***. An important point of this course is to teach you some of that artistry. Hopefully you will learn through that artistry to translate your insight to the creation of functions that are useful in your own work. But even if you just use functions created by others, knowing how functions are built will be helpful in using them properly.

In the sort of function just described, all the offices were along a single corridor. Such functions are said to have ***one input***, or, equivalently, to be "functions of one variable." To operate the function, you just need one number: the address of the office from which you'll collect the output.

Many functions have more than one input: two, three, four, ... tens, hundreds, thousands, millions, .... In this course, we'll work mainly with functions of two inputs, but the skills you develop will be applicable to functions of more than two inputs.

What does a function of two inputs look like in our office analogy? Imagine that the office building has many parallel corridors, each with a numeric ID. To evaluate the function, you need two numeric inputs: the number of the corridor and the number of the door along that corridor. With those two numbers in hand, you locate the appropriate door, knock on it and receive the output number in return. `r mark(330)`

Three inputs? Think of a building with many floors, each floor having many parallel corridors, each corridor having many offices in sequence. Now you need three numbers to identify a particular office: floor, corridor, and door.

Four inputs? A street with many three-input functions along it. Five inputs? A city with many parallel four-input streets. And on and on.

Applying inputs to a function in order to receive an output is only a small part of most calculations. Calculations are usually organized as ***algorithms***, which is just to say that algorithms are descriptions of a calculation. The calculation itself is ... a function!

How does the calculation work? Think of it as a business. People come to your business with one or more inputs. You take the inputs and, following a carefully designed protocol, hand them out to your staff, perhaps duplicating some or doing some simple arithmetic with them to create a new number. Thus equipped with the relevant numbers, each member of staff goes off to evaluate a particular function with those numbers. (That is, the staff member goes to the appropriate street, building, floor, corridor, and door, returning with the number provided at that office.) The staff re-assembles at your roadside stand, you do some sorting out of the numbers they have returned with, again following a strict protocol. Perhaps you combine the new numbers with the ones you were originally given as inputs. In any event, you send your staff out with their new instructions---each person's instructions consist simply of a set of inputs which they head out to evaluate and return to you. At some point, perhaps after many such cycles, perhaps after just one, you are able to combine the numbers that you've assembled into a single result: a number that you return to the person who came to your business in the first place.

A calculation might involve just one function evaluation, or involve a chain of them that sends workers buzzing around the city and visiting other businesses that in turn activate their own staff who add to the urban tumult.

The reader familiar with floors and corridors and office doors may note that the addresses are ***discrete***. That is, office 321 has offices 320 and 322 as neighbors. Calculus is about continuous functions, so we need a way to accept, say, 321.487... as an input. There is no such office. `r mark(340)`

A slight modification to the procedure will produce a continuous function. It works like this: for an input of 321.487... the messenger goes to both office 321 and 322 and collects their respective outputs. Let's imagine that they are -14.3 and 12.5 respectively. All that's needed is a small calculation, which in this case will look like $$-14.3 \times (1 - 0.487...)   + 12.5 \times 0.487...$$ This is called ***linear interpolation*** and lets us construct continuous functions out of discrete data.

In Blocks 2 and 5 we'll discuss other widely used ways to do this that produce not just continuous functions but ***smooth*** functions. Understanding the difference between continuous and smooth will have to wait until we introduce a couple more calculus concepts: derivatives and limits.


::: {.intheworld  data-latex=""}
**Weather forecasting by numerical process**

*[Weather forecasting by numerical process](https://archive.org/details/weatherpredictio00richrich/page/184/mode/2up?view=theater)* is a highly influential book, from 1922, by [Lewis Fry Richardson](https://en.wikipedia.org/wiki/Lewis_Fry_Richardson). He envisioned a calculation for a weather forecast as a kind of function. The domain for the forecast is the latitude and longitude of a point on the globe, rather than the rectilinear organization of corridor.

One fantastic illustration of the idea shows a building constructed in the form of an inside-out globe.  [Source](https://www.cabinetmagazine.org/issues/27/foer.php) At each of many points on the globe, there is a business. (You can see this most clearly in the foreground, which shows several boxes of workers.) `r mark(360)`

```{r echo=FALSE, out.width="70%", fig.align="center", fig.cap="An artist's depiction of the organization of calculations for weather forecasting by Richardson's system."}
knitr::include_graphics(normalizePath("www/Richardson-globe.jpg"))
```

In each business there is a person who will report the current air pressure at that point on the globe, another person who reports the temperature, another reporting humidity, and so on. To compute the predicted weather for the next day, the business has a staff assigned to visit the neighboring businesses to find out the pressure, temperature, humidity, etc. Still other staffers take the collected output from the neighbors and carry out the arithmetic to translate those outputs into the forecast for tomorrow. For instance, knowing the pressure at neighboring points enables the direction of wind to be calculated, thus the humidity and temperature of air coming in to and out of the region the business handles. In today's numerical weather prediction models, the globe is divided very finely by latitude, longitude, and altitude, and software handles both the storage of present conditions and the calculation from that of the future a few minutes later. Repeating the process using the forecast enables a prediction to be made for a few minutes after that, and so on.

Some of the most important concepts in calculus relate to the process of collecting outputs from neighboring points and combining them: for instance finding the difference or the sum. To illustrate, here is the first set of equations from Richardson's *Weather forecasting ...* written in the notation of calculus: `r mark(370)`

```{r echo=FALSE, out.width="70%", fig.align="center"}
knitr::include_graphics(normalizePath("www/Richardson-equations.png"))
```

You can hardly be expected at this point to understand the calculations described by these equations, which involve the physics of air flow, the coriolis force, etc. but it's worth pointing out some of the notation:

- The equations are about the momentum of a column of air at a particular latitude ($\phi$) and longitude.
- $M_E$ and $M_N$ are east-west and north-south components of that momentum.
- $\partial M_E /\partial t$ is the rate at which the east-west momentum will change in the next small interval of time ($\partial t$).
- $p_G$ is the air pressure at ground level from that column of air.
- $\partial p_G / \partial n$ is about the difference between air pressure in the column of air and the columns to the north and south.

Calculus provides both the notation for describing the physics of climate and the means to translate this physics into arithmetic calculation.
:::


## Data graphics: the point plot

One of the most common uses of a graphics frame is to display visually two columns from a table containing data. Data are stored in a spreadsheet-like format called a ***data frame***. There are many ways to access data frames and many different ways to store them. In *MOSAIC Calculus* we supply data frames in the simplest possible way: giving them a name that you can use to refer to the data frame.

For instance, here is a small part of a data frame about the size of penguins in the Palmer Archipelago in Antarctica. `r mark(710)`

```{r echo=FALSE}
library(palmerpenguins)
set.seed(101)
knitr::kable(
  penguins %>% sample_n(10) %>%
    select(species, body_mass_g, flipper_length_mm, 
           bill_length_mm) %>%
    rename(body_mass = "body_mass_g", 
           flipper_length = "flipper_length_mm",
           bill_length = "bill_length_mm") %>%
    mutate(body_mass = body_mass/1000,
           flipper_length=flipper_length/10,
           bill_length = bill_length/10)
) %>% 
    kableExtra::kable_styling()
```

::: {.scaffolding  data-latex=""}
The output above shows what a data frame looks like. Now we need to look at how to use a data frame in an R command. The particular data frame shown just above has the name `penguins` in R. To refer to the data frame, just use the name.

Open a `r sandbox_link()` and give the name itself as a command. This simple command causes the data frame to be displayed on the screen.

```{r eval=FALSE}
penguins
```

You should see as a result a table that can be scrolled through interactively with all 344 rows of the `penguins` data frame.

*Looking* at a data frame, or part of one, is sometimes what's required. But in general you will use the name of the data frame of interest as an ***argument*** to an R function. Typically the argument will be named `data = ` as you'll see below.

The name `penguins` is very general and it wouldn't be at all surprising if some other penguin fan or researcher created a different set of data with the same name. R, like many other modern languages, makes room for such multiple uses of a name by a facility called a ***namespace***. R programmers can create their own namespace. This is not something we will do in this course. But it's helpful to know when the namespace mechanism is at work. For instance, the particular `penguins` we've provided with this course comes from a namespace called `palmerpenguins`. Thus, the "full" name of the data fr is `palmerpenguins::penguins`. You may see such name constructions occasionally in exercises in this course. You don't have to understand how namespaces work other than to know that when you are given the full name, you should use it, double colons and all.
:::

Before you can use `gf_point()` to plot a pair of columns from a data frame, you have to know the names of the columns. A useful function for this is `names()`. Similarly, to look at the first few rows, use the `head()` function. Try these commands in a sandbox:

```{r results="hide"}
names(penguins)
head(penguins)
```

## Point plots

A ***point plot*** displays two columns from a data frame. Each row in the data frame is represented by one point in the graphic. For instance:

```{r penguin-flipper, warning=FALSE, fig.cap="Data from 344 penguins on flipper length (mm) and body mass (g)."}
gf_point(flipper_length_mm ~ body_mass_g, 
         data=penguins) 
```

Each penguin has a specific mass and flipper length. If you focus your attention on the penguins with a mass of around 4 kg (that is, 4000 gm), you can see that the different penguins have a variety of flipper lengths. That's typical natural variability.




Two quantitative variables




::: {.intheworld}
Other statistical graphics, e.g. densities
:::

## Graphics layers

Add a function on top of a data set

Dots on axis, horizontal and vertical lines (e.g. zeros)
