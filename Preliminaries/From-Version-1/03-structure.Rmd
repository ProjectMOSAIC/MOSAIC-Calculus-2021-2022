# Structure of a function

<div style="float:right;">[![](www/icons/edit.png)](https://github.com/ProjectMOSAIC/MOSAIC-Calculus/blob/main/Block-1/03-structure.Rmd)</div>

> *The ideas which are here expressed so laboriously are extremely simple .... The difficulty lies, not in the new ideas, but in escaping from the old ones, which [branch]^[Original word: "ramify"], for those brought up as most of us have been, into every corner of our minds.* --- J. M Keynes, 1936, [*The General Theory of Employment, Interest, and Money*](files.ethz.ch/isn/125515/1366_KeynesTheoryofEmployment.pdf), 1936

You're used to mathematical functions being stated as ***formulas***, expressions composed of addition, multiplication, square roots, and so on. `r mark(300)`

- The expression $m x + b$ uses a multiplication and an addition. 
- $\sqrt{\strut 1 - x^2}$ uses squaring ($x^2$), subtraction and square root. 
- $3\sin\left(\frac{2 \pi}{P} x\right) + 4$ uses multiplications, division, sin function, and an addition

There's nothing in the mathematical concept of "function" that requires a formula. And computer functions in general are not based on an algebraic formula. The word used to describe the internals of a computer function is ***algorithm***, which is a generalization of "formula" that includes many non-arithmetic operations such as looping and branching.

When you press a function button like "sin" or "ln" or "exp" on a calculator, you likely have little idea what process is being set in action to create the result. Indeed, very few people do, even among professionals. This is not a problem. You can ***name*** the function that's appropriate for your purpose, you can ***apply*** the function to an input, and you can do something with the ***output***.

This chapter is about what functions are and how functions are organized: where the name goes, where the input goes, and what determines the output. 


## Inputs to output {#inputs-to-output}

We will be using formulas extensively, but best if you can visualize functions generally as something that's not necessarily a formula. This section gives another perspective on how to describe and think about a function. Remember, functions ***take inputs*** and ***return the corresponding output***. Any arrangement that accomplishes this (and ensures  the same output is always returned for a given input) is a function, even if arithmetic is nowhere in sight. For example, a simple and useful framework for organizing information is the ***table***, generally set up as an array of rows and columns. A table can be thought of as a function, despite it not containing any formulas or arithmetic: it relates one or more columns (the input) to another column (the output).

 For instance, here is a table about several internal combustion engines of various sizes:

```{r engine-table, echo=FALSE, fig.cap="Various attributes of internal combustion engines, from the very small to the very large."}
set.seed(104)
if (knitr::is_latex_output()) {
  knitr::kable(sample(Engines, size=8) %>%
                select(Engine, mass, BHP, RPM, bore, stroke) %>%
                arrange(mass))
} else {
  knitr::kable(sample(Engines, size=8) %>%
                select(Engine, mass, BHP, RPM, bore, stroke) %>%
                arrange(mass),
              rownames=FALSE, autoHideNavigation=TRUE) %>%
    kableExtra::kable_styling()
}
```

Each row of the table reports on one, specific engine. Each column is one attribute of an engine. Using such tables can be easy. For example, if asked to report how fast the engine named "Enya 60-4C" spins, you would go down to the Enya 60-4C row and over to the "RPM" column and read off the answer: 11,800 revolutions per minute (RPM).

A table like this describes the general relationships between engine attributes. For instance, we might want to understand the relationship (if any) between RPM and engine mass, or relate the diameter (that is, "bore") and depth (that is, "stroke") of the cylinders to the power generated by the engine. Any single entry in the table doesn't tell us about such general relationships; we need to consider the rows and columns as a whole. `r mark(310)`

If you examined the relationship between engine power (`BHP`) and bore, stroke, and RPM, you will find that (as a rule) the larger the bore and stroke, the more powerful the engine. That's a ***qualitative*** description of the relationship. Most educated people are able to understand such a qualitative description. Even if they don't know exactly what "power" means, they have some rough conception of it.

Often, we're interested in having a ***quantitative*** description of a relationship such as the one (bore, stroke) $\rightarrow$ power. Remarkably, many otherwise well-educated people are uncomfortable with the idea of using quantitative descriptions of a relationship: what sort of language the description should be written with; how to perform the calculations to use the description; how to translate between data (such as in the table) and a quantitative description; how to translate the quantitative description to address a particular question or make a decision.

This course is about constructing and using such quantitative descriptions: that is, ***mathematical modeling***. Skills for modeling are essential for work in engineering and science, and highly valued in many other fields in commerce, management, and government. Often, the work of applying such quantitative skills is called ***calculation***. The name ***calculus*** is used to describe the methods that are widely used for undertaking calculations.

***Functions*** are a fundamental way of organizing mathematical models and calculations. You have undoubtedly seen them in your previous mathematics education, but it's worth reviewing them from the basics so that we can share a vocabulary for communicating about them.

- A function is a transformation from one or more ***inputs*** to an ***output***.
- To keep things simple, for now we'll focus on inputs and outputs that are ***numeric***. Later, we'll need a more nuanced view of "numeric" that takes into account the different kinds of things that are represented by numbers, e.g. length, power, RPM.

## A bureaucratic analogy {#bureaucratic}

You'll have many opportunities to work with functions defined by formulas. Here, the emphasis is that functions are really just a way of storing a correspondence of inputs to outputs and that formulas need have nothing to do with it except as one way of describing the pattern. Instead of a formula, imagine a long corridor with a sequence of offices, each identified by a room number. The input to the function is the room number. To ***evaluate*** the function for that input, you knock on the appropriate door and, in response, you'll receive a piece of paper with a number to take away with you. That number is the output of the function. `r mark(320)`

This will sound at first too simple to be true, but ... In a mathematical function each office gives out exactly the same number every time someone knocks on the door. Obviously, being a worker in such an office is highly tedious and requires no special skill. Every time someone knocks on the worker's door, he or she writes down the *same* number on a piece of paper and hands it to the person knocking. What that person will do with the number is of absolutely no concern to the office worker.

The utility of such functions depends on the artistry and insight of the person who creates them: the ***modeler***. An important point of this course is to teach you some of that artistry. Hopefully you will learn through that artistry to translate your insight to the creation of functions that are useful in your own work. But even if you just use functions created by others, knowing how functions are built will be helpful in using them properly.

In the sort of function just described, all the offices were along a single corridor. Such functions are said to have ***one input***, or, equivalently, to be "functions of one variable." To operate the function, you just need one number: the address of the office from which you'll collect the output.

Many functions have more than one input: two, three, four, ... tens, hundreds, thousands, millions, .... In this course, we'll work mainly with functions of two inputs, but the skills you develop will be applicable to functions of more than two inputs.

What does a function of two inputs look like in our office analogy? Imagine that the office building has many parallel corridors, each with a numeric ID. To evaluate the function, you need two numeric inputs: the number of the corridor and the number of the door along that corridor. With those two numbers in hand, you locate the appropriate door, knock on it and receive the output number in return. `r mark(330)`

Three inputs? Think of a building with many floors, each floor having many parallel corridors, each corridor having many offices in sequence. Now you need three numbers to identify a particular office: floor, corridor, and door.

Four inputs? A street with many three-input functions along it. Five inputs? A city with many parallel four-input streets. And on and on.

Applying inputs to a function in order to receive an output is only a small part of most calculations. Calculations are usually organized as ***algorithms***, which is just to say that algorithms are descriptions of a calculation. The calculation itself is ... a function!

How does the calculation work? Think of it as a business. People come to your business with one or more inputs. You take the inputs and, following a carefully designed protocol, hand them out to your staff, perhaps duplicating some or doing some simple arithmetic with them to create a new number. Thus equipped with the relevant numbers, each member of staff goes off to evaluate a particular function with those numbers. (That is, the staff member goes to the appropriate street, building, floor, corridor, and door, returning with the number provided at that office.) The staff re-assembles at your roadside stand, you do some sorting out of the numbers they have returned with, again following a strict protocol. Perhaps you combine the new numbers with the ones you were originally given as inputs. In any event, you send your staff out with their new instructions---each person's instructions consist simply of a set of inputs which they head out to evaluate and return to you. At some point, perhaps after many such cycles, perhaps after just one, you are able to combine the numbers that you've assembled into a single result: a number that you return to the person who came to your business in the first place.

A calculation might involve just one function evaluation, or involve a chain of them that sends workers buzzing around the city and visiting other businesses that in turn activate their own staff who add to the urban tumult.

The reader familiar with floors and corridors and office doors may note that the addresses are ***discrete***. That is, office 321 has offices 320 and 322 as neighbors. Calculus is about continuous functions, so we need a way to accept, say, 321.487... as an input. There is no such office. `r mark(340)`

A slight modification to the procedure will produce a continuous function. It works like this: for an input of 321.487... the messenger goes to both office 321 and 322 and collects their respective outputs. Let's imagine that they are -14.3 and 12.5 respectively. All that's needed is a small calculation, which in this case will look like $$-14.3 \times (1 - 0.487...)   + 12.5 \times 0.487...$$ This is called ***linear interpolation*** and lets us construct continuous functions out of discrete data.

In Blocks 2 and 5 we'll discuss other widely used ways to do this that produce not just continuous functions but ***smooth*** functions. Understanding the difference between continuous and smooth will have to wait until we introduce a couple more calculus concepts: derivatives and limits.

## Domain: input space

As you know, there is a powerful way of thinking about numbers in terms of ***space*** and ***geometry***. For instance, a single number corresponds to a point on a line: the so-called ***number line***. A pair of inputs, say, (x, y) corresponds to a point in a plane, often called the ***Cartesian coordinate plane***. Three numbers corresponds to a point in space, perhaps organized into (x, y, z) of a Cartesian space. There are higher-dimensional spaces, but usually special training is needed to become comfortable with them. If you are having this discomfort, you might prefer to work with the office analogy. Just for fun, here's how you can think of a 10-dimensional space: 10 numbers, one telling you which planet, the next specifying the continent on that planet, and so on for country, state, city, street, building, floor, corridor, door.

The set of inputs with which the function can be evaluated is called the ***domain*** of the function. Sometimes we describe the domain as a space, e.g. the number line, the plane, and so on. Sometimes domains including more restrictions. For instance, a particular input might have meaning only when positive, with no offices corresponding to negative values for that input. Or, an input might be restricted to be in the interval 0 to 1. Sometimes in calculus, the domain excludes an isolated point. For instance, there may be no office at the door marked 0 but the neighboring doors open into working offices. `r mark(350)`


## Range: output space

The ***range*** of a function is the set of all the *outputs* that can be produced. Since at this stage we're working only with functions that return a single number as output, it's common to describe the range as all or part of the number line. For instance, some functions only have positive outputs. Other functions' outputs are always in the interval 0 to 1. (This is the case, for instance, when the function returns a probability as the output.)


::: {.intheworld  data-latex=""}
**Weather forecasting by numerical process**

*[Weather forecasting by numerical process](https://archive.org/details/weatherpredictio00richrich/page/184/mode/2up?view=theater)* is a highly influential book, from 1922, by [Lewis Fry Richardson](https://en.wikipedia.org/wiki/Lewis_Fry_Richardson). He envisioned a calculation for a weather forecast as a kind of function. The domain for the forecast is the latitude and longitude of a point on the globe, rather than the rectilinear organization of corridor.

One fantastic illustration of the idea shows a building constructed in the form of an inside-out globe.  [Source](https://www.cabinetmagazine.org/issues/27/foer.php) At each of many points on the globe, there is a business. (You can see this most clearly in the foreground, which shows several boxes of workers.) `r mark(360)`

```{r echo=FALSE, out.width="70%", fig.align="center", fig.cap="An artist's depiction of the organization of calculations for weather forecasting by Richardson's system."}
knitr::include_graphics(normalizePath("www/Richardson-globe.jpg"))
```

In each business there is a person who will report the current air pressure at that point on the globe, another person who reports the temperature, another reporting humidity, and so on. To compute the predicted weather for the next day, the business has a staff assigned to visit the neighboring businesses to find out the pressure, temperature, humidity, etc. Still other staffers take the collected output from the neighbors and carry out the arithmetic to translate those outputs into the forecast for tomorrow. For instance, knowing the pressure at neighboring points enables the direction of wind to be calculated, thus the humidity and temperature of air coming in to and out of the region the business handles. In today's numerical weather prediction models, the globe is divided very finely by latitude, longitude, and altitude, and software handles both the storage of present conditions and the calculation from that of the future a few minutes later. Repeating the process using the forecast enables a prediction to be made for a few minutes after that, and so on.

Some of the most important concepts in calculus relate to the process of collecting outputs from neighboring points and combining them: for instance finding the difference or the sum. To illustrate, here is the first set of equations from Richardson's *Weather forecasting ...* written in the notation of calculus: `r mark(370)`

```{r echo=FALSE, out.width="70%", fig.align="center"}
knitr::include_graphics(normalizePath("www/Richardson-equations.png"))
```

You can hardly be expected at this point to understand the calculations described by these equations, which involve the physics of air flow, the coriolis force, etc. but it's worth pointing out some of the notation:

- The equations are about the momentum of a column of air at a particular latitude ($\phi$) and longitude.
- $M_E$ and $M_N$ are east-west and north-south components of that momentum.
- $\partial M_E /\partial t$ is the rate at which the east-west momentum will change in the next small interval of time ($\partial t$).
- $p_G$ is the air pressure at ground level from that column of air.
- $\partial p_G / \partial n$ is about the difference between air pressure in the column of air and the columns to the north and south.

Calculus provides both the notation for describing the physics of climate and the means to translate this physics into arithmetic calculation.
:::






## Formulas in R

<!-- moved two exercise files inline: 
chicken-chew-screen.Rmd (was exercise 3.6)
dolphin-toss-candy.Rmd (was 3.7) -->

You're familiar to some extent with traditional mathematical notation for formulas. Yet in applied work, you will often need to translate such formulas into computer notation. This book is written using R, but particularly when mathematical formulas are involved, commands are similar across many computer languages, so what you learn will be applicable to any other languages such as Python or MATLAB.

The first high-level computer language was FORTRAN, released in 1957. The name stands for "formula translation." FORTRAN enabled arithmetic operations to be written in a way very nearly that of traditional notation. Until then, computer programs were written using alpha-numeric codes that were meaningless to a casual reader. We unfortunately still use the term "computer code" to refer to programs, despite 70-years progress in improving legibility. 

The best way to learn to implement mathematical formulas in a computer language is to read examples and practice writing them. 

Here are some examples:

Traditional notation | R notation 
---------------------|-------------
$3 + 2$              | `3 + 2`
$3 \div 2$           | `3 / 2`
$6 \times 4$         | `6 * 4`
$\sqrt{\strut4}$     | `sqrt(4)`
$\ln 5$              | `log(5)`
$2 \pi$              | `2 * pi`
$\frac{1}{2} 17$     | `(1 / 2) * 17`
$17 - 5 \div 2$      | `17 - 5 / 2`
$\frac{17 - 5}{\strut 2}$   | `(17 - 5) / 2`
$3^2$                | `3^2`
$e^{-2}$             | `exp(-2)`

Each of these examples has been written using numbers as inputs to the mathematical operations. The syntax will be exactly the same when using an input name such as `x` or `y` or `altitude`, for instance `(x - y) / 2`. In order for that command using `x` and `y` to work, some meaning must have been previously attached to the symbols. We'll come back to this important topic on another day.

Read through the above table of examples several times. Note down any that you find at all confusing. Then cover up the right side of the table and write down the R expression for each item on the left side. Similarly, cover up the left side of the table and translate the R expression into traditional notation.

::: {.scaffolding  data-latex=""}
Open a `r sandbox_link()` and, one at a time, write and run the R expression for each of these traditional-notation expressions. We give the numerical result for each of the traditional expressions to let you confirm that your R version is correct.

i. $(16 - 3)/2$ gives result `r (16-3)/2`
ii. $\sqrt{\frac{19}{3}}$ gives `r sqrt(19/3)`
iii. $\cos(\frac{2 \pi}{3})$ gives `r cos(2 * pi / 3)`
iv. $\pi^3 + 2$ gives `r pi^3 + 2`
v. $\pi^{3+2}$ gives `r pi^(3+2)`

:::

Once you have a grasp of how to render traditional-notation formulas into R, read these few principles to help consolidate your understanding.

i. Computer languages generally, and R in particular, involve expressions that are written in a typewriter format: one conventional character after another in a straight line. There are no superscripts or subscripts used. So, $\frac{1}{3}$ will be written `1/3`. The equivalent of $\sqrt{7}$ is `sqrt(7)`.
ii. Parentheses:
    a. When an opening parenthesis directly follows a name, as in `sqrt(`, it means that the named operation is to be ***applied*** to the quantity inside the parentheses. So `sqrt(7)` means "take the square root of 7" and `log(10)` means "take the (natural) logarithm of 10." The common mathematical functions typically take only one input. We'll stick with those for now.
    b. When an opening parenthesis does not directly follow a name, as in `6 - (2+3)`, the parentheses stand for ***grouping*** in exactly the same way as in traditional notation. For instance, $(6 + 15) / 3$ is translated as `(6 + 15) / 3`.
iii. Multiplication and exponentiation are often written traditionally in terms of the relative position of quantities. So $(3 + 2)\pi$ means to multiply 5 times $\pi$, even though there is no multiplication sign being written. Similar, $\pi^{3 + 2}$ means to raise $\pi$ to the fifth power. There is no "exponentiation sign" used, just the positioning of $3+2$ as a superscript: $^{3+2}$. In R (and almost every computer language) multiplication and exponentiation **must be written explicitly**. The quantities $(3 + 2)\pi$ and $\pi^{3 + 2}$ would be translated as `(3 + 2) * pi` and `pi^(3+2)`. 
    
One additional note: All these examples can be written with a single line of code, as is true for many short formulas. Later on, we'll encounter longer formulas that *could* be written on a single line but are more readable when spread over two or more consecutive lines.   



When your R command is not a complete sentence, the `r sandbox_link()` will display an error like this:

<span style="font-color: red;"><code>Error in parse(text = x, keep.source = TRUE) : <text>:5:0: unexpected end of input </code></span>

The "unexpected end of input" is the computer's way of saying, "You haven't finished your sentence so I don't know what to do."

Each of these R expressions is incomplete. Your job, which you should do in a sandbox, is to turn each into a complete expression. Sometimes you'll have to be creative, since when a sentence is incomplete you, like the computer, don't really know what it means to say! But each of these erroneous expressions can be fixed by **adding** or **changing** text.

Open a sandbox and copy each of the items below, one at a time, into a sandbox. Press "Run code" for that item and verify that you get an error message. 

For the first item, the sandbox will look like this:

```{r echo=FALSE, fig.cap="Running an invalid command will produce an error message." }
knitr::include_graphics(normalizePath("www/sandbox-error.png"))
```

Then, fix the command so you get a numerical result rather than the error message.

Working through all of these will help you develop an eye and finger-memory for R commands.

i.  `sin 3`
iv. `((16 - 4) + (14 + 2) / sqrt(7)`
v. `pnorm(3; mean=2, sd=4)`
vi. `log[7]`
vii. `14(3 + 7)`
viii. `e^2`
ix. `3 + 4 x + 2 x^2`


## Exercises


`r insert_calcZ_exercise(3.1, "RLUCX", "Exercises/range-domain.Rmd")`

`r insert_calcZ_exercise("3.2", "pUKm4c", "Exercises/sheep-buy-dress.Rmd")`

`r insert_calcZ_exercise(3.3, "DLWSA", "Exercises/pattern-book-domain.Rmd")`

`r insert_calcZ_exercise(3.4, "MNCLS2", "Exercises/pattern-book-range.Rmd")`

`r insert_calcZ_exercise("3.5", "BXCA4", "Exercises/fish-sees-tree.Rmd")`


