[["change.html", "  Chapter 1 Change 1.1 Quantity vs number 1.2 Functions 1.3 Fundamental model of change 1.4 Exercises", "   2021-10-17 Chapter 1 Change Calculus is about change, and change is about relationships. Consider the complex and intricate network of relationships that determine climate: a changing climate implies that there is a relationship between, say, global average temperature and time. Scientists know temperature changes with levels of CO2 and methane which themselves change due to their production or elimination by atmospheric and geological processes. A change in one component of climate (e.g., ocean acidification or pH level) provokes change in others. Calculus is foundational to the study of such change relationships. 100 This book presents calculus in terms of two simple concepts central to the study of change: quantities and functions. Those words have everyday meanings which are, happily, close to the specific mathematical concepts that we will be using over and over again. Close … but not identical. So, pay careful attention to the brief descriptions that follow. 1.1 Quantity vs number A mathematical quantity is an amount. How we measure amounts depends on the kind of stuff we are measuring. The real-world stuff might be mass or time or length. It equally well can be velocity or volume or momentum or corn yield per acre. We live in a world of such stuff, some of which is tangible (e.g., corn, mass, force) and some of which is harder to get your hands on and your minds around (acceleration, crop yield, fuel economy). An important use of calculus is helping us conceptualize the abstract kinds of stuff as mathematical compositions of simpler stuff. For example, crop yield incorporates mass with length and time. Later, you’ll see us using the more scientific-sounding term dimension instead of “stuff.” In fact, Chapter 16 is entirely dedicated to the topic of dimensions, but for now it’s sufficient for you to understand that numbers alone are not quantities. Most people are inclined to think “quantity” is the same as “number”; they conflate the two. This is understandable but misguided. By itself a number is meaningless. What meaning does the number 5 have without more context? Quantity, on the other hand, combines a number with the appropriate context to describe some amount of stuff. The first thing you need to know about any quantity is the kind of stuff it describes. A “mile” is a kind of stuff: length. A meter is the same kind of stuff: length. A liter is a different kind of stuff: volume. A gallon and an acre-foot are the same kind of stuff: volume. But an inch (length) is not the same kind of stuff as an hour (time). “Stuff,” as we mean it here, is what we measure. As you know, we measure with units. Which units are appropriate depends on the kind of stuff. Meters, miles, microns are all appropriate units of length, even though the actual lengths of these units differ markedly. (A mile is roughly 1.6 million millimeters.) 110 Only after you know the dimension and units does the number have meaning. Thus, a number is only part of specifying a quantity. Here’s the salient difference between number and quantity when it comes to calculus: All sorts of arithmetic and other mathematical operations can be performed to combine numbers: addition, multiplication, square roots, etc. When performing mathematics on quantities, only multiplication and division are universally allowed. For addition and subtraction, square roots, and such, the operation makes sense only if the dimensions are suitable. The mathematics of units and dimension are to the technical world what common sense is in our everyday world. For instance (and this may not make sense at this point), if people tell me they are taking the square root of 10 liters, I know immediately that either they are just mistaken or that they haven’t told me essential elements of the situation. It’s just as if someone said, “I swam across the tennis court.” You know that person either used the wrong verb—walk or run would work—or that it wasn’t a tennis court, or that something important was unstated, perhaps, “During the flood, I swam across the tennis court.” 1.2 Functions The other central concept in the book is functions in their mathematical and computing sense. Functions are the primary topic for Block 1. A function is something that takes one or more inputs and returns an output. In calculus, we’ll deal mainly with functions that take one or more quantities as inputs and return another quantity as output. But sometimes we’ll work with functions that take functions as input and return a quantity as output. And there will even be functions that take a function as an input and return a function as output. A function is something that takes one or more inputs and returns an output. You’ve almost certainly seen functions expressed in the mathematical form \\(f(x)\\). The function is \\(f()\\), the input is \\(x\\). Perhaps it’s obvious at this point that \\(x\\) is a quantity. \\(f(x)\\) means to apply the function \\(f()\\) to the input quantity \\(x\\), creating the output \\(f(x)\\). In computing, there are explicit notations to identify the output of a function. Strangely, in high-school mathematics there is not. This is a major source of confusion both to students learning calculus and to professionals using computers to do the work of calculus. 120 It’s possible to present calculus without functions. For instance, Isaac Newton, the inventor of calculus, spoke of “flowing quantities.”1 It’s practically impossible (and generally unwise) to do computing without functions. They are a basic building block of every mainstream modern computer language. Since the operations of calculus in actual practice are performed on the computer, common sense suggests that we should describe calculus in terms of functions. That’s what we will do in this book. For you, this may take a bit of getting used to. The reason is that the notation used in high-school algebra and in almost all calculus texts is not the notation of functions. For example, many students are familiar with this famous equation: \\[y = m x + b\\] Using the language of math classes, we can say that the equation involves two “variables.” And from your experience, you know that the variables are \\(x\\) and \\(y\\). The other letters, \\(m\\) and \\(b\\), are something else. Many students will reflexively call them the “slope” and “intercept” of the “line.” You are so used to this that you probably don’t see the huge ambiguity involved. For instance, what is a variable? Common sense suggest that it’s a thing that varies. But if we know the value of \\(x\\), is it still a variable? In statistics, a variable is something else entirely: a trait. Since statistics and mathematics are used together, this is bound to bring confusion. 130 The notation of equations is a poor substitute for the notation of functions. For instance, what is the input and what is the output? It’s not explicitly stated in the equation. If, using the allowed manipulations of algebra, we re-arrange \\[y = m x + b \\ \\ \\text{into}\\ \\ \\ m = \\frac{y-b}{x}\\] do we still have a function? If so, is it the same function as \\(m x + b\\)? Would \\(x\\) be the input or would both \\(x\\) and \\(y\\) be inputs? How about \\(b\\)? And in the re-arrangement, we have a problem if \\(x\\) is zero, a problem we would never encounter in the original \\(y=mx+b\\). The engineers and mathematicians who invented computer languages realized that they had to be explicit in identifying the input, the output, and the function itself; computers demand unambiguous instructions.2 Sorting this out was a difficult process even for those mathematically talented and skilled pioneers of notation. So, you can be forgiven for the occasional confusion you have when dealing with notation that pre-dates computing. 140 In this book we’ll be explicit and consistent in the ways we denote functions so that you can always figure out what are the inputs and how they are being translated into the output. A good start in learning to read the function notation is to see the equivalent of \\(y=m x + b\\) in that notation: \\[g(x) \\equiv m x + b\\] Notice that we’re using \\(\\equiv\\) (with three parallel bars) rather than \\(=\\). Pronounce \\(\\equiv\\) as “is defined to be,” or “equiv” for short. There’s no \\(y\\). The \\(x\\) appears in parentheses on the left side of \\(\\equiv\\) to say explicitly “\\(x\\) stands for the input.” The notation provides a place to state the name of the function, in this case \\(g()\\), so that we can refer to the function unambiguously when we are doing operations on it. Since often we’ll be using many functions at the same time, it’s helpful to have a way to distinguish them by name. The functional notation makes it easy to create many different names, e.g. \\(g_\\star()\\), \\(h_\\text{altitude}()\\), azimuth(), and so on. The high-school habit of using \\(y\\) doesn’t give such flexibility. 1.3 Fundamental model of change At the start of the chapter, it says, “Calculus is about change, and change is about relationships.” The idea of a function gives a definite perspective on this. The relationship is between a function’s input and the function’s output. The input might be day of the year (1-365, often called the “Julian Date”), and the output cumulative rainfall up to that day. Every day it rains, the cumulative rainfall increases. For another function(, the input might be the altitude on your hike up Pikes Peak and the output the air temperature. Typically, as you gain altitude the temperature goes down. With still another function, the input might be the number of hours after noon, the output the brightness of sunlight. As the sun goes down, the light grows dimmer, but only to a point. 150 The rate of change is based on a simple question: If the input changes from \\(x = A\\) to \\(x = B\\), how much does the output change? Of course, the output from function \\(f(x)\\) will be \\(f(x=A)\\) and \\(f(x=B)\\) respectively. The rate-of-change relationship is the ratio \\[\\frac{\\color{red}{f(x=B) - f(x=A)}}{\\color{blue}{B-A}}\\ \\ \\text{also written}\\ \\ \\frac{\\color{red}{\\text{rise}}}{\\color{blue}{\\text{run}}}\\] Why do we focus on the rate of change rather than something simpler, for example the net change \\(\\color{red}{f(x=B) - f(x=A)}\\)? The reason goes back to a scientific breakthrough in the 1600s: the writing down of the Newton’s laws of motion. The language in which these laws were first successfully expressed is the language of rates of change. In the intervening 400 years, the laws have been updated with the theory of relativity and quantum mechanics. These laws too are expressed as rates of change. In undertaking to study just about any quantitative field from engineering to economics you’ll find that theory is expressed using functions and rates of change. You may recognize in the formula for the rate of change a familiar quantity: the slope of a line. Everyone understands what a line is, but the geometry is not our primary concern here. We describe relationships using functions and for us the straight-line function will be a fundamental way of expressing a relationship. Straight-line functions can be written in several ways, but we’ll tend to use two predominant forms: \\[\\line(x) \\equiv a x + b\\ \\ \\ \\text{or}\\ \\ \\ \\ \\line(x) \\equiv a [x - x_0]\\] The two forms are interchangeable, but as you’ll see in upcoming chapters, sometimes it’s more convenient to use one form or the other. In either case, the rate of change is, quantitatively, the value of the parameter \\(a\\). 160 The simple function \\(\\line(x)\\), whose change relationship we understand intuitively, will be used to approximate more complicated change relationships. With the approximation in place, we can do calculations about the change relationships much more easily. Collectively, the set of mathematical concepts and techniques that support describing and calculating on change relationships has the name Calculus. In writing \\(\\line(x) \\equiv a [x - x_0]\\) I used square braces \\(\\left[\\strut\\ \\right]\\) rather than parentheses \\(\\left(\\strut\\ \\right)\\) to surround \\(x - x_0\\). Either could be used and there is no difference in meaning. In traditional mathematical notation, either serves to demarcate a sub-expression. We’ll be using parentheses very extensively in expressions like \\(\\line(x)\\), so it’s nice to have a visual break. 1.4 Exercises Exercise 1.1: VDKUI Since the inputs to functions are quantities, it’s convenient to give them names that remind the human reader what they stand for. The most common name we will use in this book for an input to a function will be: \\(\\large x\\) a general-purpose name that complies with the practice in high-school algebra. Remember, for us \\(x\\) is not an “unknown” as it so often is in algebra; in calculus \\(x\\) is the name of an input. Perhaps next most common as an input name is \\(\\large t\\). This name is typically used when the input is meant to be time. So if we were creating a function to represent the relationship between time (of day) and outdoor brightness, we might use this notation: \\(\\text{brightness}(t)\\) Other input names we will use in this book are \\(y\\), \\(z\\), \\(u\\), \\(v\\), \\(w\\). But we won’t shy away from more descriptive names, like \\(T\\) for “temperature” or \\(V\\) for volume, or even \\(\\text{altitude}\\) (which describes itself). For each of the following function definitions, what is the input name? Question A Input name in \\(g(t) \\equiv 2 t^2 + 8\\)?     t\\(\\heartsuit\\ \\)       u︎✘        v︎✘        w︎✘        x︎✘        y︎✘        z︎✘ Question B Input name in \\(\\line(z) \\equiv a z + b\\)?     t︎✘        u︎✘        v︎✘        w︎✘        x︎✘        y︎✘        z\\(\\heartsuit\\ \\) Question C Input name in \\(h(t) \\equiv 2 t^2 + 8 w\\)?     t\\(\\heartsuit\\ \\)       u︎✘        v︎✘        w︎✘        x︎✘        y︎✘        z︎✘ Question D Input name in \\(f(u) \\equiv a u + b + u^2\\)?     t︎✘        u\\(\\heartsuit\\ \\)       v︎✘        w︎✘        x︎✘        y︎✘        z︎✘ Question E Input name in \\(g(w) \\equiv x + 4\\)? t︎✘ u︎✘ v︎✘ wExcellent!  x︎✘ Tricked you! It’s the name in the parentheses on the left side of \\(\\equiv\\) that matters. Evidently, the output of \\(g(w)\\) doesn’t depend on \\(w\\). That’s not much of a relationship, but it is a common one. y︎✘ z︎✘ Exercise 1.2: KHDUE Each of the plots shows the graph of a function with two inputs, \\(A\\) and \\(B\\), marked. Question A In plot (1), what is the rate of change over the interval \\(A\\) to \\(B\\)? (Pick the closest answer.) -15/2︎✘ Remember to take the difference: \\(f(B) - f(A)\\). 15/2︎✘ The order of A and B is significant! 2/15︎✘ It’s “rise” over “run”, not the other way around. -2/15︎✘ It’s “rise” over “run”, not the other way around. 8/2︎✘ The order of A and B is significant! -8/2Nice!  2/8︎✘ The order of A and B is significant! -2/8︎✘ It’s “rise” over “run”, not the other way around. -15/5︎✘ Remember to take the difference: \\(B - A\\) Question B In plot (2), what is the rate of change over the interval \\(A\\) to \\(B\\)? (Pick the closest answer.) -17/2︎✘ Remember to take the difference: \\(f(B) - f(A)\\). 2/17︎✘ It’s “rise” over “run”, not the other way around. -10/2︎✘ The order of A and B is significant! 10/2Nice!  2/10︎✘ The order of A and B is significant! -2/10︎✘ It’s “rise” over “run”, not the other way around. -17/-5︎✘ Remember to take the difference: \\(B - A\\) Question C We haven’t told you exactly how to do this yet, but give it a try. What is the rate of change near the point marked \\(C\\)? (Pick the closest answer.))     -1/2︎✘        -1︎✘        -2︎✘        -3︎✘        -3/2︎✘        -4︎✘        -5\\(\\heartsuit\\ \\) In Newton’s language, a “flowing quantity” was a fluent and the change in a flowing quantity was a fluxion.↩︎ Actually, it’s common to give computers ambiguous instructions. The computer will carry out the instruction in the way it does, which may not be anything like what the programmer expected or intended.↩︎ "],["pattern-book.html", "Chapter 2 Functions for modeling 2.1 Pattern-book functions 2.2 The power-law family 2.3 Constructing functions 2.4 Function shapes 2.5 Exercises", " Chapter 2 Functions for modeling Mathematical modeling is a process where mathematics is used to understand, analyze, or predict a real-world situation. This process often occurs in cycles that revisit each of the following three stages: 200 Translate the real-world situation into a mathematical form (called a model) Shape the model to answer the question at hand Evaluate the model’s reliability and agreement with the real-world situation We’ll discuss each stage of the modeling process in the following paragraphs and explore as a concrete example the way Sir Isaac Newton applied his theory of universal gravitation to the motion of planets. The first stage of mathematical modeling involves translating the real-world situation into a mathematical form; the output or result of this stage is called a mathematical model. In this book the objective of the translation phase will almost always be to choose or construct one or more functions that represent the relationships involved in the system being studied. You’ll learn several strategies for turning what you know about the system into appropriate functions. And you’ll learn some standard frameworks for organizing your ideas to help you determine how functions will be related, for instance Newton’s framework relating position, velocity, and acceleration as rates of change of one another. 210 As a concrete example of this first stage, consider how Newton had to translate observations about planetary motion into a mathematical form. He was trying to make sense of the motion of planets in light of his novel theory that gravity is a universal force of attraction between all masses, rather than something peculiar to celestial bodies. He showed that the motions of planets, moons, and the Sun are governed by the same basic principles as an apple falling from a tree. To do this, he modeled force as a quantity that can be measured, simplified the complexity of the planets to mere masses (another measurable quantity), and supposed that position and motion were related. His theory of the motion of planets was based on two fundamental mathematical models: First, \\[F = ma\\ \\ \\ \\text{(Newton&#39;s Second Law)}\\] which relates force, mass, and acceleration. Second, the \\[F = \\frac{G m_1 m_2}{d^2}\\ \\ \\ \\text{(Law of Universal Gravitation)}\\] (sometimes called the inverse square law), which relates the mass of two objects (\\(m_1\\) and \\(m_2\\)), and the distance between them to the force of gravitation. We’ll get to the purpose of the \\(G\\) in Chapter 16, but for the moment, understand that this process of translating observations about planetary motion into a mathematical form is characteristic of the first stage of the modeling process. The second stage of modeling involves doing mathematical work to shape the model into a form that can directly answer the modeler’s question of interest. For instance, Newton knew from previous astronomical observations and Kepler’s theorizing that planets’ orbits are elliptical in shape that he needed to do some work on his two models in order to deduce the orbital shapes consistent with his Second Law and Universal Gravitation. In this book you’ll learn to use several key tools for doing mathematical work on functions. We might as well name them now: differentiation, anti-differentiation, optimization, and zero-finding. These tools derive directly from Newton’s work on planetary motion, but thankfully, we are not constrained to using the technology of his day in their application. Instead, we will leverage modern computers to make each tool easier to use. Your job is to learn enough about them that you will know when, how, and why to use each tool. The third and final stage of mathematical modeling often involves evaluating the model. The goal is to determine how reliable is the model’s answer and to see if the consequences of the model are consistent with what happens in the real world. The evaluation often leads to a re-assessment of the model and a return to stage 1 to improve things. The resulting loop is called the modeling cycle. For example, it seems likely that Newton did not start out knowing that gravitation follows an inverse square law. Perhaps he went through several modeling cycles until he found the form that was consistent with Kepler’s elliptical orbits. In this book you’ll learn techniques for comparing models to data and for making predictions from models that can be compared to observations. You’ll also see examples of when the evaluation of a function suggests revisions that might improve the model. 2.1 Pattern-book functions In this section, we introduce the Pattern-book functions–a short list of simple mathematical functions that provide a large majority of the tools for representing the real world as a mathematical object. Think of the items in this list as different actors, each of whom is skilled in portraying an archetypical character: hero, outlaw, lover, fool, comic. A play brings together different characters, costumes them, and relates them to one another through dialog or other means. All this is for the purpose of telling a story and providing insight into human relationships and emotions. 230 A mathematical model is a kind of story and a mathematical modeler a kind of playwright. She combines mathematical character types to tell a story about relationships. But there is only a handful of archetypal mathematical functions, the analog of the character actors in drama and comedy. In creating a mathematical model, you clothe the actors to suit the era and location and assemble them together in harmony or discord. Costume designers and others do not start from nothing. There are reference guides that collect patterns which a designer can customize to the needs at hand. These reference guides are sometimes called “pattern books.” (See Figure 2.1 for an example.) Figure 2.1: A pattern book of theatrical costumes Similarly, we will start with a pattern set of functions that have been collected from generations of experience. To remind us of their role in modeling, we’ll call these pattern-book functions. These pattern-book functions are useful in describing diverse aspects of the real world and have simple calculus-related properties that make them relatively easy to deal with. There are just a handful pattern-book functions from which untold numbers of useful modeling functions can be constructed. Mastering calculus is in part a matter of becoming familiar with the mathematical connections among the pattern-book functions. (You’ll see these in due time.) Here is a list of our pattern-book functions showing both a traditional notation and the R formula: Pattern name Traditional notation R notation exponential \\(e^x\\) exp(x) logarithm (“natural log”) \\(\\ln(x)\\) log(x) sinusoid \\(\\sin(x)\\) sin(x) square \\(x^2\\) x^2 proportional \\(x\\) x constant \\(1\\) 1 reciprocal \\(1/x\\) or \\(x^{-1}\\) 1/x gaussian \\(\\dnorm(x)\\) dnorm(x) sigmoid \\(\\pnorm(x)\\) pnorm(x) These functions are shown with a traditional formula notation to highlight the connections to the math you already studied, and \\(x\\) is used as the input to these functions out of tradition. 240 The list of pattern-book functions is short. You should memorize the names and be able easily to associate each name with the traditional notation. Over the next several chapters, we will introduce several features of functions. These features include: monotonicity up or down concavity up or down horizontal asymptotes vertical asymptotes periodicity continuity By the end of Block 1, you should be able to list all the basic pattern-book functions and describe the features relevant to each. 250 These pattern-book functions are widely applicable. But nobody would confuse the pictures in a pattern book with costumes that are ready for wear. Each pattern must be tailored to fit the actor and customized to fit the theme, setting, and action of the story. 260 Similarly, the mathematical functions used in real-world applications—as opposed to the pattern-book functions—are adorned with parameters. Parameters do the work of fitting the pattern to the units and dimensions of the input and output quantities. Continuing our analogy, if the pattern is for a sock, the parameter is the size needed to fit the foot. And just as there are different systems for sizing shirts, trousers, shoes, and so on, tradition has favored idioms for parameterizing the different kinds of pattern-book functions. We haven’t yet introduced these idioms, but when we do in Chapter 7 you are well advised to learn to interpret them at a glance. There is universal agreement about the names of all of the pattern-book functions except for two: the gaussian and the logarithm. The name “gaussian” is not descriptive; the graph of a gaussian function looks like a camel’s hump, the curve of a bell, or a bump in the road. There are all sorts of bell-shaped functions that differ slightly in their origins and detailed shape. In this book, we may use the terms “hump”, “bell”, or “bump” to remind you of the basic shape, but the specific mathematical function we have in mind is called the gaussian function, named after a tremendously influential mathematician, Carl Friedrich Gauss (1777-1855). This function, first published in 1718 (before Gauss was born), has an important role throughout physical science, technology, and data science. In probability theory and the social sciences, the shape of the function is given the simple name “normal distribution”; it shows up in so many places to be considered utterly unsurprising and “normal.” The name “logarithm” is anything but descriptive. The name was coined by the inventor, John Napier (1550-1617), to emphasize the original purpose of his invention: to simplify the work of multiplication and exponentiation. The name comes from the Greek words logos, meaning “reasoning” or “reckoning,” and arithmos, meaning “number.” A catchy marketing term for the new invention, at least for those who speak Greek! Although invented for the practical work of numerical calculation, the logarithm function has become central to mathematical theory as well as modern disciplines such as thermodynamics and information theory. The logarithm is key to the measurement of information and magnitude. As you know, there are units of information used particularly to describe the information storage capacity of computers: bits, bytes, megabytes, gigabytes, and so on. Very much in the way that there are different units for length (cm, meter, kilometer, inch, mile, …), there are different units for information and magnitude. For almost everything that is measured, we speak of the “units” of measurement. For logarithms, instead of “units” by tradition another word is used: the base of the logarithm. The most common units outside of theoretical mathematics are base-2 (“bit”) and base-10 (“decade”). But the unit that is most convenient in mathematical notation is “base e,” where \\(e = 2.71828182845905...\\). This is genuinely a good choice for the units of the logarithm, but that’s hardly obvious to anyone encountering it for the first time. To make the choice more palatable, it’s marketed as the “base of the natural logarithm.” In this book, we’ll be using this natural logarithm as our official pattern-book logarithm. 2.2 The power-law family Three of the pattern-book functions—\\(1/x\\), \\(x\\), \\(x^2\\)—actually belong to an infinite family called the power-law functions. The three shown above occur so often and are so closely related to the other pattern-book functions that they receive their own special names (inverse, proportional, and square) and place in our list; however, it is the family of power-law functions that form the more general pattern needed for modeling. Some other examples of power-law functions are \\(x^3, x^4, \\ldots\\) as well as \\(x^{1/2}\\) (also written \\(\\sqrt{x}\\)), \\(x^{1.36}\\), and so on. Some of these also have special (albiet less frequently used) names, but all of the power-law functions can be written as \\(x^p\\), where \\(x\\) is the input and \\(p\\) is a number. 290. Within the power-law family, it is helpful to know and be able to differentiate between several overlapping groups: The monomials. These are power-law functions such as \\(m_0(x) \\equiv x^0\\), \\(m_1(x) \\equiv x^1\\), \\(m_2(x) \\equiv x^2\\), \\(\\ldots\\), \\(m_p(x) \\equiv x^p\\), \\(\\ldots\\), where \\(p\\) is a whole number (i.e., a non-negative integer). Of course, \\(m_0()\\) is exactly the same as the constant function, since \\(x^0 = 1\\). Likewise, \\(m_1(x)\\) is the same as the identity function since \\(x^1 = x\\). As for the rest, they have just two general shapes: both arms up for even powers of \\(p\\) (like in \\(x^2\\), a parabola); one arm up and the other down for odd powers of \\(p\\) (like in \\(x^3\\), a cubic). Figure 2.2: Graphs of the monomial functions from order 2 to 5. The negative powers. These are power-law functions where \\(p&lt;0\\), such as \\(f(x) \\equiv x^{-1}\\), \\(g(x) \\equiv x^{-2}\\), \\(h(x) \\equiv x^{-1.5}\\). For negative powers, the size of the output is inversely proportional to the size of the input. In other words, when the input is large (not close to zero) the output is small, and when the input is small (close to zero), the output is very large. This behavior happens because a negative exponent like \\(x^{-2}\\) can be rewritten as \\(\\frac{1}{x^2}\\); the input is inverted and becomes the denominator, hence the term “inversely proportional”. Figure 2.3: Graphs of power-law functions with negative exponents. Note that the function output is very large when \\(x\\) is near zero. The non-integer powers, e.g. \\(f(x) = \\sqrt{x}\\), \\(g(x) = x^\\pi\\), and so on. When \\(p\\) is either a fraction or an irrational number (like \\(\\pi\\)), the real-valued power-function \\(x^p\\) can only take non-negative numbers as input. In other words, the domain of \\(x^p\\) is \\(0\\) to \\(\\infty\\) when \\(p\\) is not an integer. You have likely already encountered this domain restriction when using the power law with \\(p=\\frac{1}{2}\\), since \\(f(x)\\equiv x^{1/2}=\\sqrt{x}\\), and the square root of a negative number is not a real number. Some of you may have heard about the imaginary numbers that allow you to take the square root of a negative number, but for the moment, you only need to understand that when working with real-valued power-law functions with non-integer exponents, the input must be non-negative. (The story is actually a bit more complicated since, algebraically, rational exponents like \\(1/3\\) or \\(1/5\\) with an odd-valued denominator can be applied to negative numbers. Computer arithmetic, however, does not recognize these exceptions.) Figure 2.4: The domain of power-law functions with non-integer power is \\(0 \\leq x &lt; \\infty\\). 2.3 Constructing functions Often, modeling involves building a complicated function out of the simple shapes provided by the pattern-book functions. This is not yet the time to say much more, but we do want to show you what such a construction looks like in both a traditional style of notation and the style used for programming computers. As you’ll see later, in Chapter 11, to make complicated functions we generally combine simpler functions in one or more of three different ways: linear combinations, products, and composition. 270 As a very brief introduction, consider these examples. A polynomial is a linear combination of simple functions called “monomials.” These are likely familiar to you in traditional notation: \\[g(x) \\equiv 2 + 3 x - 7x^2\\] In the R/mosaic computer notation we will be using the function \\(g()\\) would be defined like this: g &lt;- makeFun(2 + 3*x - 7*x^2 ~ x) Notice that the R/mosaic notation has most elements in common with the traditional notation, but the order is somewhat different. g &lt;- means to give the function the name \\(g.\\) (In this book, I usually write function names with a pair of parentheses as a suffix, e.g. \\(g(x).\\) This reminds you that the name refers to a function. But the R name is simply g, even though I often write it as g() in the text.) The &lt;- is called the assignment operator, the instruction in R to give a name to an object. Here, the object will be the R function created by makeFun(). 2 + 3*x - 7*x^2 is the formula for the function, that is, the expression found on the right-hand side of \\(\\equiv\\) in the traditional notation. ~ x is the part of the R/mosaic notation that says, “The name of the input will be x.” In traditional notation, the name of the input is in parentheses following the name of the function \\(g\\,{\\mathbf{(x)}}\\), but in R/mosaic notation, the two are in different places: the function name is to the left of the assignment operator (&lt;-) and the name of the name of the input follows the tilde (~). The formula and the name of the input are always related in the R/mosaic notation by what is called a tilde expression. The formula is on the left-hand side of the tilde (~) and the argument name is on the right-hand side of the tilde. If there is more than one argument, all the names go on the right-hand side of the tilde expression, separated by &amp;. (Some people prefer to use + as the separator. That’s fine, but we use the &amp; convention throughout this book.) makeFun() is the R/mosaic operator that takes the information contained in the tilde expression and turns it into an R function; it literally “makes an R function”, hence the name, makeFun(). Functions constructed as a product of simple functions can look like this in tradition notation: \\[h(t) \\equiv \\sin(t) e^{-t}\\] and like this in computer notation: h &lt;- makeFun(sin(t)*exp(-t) ~ t) In function composition, the output of one function is the input to a second function, as with \\[H(t) \\equiv \\sin\\left(e^{-t}\\right)\\] or, in computer notation, H &lt;- makeFun(sin(exp(-t)) ~ t) 2.4 Function shapes You are going to be building models by selecting an appropriate function or by putting functions together in various ways. This might remind you of Lego blocks. As you know, Legos come in different shapes: \\(6\\times 2\\), \\(4\\times 2\\), \\(2\\times 2\\), and so on. Similarly, each of the pattern-book functions has a distinctively shaped graph. Knowing the shapes by name will help you when you need to build a model. 280 The proportional function and the constant function have extremely simple shapes. Note that the graph of a constant function is not just any line, but a line with zero slope. ## Warning in validate_domain(domain, free_args): Missing domain names: x ## Warning in validate_domain(domain, free_args): Missing domain names: x It is tempting to deny that the constant function is a function. After all, the output does not depend on the input. Still, this situation arises frequently in modeling: you start out supposing that one quantity depends on another, but it sometimes turns out that it does not. Since functions are our way of representing relationships, it is helpful to have a function for the situation of “no relationship.” The constant function does this job. You may also notice the proportional function shown above does nothing to change the input; it simply returns as output the same value it received as input. For this reason, the proportional pattern-book function (\\(f(x)=x\\)) is sometimes called the identity function. Later we will show how this simple pattern-book function can be endowed with parameters that form the basis of many change relationships. Functions like sin(), log(), pnorm() are always referred to by name with parentheses enclosing the arguments. Other functions are traditionally written without a name, for instance, like \\(e^x\\) or \\(1/x\\). These two different conventions can lead to confusion. There is little that can be done to avoid that confusion, since the dual conventions appear throughout technical work. If absolute consistency of notation were the prime goal, we could have written this book in a style that gives a name to every pattern-book function writes it in the name/parentheses style. Something like this: reciprocal &lt;- makeFun(1/t ~ t) constant &lt;- makeFun(1 ~ z) square &lt;- makeFun(x^2 ~ x) These would be used in the ordinary way, for instance: reciprocal(7) ## [1] 0.1428571 constant(123.67) ## [1] 1 square(19) ## [1] 361 Writing reciprocal(\\(x\\)) instead of \\(1/x\\) is long-winded, which is perhaps why you never see it. But when you see \\(1/x\\) you should think of it as a function being applied to \\(x\\) and not as a bit of arithmetic. By the way … I used different names for the inputs in these three functions just to remind the reader that, for functions with one input, the name has no significance. You just have to make sure to use the same name on the left- and right-hand sides of the tilde expression. 2.5 Exercises Exercise 2.1: H2KG3 Copy and paste the R/mosaic command below into a SANDBOX. The command shows a simple way to graph a function, in this case exp(). Press “Run code” to execute the command and draw the graph. slice_plot(exp(x) ~ x, domain(x=c(-3, 3))) In this exercise, you’ll be modifying the sandbox code to draw different functions, so you can examine their shapes. Your task is to read and interpret the graphs of the basic modeling functions. Here, you will be looking for zero-crossings: the neighborhood of a point in the function’s domain where the output of the function is negative for inputs on one side and positive for inputs on the other side. If zero is touched but not crossed, we’ll call that “touched zero.” Make a list of the pattern-book functions. For each function in the list, say whether the function crosses zero, touches zero but doesn’t cross, or doesn’t touch at all in the part of the domain shown in the graphic: \\(-3 \\leq x \\leq 3\\). Also note if the value of the function appears to be reaching a horizontal asymptote at zero for very negative \\(x\\), for very positive \\(x\\), for both, or neither. We’ll show you the answers for the exponential function. You’ll have to modify the computer command to graph the other pattern-book functions. function name R formula zero in domain shown in graph asymptotic zero exponential exp(x) no zeros for very negative \\(x\\) logarithm sinusoid square proportional constant reciprocal gaussian sigmoid Exercise 2.2: Pdt9jy On a piece of paper, sketch from memory a graph of each of the nine pattern-book functions. Exercise 2.3: VIW7T For each of the pattern-book functions except the reciprocal, the graph crosses either the vertical axis (that is \\(x=0\\)) or the horizontal axis (that is, \\(f(x) = 0\\)), or both. It’s helpful to know the exact quantitative value for the output where the function graph crosses the vertical axis. To answer these questions, you will want to open a SANDBOX to try the various possibilities. Question A What is the exact output of the pattern-book exponential function when the input is \\(x=0\\)?     0︎✘        0.3989423︎✘        1/2︎✘        1\\(\\heartsuit\\ \\) Question B What is the exact output of the pattern-book sine function when the input is \\(x=0\\)?     0\\(\\heartsuit\\ \\)       0.3989423︎✘        1/2︎✘        1︎✘ Question C What is the exact output of the pattern-book sigmoid function when the input is \\(x=0\\)?     0︎✘        0.3989423︎✘        1/2\\(\\heartsuit\\ \\)       1︎✘ Question D What is the output (to several digits) of the pattern-book hump function when the input is \\(x=0\\)?     0︎✘        0.3989423\\(\\heartsuit\\ \\)Right. But 0.4 will do when you’re sketching a graph.       1/2︎✘        1︎✘ Question E What is the exact output of the pattern-book constant function?     0︎✘        0.3989423︎✘        1/2︎✘        1\\(\\heartsuit\\ \\) Exercise 2.4: Qj0JAr Some of our pattern-book functions have a distinctive property called scale invariance. This means the graph of the function looks the same even when plotted on very different horizontal and vertical axes. The function \\(\\ln(x)\\) plotted on two different scales in Figure 2.5 shows that the graph of the function has practically the same shape. Figure 2.5: The logarithm function has the same overall shape even when plotted on domains of very different scales. Figure 2.6 shows a power-law function, \\(g(x) \\equiv x^2\\), which is also scale invariant. Figure 2.6: The function \\(x^2\\) shown on two very different domain scales has the same overall shape. Other pattern-book functions are not scale invariant, for example \\(\\sin(x)\\). Figure 2.7: The sin( ) function is not scale invariant. In contrast to scale-invariant functions, some of our pattern-book functions have a characteristic scale. This is a domain length over which the whole of a characteristic feature of the function is evident. Graphing on larger domains simply squashes down the characteristic feature to a small part of the graphic domain. For instance, in the \\(\\sin()\\) function the cycle is a characteristic feature. The cycle in the pattern-book sinusoid has a characteristic length of \\(2 \\pi\\), the length of the cycle. Consequently, the graph looks different depending on the length of the graphics domain in multiples of the characteristic length. You can see from Figure 2.7 that the graph on the domain \\(-10 &lt; x &lt; 10\\), that is, about 3 times the characteristic scale, looks different from the graph on the larger domain that has a length 30 times the characteristic scale. The output of the sigmoid function runs from 0 to 1 but reaches these values only asymptotically, as \\(x \\rightarrow \\pm \\infty\\). In defining a characteristic scale, it would be reasonable to look at the length of the domain that takes the output from, say, 0.01 to 0.99. In other words, we want the characteristic scale to be defined in a way that captures almost all the action in the output of the function. For a gaussian, a reasonable definition of a characteristic scale would be the length of domain where the output falls to about, say, 1% of it’s peak output. Question A The gaussian (hump) function dnorm() has a characteristic scale. Which of these is a domain length that can encompass the characteristic shape of the gaussian?     0.1︎✘        1︎✘        6\\(\\heartsuit\\ \\)The domain \\(-3 &lt; x &lt; 3\\) supports practically everything.       16︎✘        256︎✘ Question B The sigmoid function pnorm() also has a characteristic scale. Which of these is a domain length that can encompass the characteristic shape of the sigmoid?     0.1︎✘        1︎✘        6\\(\\heartsuit\\ \\)       16︎✘        256︎✘ Throughout science, it’s common to set a standard approach to defining a characteristic scale. For instance, the characteristic scale of an aircraft could be taken as the length of body. Gaussian and sigmoids are so common throughout science that there is a convention for defining the characteristic scale called the standard deviation. For the pattern book gaussian and sigmoid, the standard deviation is 1. That’s much shorter than the domain that captures the bulk of action of the gaussian or sigmoid. For this reason, statisticians in practice use a characteristic scale of \\(\\pm 2\\) or \\(\\pm 3\\) standard deviations. "],["structure-of-a-function.html", "Chapter 3 Structure of a function 3.1 Inputs to output 3.2 A bureaucratic analogy 3.3 Domain: input space 3.4 Range: output space 3.5 Formulas in R 3.6 Exercises", " Chapter 3 Structure of a function [F-10] Recognize that functions are a way of representing (storing) what we know and be able to use properly the basic nomenclature of functions). The ideas which are here expressed so laboriously are extremely simple …. The difficulty lies, not in the new ideas, but in escaping from the old ones, which [branch]3, for those brought up as most of us have been, into every corner of our minds. — J. M Keynes, 1936, The General Theory of Employment, Interest, and Money, 1936 You’re used to mathematical functions being stated as formulas, expressions composed of addition, multiplication, square roots, and so on. 300 The expression \\(m x + b\\) uses a multiplication and an addition. \\(\\sqrt{\\strut 1 - x^2}\\) uses squaring (\\(x^2\\)), subtraction and square root. \\(3\\sin\\left(\\frac{2 \\pi}{P} x\\right) + 4\\) uses multiplications, division, sin function, and an addition There’s nothing in the mathematical concept of “function” that requires a formula. And computer functions in general are not based on an algebraic formula. The word used to describe the internals of a computer function is algorithm, which is a generalization of “formula” that includes many non-arithmetic operations such as looping and branching. When you press a function button like “sin” or “ln” or “exp” on a calculator, you likely have little idea what process is being set in action to create the result. Indeed, very few people do, even among professionals. This is not a problem. You can name the function that’s appropriate for your purpose, you can apply the function to an input, and you can do something with the output. This chapter is about what functions are and how functions are organized: where the name goes, where the input goes, and what determines the output. 3.1 Inputs to output We will be using formulas extensively, but best if you can visualize functions generally as something that’s not necessarily a formula. This section gives another perspective on how to describe and think about a function. Remember, functions take inputs and return the corresponding output. Any arrangement that accomplishes this (and ensures the same output is always returned for a given input) is a function, even if arithmetic is nowhere in sight. For example, a simple and useful framework for organizing information is the table, generally set up as an array of rows and columns. A table can be thought of as a function, despite it not containing any formulas or arithmetic: it relates one or more columns (the input) to another column (the output). For instance, here is a table about several internal combustion engines of various sizes: Engine mass BHP RPM bore stroke Webra Speed 20 0.25 0.78 22000 16.5 16 Enya 60-4C 0.61 0.84 11800 24.0 22 Honda 450 34.00 43.00 8500 70.0 58 Jacobs R-775 229.00 225.00 2000 133.0 127 Daimler-Benz 609 1400.00 2450.00 2800 165.0 180 Daimler-Benz 613 1960.00 3120.00 2700 162.0 180 Nordberg 5260.00 3000.00 400 356.0 407 Cooper-Bessemer V-250 13500.00 7250.00 330 457.0 508 Each row of the table reports on one, specific engine. Each column is one attribute of an engine. Using such tables can be easy. For example, if asked to report how fast the engine named “Enya 60-4C” spins, you would go down to the Enya 60-4C row and over to the “RPM” column and read off the answer: 11,800 revolutions per minute (RPM). A table like this describes the general relationships between engine attributes. For instance, we might want to understand the relationship (if any) between RPM and engine mass, or relate the diameter (that is, “bore”) and depth (that is, “stroke”) of the cylinders to the power generated by the engine. Any single entry in the table doesn’t tell us about such general relationships; we need to consider the rows and columns as a whole. 310 If you examined the relationship between engine power (BHP) and bore, stroke, and RPM, you will find that (as a rule) the larger the bore and stroke, the more powerful the engine. That’s a qualitative description of the relationship. Most educated people are able to understand such a qualitative description. Even if they don’t know exactly what “power” means, they have some rough conception of it. Often, we’re interested in having a quantitative description of a relationship such as the one (bore, stroke) \\(\\rightarrow\\) power. Remarkably, many otherwise well-educated people are uncomfortable with the idea of using quantitative descriptions of a relationship: what sort of language the description should be written with; how to perform the calculations to use the description; how to translate between data (such as in the table) and a quantitative description; how to translate the quantitative description to address a particular question or make a decision. This course is about constructing and using such quantitative descriptions: that is, mathematical modeling. Skills for modeling are essential for work in engineering and science, and highly valued in many other fields in commerce, management, and government. Often, the work of applying such quantitative skills is called calculation. The name calculus is used to describe the methods that are widely used for undertaking calculations. Functions are a fundamental way of organizing mathematical models and calculations. You have undoubtedly seen them in your previous mathematics education, but it’s worth reviewing them from the basics so that we can share a vocabulary for communicating about them. A function is a transformation from one or more inputs to an output. To keep things simple, for now we’ll focus on inputs and outputs that are numeric. Later, we’ll need a more nuanced view of “numeric” that takes into account the different kinds of things that are represented by numbers, e.g. length, power, RPM. 3.2 A bureaucratic analogy You’ll have many opportunities to work with functions defined by formulas. Here, the emphasis is that functions are really just a way of storing a correspondence of inputs to outputs and that formulas need have nothing to do with it except as one way of describing the pattern. Instead of a formula, imagine a long corridor with a sequence of offices, each identified by a room number. The input to the function is the room number. To evaluate the function for that input, you knock on the appropriate door and, in response, you’ll receive a piece of paper with a number to take away with you. That number is the output of the function. 320 This will sound at first too simple to be true, but … In a mathematical function each office gives out exactly the same number every time someone knocks on the door. Obviously, being a worker in such an office is highly tedious and requires no special skill. Every time someone knocks on the worker’s door, he or she writes down the same number on a piece of paper and hands it to the person knocking. What that person will do with the number is of absolutely no concern to the office worker. The utility of such functions depends on the artistry and insight of the person who creates them: the modeler. An important point of this course is to teach you some of that artistry. Hopefully you will learn through that artistry to translate your insight to the creation of functions that are useful in your own work. But even if you just use functions created by others, knowing how functions are built will be helpful in using them properly. In the sort of function just described, all the offices were along a single corridor. Such functions are said to have one input, or, equivalently, to be “functions of one variable.” To operate the function, you just need one number: the address of the office from which you’ll collect the output. Many functions have more than one input: two, three, four, … tens, hundreds, thousands, millions, …. In this course, we’ll work mainly with functions of two inputs, but the skills you develop will be applicable to functions of more than two inputs. What does a function of two inputs look like in our office analogy? Imagine that the office building has many parallel corridors, each with a numeric ID. To evaluate the function, you need two numeric inputs: the number of the corridor and the number of the door along that corridor. With those two numbers in hand, you locate the appropriate door, knock on it and receive the output number in return. 330 Three inputs? Think of a building with many floors, each floor having many parallel corridors, each corridor having many offices in sequence. Now you need three numbers to identify a particular office: floor, corridor, and door. Four inputs? A street with many three-input functions along it. Five inputs? A city with many parallel four-input streets. And on and on. Applying inputs to a function in order to receive an output is only a small part of most calculations. Calculations are usually organized as algorithms, which is just to say that algorithms are descriptions of a calculation. The calculation itself is … a function! How does the calculation work? Think of it as a business. People come to your business with one or more inputs. You take the inputs and, following a carefully designed protocol, hand them out to your staff, perhaps duplicating some or doing some simple arithmetic with them to create a new number. Thus equipped with the relevant numbers, each member of staff goes off to evaluate a particular function with those numbers. (That is, the staff member goes to the appropriate street, building, floor, corridor, and door, returning with the number provided at that office.) The staff re-assembles at your roadside stand, you do some sorting out of the numbers they have returned with, again following a strict protocol. Perhaps you combine the new numbers with the ones you were originally given as inputs. In any event, you send your staff out with their new instructions—each person’s instructions consist simply of a set of inputs which they head out to evaluate and return to you. At some point, perhaps after many such cycles, perhaps after just one, you are able to combine the numbers that you’ve assembled into a single result: a number that you return to the person who came to your business in the first place. A calculation might involve just one function evaluation, or involve a chain of them that sends workers buzzing around the city and visiting other businesses that in turn activate their own staff who add to the urban tumult. The reader familiar with floors and corridors and office doors may note that the addresses are discrete. That is, office 321 has offices 320 and 322 as neighbors. Calculus is about continuous functions, so we need a way to accept, say, 321.487… as an input. There is no such office. 340 A slight modification to the procedure will produce a continuous function. It works like this: for an input of 321.487… the messenger goes to both office 321 and 322 and collects their respective outputs. Let’s imagine that they are -14.3 and 12.5 respectively. All that’s needed is a small calculation, which in this case will look like \\[-14.3 \\times (1 - 0.487...) + 12.5 \\times 0.487...\\] This is called linear interpolation and lets us construct continuous functions out of discrete data. In Blocks 2 and 5 we’ll discuss other widely used ways to do this that produce not just continuous functions but smooth functions. Understanding the difference between continuous and smooth will have to wait until we introduce a couple more calculus concepts: derivatives and limits. 3.3 Domain: input space As you know, there is a powerful way of thinking about numbers in terms of space and geometry. For instance, a single number corresponds to a point on a line: the so-called number line. A pair of inputs, say, (x, y) corresponds to a point in a plane, often called the Cartesian coordinate plane. Three numbers corresponds to a point in space, perhaps organized into (x, y, z) of a Cartesian space. There are higher-dimensional spaces, but usually special training is needed to become comfortable with them. If you are having this discomfort, you might prefer to work with the office analogy. Just for fun, here’s how you can think of a 10-dimensional space: 10 numbers, one telling you which planet, the next specifying the continent on that planet, and so on for country, state, city, street, building, floor, corridor, door. The set of inputs with which the function can be evaluated is called the domain of the function. Sometimes we describe the domain as a space, e.g. the number line, the plane, and so on. Sometimes domains including more restrictions. For instance, a particular input might have meaning only when positive, with no offices corresponding to negative values for that input. Or, an input might be restricted to be in the interval 0 to 1. Sometimes in calculus, the domain excludes an isolated point. For instance, there may be no office at the door marked 0 but the neighboring doors open into working offices. 350 3.4 Range: output space The range of a function is the set of all the outputs that can be produced. Since at this stage we’re working only with functions that return a single number as output, it’s common to describe the range as all or part of the number line. For instance, some functions only have positive outputs. Other functions’ outputs are always in the interval 0 to 1. (This is the case, for instance, when the function returns a probability as the output.) Weather forecasting by numerical process Weather forecasting by numerical process is a highly influential book, from 1922, by Lewis Fry Richardson. He envisioned a calculation for a weather forecast as a kind of function. The domain for the forecast is the latitude and longitude of a point on the globe, rather than the rectilinear organization of corridor. One fantastic illustration of the idea shows a building constructed in the form of an inside-out globe. Source At each of many points on the globe, there is a business. (You can see this most clearly in the foreground, which shows several boxes of workers.) 360 Figure 3.1: An artist’s depiction of the organization of calculations for weather forecasting by Richardson’s system. In each business there is a person who will report the current air pressure at that point on the globe, another person who reports the temperature, another reporting humidity, and so on. To compute the predicted weather for the next day, the business has a staff assigned to visit the neighboring businesses to find out the pressure, temperature, humidity, etc. Still other staffers take the collected output from the neighbors and carry out the arithmetic to translate those outputs into the forecast for tomorrow. For instance, knowing the pressure at neighboring points enables the direction of wind to be calculated, thus the humidity and temperature of air coming in to and out of the region the business handles. In today’s numerical weather prediction models, the globe is divided very finely by latitude, longitude, and altitude, and software handles both the storage of present conditions and the calculation from that of the future a few minutes later. Repeating the process using the forecast enables a prediction to be made for a few minutes after that, and so on. Some of the most important concepts in calculus relate to the process of collecting outputs from neighboring points and combining them: for instance finding the difference or the sum. To illustrate, here is the first set of equations from Richardson’s Weather forecasting … written in the notation of calculus: 370 You can hardly be expected at this point to understand the calculations described by these equations, which involve the physics of air flow, the coriolis force, etc. but it’s worth pointing out some of the notation: The equations are about the momentum of a column of air at a particular latitude (\\(\\phi\\)) and longitude. \\(M_E\\) and \\(M_N\\) are east-west and north-south components of that momentum. \\(\\partial M_E /\\partial t\\) is the rate at which the east-west momentum will change in the next small interval of time (\\(\\partial t\\)). \\(p_G\\) is the air pressure at ground level from that column of air. \\(\\partial p_G / \\partial n\\) is about the difference between air pressure in the column of air and the columns to the north and south. Calculus provides both the notation for describing the physics of climate and the means to translate this physics into arithmetic calculation. 3.5 Formulas in R You’re familiar to some extent with traditional mathematical notation for formulas. Yet in applied work, you will often need to translate such formulas into computer notation. This book is written using R, but particularly when mathematical formulas are involved, commands are similar across many computer languages, so what you learn will be applicable to any other languages such as Python or MATLAB. The first high-level computer language was FORTRAN, released in 1957. The name stands for “formula translation.” FORTRAN enabled arithmetic operations to be written in a way very nearly that of traditional notation. Until then, computer programs were written using alpha-numeric codes that were meaningless to a casual reader. We unfortunately still use the term “computer code” to refer to programs, despite 70-years progress in improving legibility. The best way to learn to implement mathematical formulas in a computer language is to read examples and practice writing them. Here are some examples: Traditional notation R notation \\(3 + 2\\) 3 + 2 \\(3 \\div 2\\) 3 / 2 \\(6 \\times 4\\) 6 * 4 \\(\\sqrt{\\strut4}\\) sqrt(4) \\(\\ln 5\\) log(5) \\(2 \\pi\\) 2 * pi \\(\\frac{1}{2} 17\\) (1 / 2) * 17 \\(17 - 5 \\div 2\\) 17 - 5 / 2 \\(\\frac{17 - 5}{\\strut 2}\\) (17 - 5) / 2 \\(3^2\\) 3^2 \\(e^{-2}\\) exp(-2) Each of these examples has been written using numbers as inputs to the mathematical operations. The syntax will be exactly the same when using an input name such as x or y or altitude, for instance (x - y) / 2. In order for that command using x and y to work, some meaning must have been previously attached to the symbols. We’ll come back to this important topic on another day. Read through the above table of examples several times. Note down any that you find at all confusing. Then cover up the right side of the table and write down the R expression for each item on the left side. Similarly, cover up the left side of the table and translate the R expression into traditional notation. Open a SANDBOX and, one at a time, write and run the R expression for each of these traditional-notation expressions. We give the numerical result for each of the traditional expressions to let you confirm that your R version is correct. \\((16 - 3)/2\\) gives result 6.5 \\(\\sqrt{\\frac{19}{3}}\\) gives 2.5166115 \\(\\cos(\\frac{2 \\pi}{3})\\) gives -0.5 \\(\\pi^3 + 2\\) gives 33.0062767 \\(\\pi^{3+2}\\) gives 306.0196848 Once you have a grasp of how to render traditional-notation formulas into R, read these few principles to help consolidate your understanding. Computer languages generally, and R in particular, involve expressions that are written in a typewriter format: one conventional character after another in a straight line. There are no superscripts or subscripts used. So, \\(\\frac{1}{3}\\) will be written 1/3. The equivalent of \\(\\sqrt{7}\\) is sqrt(7). Parentheses: When an opening parenthesis directly follows a name, as in sqrt(, it means that the named operation is to be applied to the quantity inside the parentheses. So sqrt(7) means “take the square root of 7” and log(10) means “take the (natural) logarithm of 10.” The common mathematical functions typically take only one input. We’ll stick with those for now. When an opening parenthesis does not directly follow a name, as in 6 - (2+3), the parentheses stand for grouping in exactly the same way as in traditional notation. For instance, \\((6 + 15) / 3\\) is translated as (6 + 15) / 3. Multiplication and exponentiation are often written traditionally in terms of the relative position of quantities. So \\((3 + 2)\\pi\\) means to multiply 5 times \\(\\pi\\), even though there is no multiplication sign being written. Similar, \\(\\pi^{3 + 2}\\) means to raise \\(\\pi\\) to the fifth power. There is no “exponentiation sign” used, just the positioning of \\(3+2\\) as a superscript: \\(^{3+2}\\). In R (and almost every computer language) multiplication and exponentiation must be written explicitly. The quantities \\((3 + 2)\\pi\\) and \\(\\pi^{3 + 2}\\) would be translated as (3 + 2) * pi and pi^(3+2). One additional note: All these examples can be written with a single line of code, as is true for many short formulas. Later on, we’ll encounter longer formulas that could be written on a single line but are more readable when spread over two or more consecutive lines. When your R command is not a complete sentence, the SANDBOX will display an error like this: &lt;span style=&quot;font-color: red;&quot;&gt;&lt;code&gt;Error in parse(text = x, keep.source = TRUE) : &lt;text&gt;:5:0: unexpected end of input &lt;/code&gt;&lt;/span&gt; The “unexpected end of input” is the computer’s way of saying, “You haven’t finished your sentence so I don’t know what to do.” Each of these R expressions is incomplete. Your job, which you should do in a sandbox, is to turn each into a complete expression. Sometimes you’ll have to be creative, since when a sentence is incomplete you, like the computer, don’t really know what it means to say! But each of these erroneous expressions can be fixed by adding or changing text. Open a sandbox and copy each of the items below, one at a time, into a sandbox. Press “Run code” for that item and verify that you get an error message. For the first item, the sandbox will look like this: Figure 3.2: Running an invalid command will produce an error message. Then, fix the command so you get a numerical result rather than the error message. Working through all of these will help you develop an eye and finger-memory for R commands. sin 3 ((16 - 4) + (14 + 2) / sqrt(7) pnorm(3; mean=2, sd=4) log[7] 14(3 + 7) e^2 3 + 4 x + 2 x^2 3.6 Exercises Exercise 3.1: RLUCX Consider this graph of a function \\(g(x)\\): Question A What is the domain of \\(g(x)\\)? \\(-\\infty &lt; x &lt; \\infty\\)︎✘ \\(-3 \\leq x \\leq 2\\)Correct.  \\(-4 \\leq x \\leq 4\\)︎✘ This might be called the “graphics” domain, yet the function graph doesn’t extend over that whole interval. \\(-10 \\leq g(x) \\leq 40\\)︎✘ This is the vertical extent of the graphics frame. \\(-1 \\leq g(x) \\leq 33\\)︎✘ The domain refers to the horizontal axis. Question B What is the range of \\(g(x)\\)? \\(-\\infty &lt; x &lt; \\infty\\)︎✘ The range refers output of the function. \\(x\\) is the input. \\(-3 \\leq x \\leq 2\\)︎✘ The range refers output of the function. \\(x\\) is the input. \\(-4 \\leq y \\leq 4\\)︎✘ You’re used to calling the function output \\(y\\), but that’s a bad habit. Break it! \\(-10 \\leq g(x) \\leq 40\\)︎✘ This is the vertical extent of the graphics frame. \\(-1 \\leq g(x) \\leq 33\\)Good.  Exercise 3.2: pUKm4c Refer to the data on internal combustion engine characteristics in Section 3.1. How would you describe the relationship between engine power (BHP) and RPM? Which of the pattern-book functions shows a similar relationship between input and output? Exercise 3.3: DLWSA All but two of the pattern-book functions have a domain that runs over the whole number line: \\(-\\infty &lt; x &lt; \\infty\\). Which pattern-book function has a domain that excludes zero and negative numbers as inputs? Which pattern-book function has just a single value missing from its domain? Exercise 3.4: MNCLS2 A function’s domain is the set of possible inputs to the function. A function’s range is the set of possible outputs. For each of the pattern-book functions, specify what is the range. Question A What is the range of the pattern-book exponential function? All positive outputsNice!  All negative outputs︎✘ The whole number line︎✘ A closed, finite interval of possibilities︎✘ Question B What is the range of the pattern-book sine function? All positive outputs︎✘ All negative outputs︎✘ The whole number line︎✘ A closed, finite interval of possibilitiesExcellent! Yes. The output of pattern-book sinusoid functions is always in the interval from -1 to 1, inclusive Question C What is the range of the pattern-book logarithm function? All positive outputs︎✘ All non-negative outputs︎✘ All negative outputs︎✘ The whole number lineCorrect.  A closed, finite interval of possibilities︎✘ Question D What is the range of the pattern-book square function? All positive outputs︎✘ Close. Zero is one of the possible outputs. We can say, equivalently, that the range is all the positive outputs plus 0 or all the non-negative outputs. All non-negative outputsNice!  All negative outputs︎✘ The whole number line︎✘ A closed, finite interval of possibilities︎✘ Question E What is the range of the pattern-book proportional function? All positive outputs︎✘ All negative outputs︎✘ The whole number lineCorrect.  A closed, finite interval of possibilities︎✘ The range extends from \\(-\\infty\\) to \\(\\infty\\). Question F What is the range of the pattern-book sigmoid function? All positive outputs︎✘ All negative outputs︎✘ The whole number line︎✘ A closed, finite interval of possibilitiesCorrect. Right. The pattern-book sigmoid function has an output that is always in the interval \\(0 \\leq \\pnorm(x) \\leq 1 .\\) Exercise 3.5: BXCA4 Open a SANDBOX. (Just click on that link, although you may eventually be given other ways to open a sandbox.) When you see a breakout box like this, it means that we’re providing some computer code that you can paste into a sandbox and run. For this exercise, that code is x &lt;- 2 sin(x)*sqrt(x) Paste those two lines into the sandbox and press “Run code.” Verify that you get this as a result: [1] 1.285941 Each line that you pasted in the sandbox is a command. The first command gives a value to \\(x\\). The second command uses that value for \\(x\\) to calculate a function output. The function is \\(g(x)\\equiv \\sin(x) \\times \\sqrt{\\strut x}\\). Why not simplify the above code to the single line sin(2)*sqrt(2)? This would produce the same output but would introduce an ambiguity to the human reader. We want to make it clear to the reader (and the computer) that whatever \\(x\\) might be, it should be used as the input to both the \\(\\sin()\\) and the \\(\\sqrt{\\strut\\ \\ \\ }\\) functions. In the following questions, numbers have been rounded to two or three significant digits. Select the answer closest to the computer output. Question A Change \\(x\\) to 1. What’s the output of \\(\\sin(x) \\ \\sqrt{\\strut x}\\)     -1.51︎✘        0.244︎✘        0.84\\(\\heartsuit\\ \\)       0.99︎✘        2.14︎✘        NaN︎✘ Question B Change \\(x\\) to 3. What’s the output of \\(\\sin(x) \\ \\sqrt{\\strut x}\\)     -1.51︎✘        0.244\\(\\heartsuit\\ \\)       0.84︎✘        0.99︎✘        2.14︎✘        NaN︎✘ Question C Change \\(x\\) to \\(-5\\). What’s the output of \\(\\sin(x) \\ \\sqrt{\\strut x}\\) -1.51︎✘ 0.244︎✘ 0.84︎✘ 0.99︎✘ 2.14︎✘ NaNGood. This stands for Not-a-Number, which is what you get when you calculate the square root of a negative input. In the sandbox, change the function to be \\(\\sqrt{\\strut\\pnorm(x)}\\). Question D For \\(x=2\\), what’s the output of \\(\\sqrt{\\strut\\pnorm(x)}\\)?     -1.51︎✘        0.244︎✘        0.84︎✘        0.99\\(\\heartsuit\\ \\)       2.14︎✘        NaN︎✘ Original word: “ramify”↩︎ "],["fun-describing.html", "Chapter 4 Describing functions 4.1 Graphing a function 4.2 Tables of inputs and outputs 4.3 Word descriptions 4.4 Computer function names 4.5 Mathematical notation 4.6 Exercises", " Chapter 4 Describing functions We will need to communicate about functions to your fellow humans and to computers. Important modes of communication include: 400 Graphs of functions that show their “shape” Tables of inputs and outputs Word descriptions Computer function name Mathematical notation In this chapter, we’ll illustrate these five different modes using the pattern-book functions. It’s important to become proficient at all five. 4.1 Graphing a function Since we’ve already introduced the pattern-book functions, this is a good time to show you how to draw a graph of them. After this short introduction, we’ll discuss graphics more generally and look at graphics of functions that have two inputs. All the pattern-book functions have just a single input. You can draw graphs of single-input functions using the slice_plot() R/mosaic operator. You need to specify two pieces of information to slice_plot(): Which function to graph. In R/mosaic, You state this with what’s called a tilde expression. A couple of examples will suffice for the moment. When the function has a name, like exp() or log() or sin(), the tilde expression looks like exp(x) ~ x. On the left side of the tilde you put the name of the function you want to graph with the input name in parentheses. You can choose any input name you like: here we are using x, but we are not limited to using x or any other letter. Sometimes we even use named inputs (e.g. exp(time)). On the right side of the tilde, place the input name again. We’ll explain why the name appears in two places later. When the function is being written as a formula, for instance 1/z or t^2, put the formula on the left side of the tilde and the input name on the right side, like 1/z ~ z or t^2 ~ t. The graphics domain. As you know, the domain of a function is the collection of all possible legitimate inputs. For most of the pattern-book functions, the domain is \\(-\\infty &lt; x &lt; \\infty\\). As you might expect, it’s impractical to have a graphical axis that is infinitely long. So you have to choose some finite interval of the function domain to use. This finite interval is called the “graphics domain.” You specify the domain with a statement like domain(x = c(-5,5)), which is setting the graphics domain to \\(-5 \\leq x \\leq 5\\). Note that the input name used in domain() must match the input name you selected in the tilde expression. R uses the c() function to collect together the two numbers that define the left and right borders of the domain. In traditional notation, we write an interval in formats like \\((-5, 5)\\) or \\([-5, 5]\\) or \\(-5 \\leq x \\leq 5\\). None of these will work with the R language. For instance, the fragment (-5, 5) is not a complete expression in R; the opening parenthesis needs to be preceded by a function name. The c() function was invented for this purpose. It can combine any number of arguments, but two is enough for our purpose here: to specify an interval on the number line.4 The tilde expression and the graphics domain specifier are the two arguments to slice_plot(). All of these are correct commands for drawing a graph: slice_plot(sin(t) ~ t, domain(t=c(-5,5))) slice_plot(exp(x) ~ x, domain(x=c(-3,2))) slice_plot(log(z) ~ z, domain(z=c(-0.5, 10))) slice_plot(t^2 ~ t, domain(t=c(-2, 2))) 4.2 Tables of inputs and outputs Another way of describing a function is to give a table of inputs and outputs. Like graphics, a table can only show some of the possible inputs. input output -1.00 0.3678794 -0.75 0.4723666 -0.50 0.6065307 -0.25 0.7788008 0.00 1.0000000 0.25 1.2840254 0.50 1.6487213 Before modern computing, tables were one of the primary means to describe functions. People working with calculus needed a reference collection of books containing tables for the functions they used. 420 With computers, we have better and faster ways to get the output of a function from the input. Still, modelers often use recorded data to construct functions. Tables are perhaps the most widely used method for storing and accessing data, although electronic spreadsheets are used today instead of printed tables. Even today, a table can be a nice way to describe a function when we are interested in the output from only a handful of the possible inputs. Conceptually, it’s helpful to keep in mind that every pattern-book function is just a way of organizing information that could have been stored in a table. You will not have to generate tabular descriptions of functions to follow this book. It’s much more convient to implement the function in software so that the output can easily be displayed for any given inputs. On the other hand, in this book we’ll often use data in tabular form to create a modeling function. There’s little point in introducing this until you have some additional calculus concepts, so be patient. 4.3 Word descriptions Knowing and correctly using a handful of phrases goes a long way in being able to communicate with other people about functions with a single input. Often, the words make sense in everyday speech (“steep”, “growing”, “decaying”, “goes up”, “goes down”, “flat”). 430 Sometimes the words are used in everyday speech but the casual person isn’t sure exactly what they mean. For instance, you will often hear the phrase “growing exponentially.” The graph of the exponential function illustrates exactly this sort of growth: flat for small \\(x\\) and growing steadily steeper and steeper as \\(x\\) increases. Still other words are best understood by those who learn calculus. “Concave up,” “concave down”, “approaching 0 asymptotically,” “continuous”, “discontinuous”, “smooth”, “having a minimum at …,” “having a minimum of …”, “approaching \\(\\infty\\) asymptotically,” “having a vertical asymptote.” The next short sections describe six simple shape concepts: concavity, continuity, monotonicity, periodicity, asymptotes, and local extrema. I’ll illustrate these concepts using three pattern-book functions graphed in Figure 4.1. 431 Figure 4.1: Three of the pattern-book functions: (a) exponential, (b) sinusoid, (c) power-law \\(x^{-1}\\). 4.3.1 Concavity The slope of a function at a given input tells how fast the function output is increasing or decreasing as the input changes slightly. Concavity is not directly about how the function output changes, but about how the function’s slope changes. For instance, a function might be growing slowly in some region of the domain and then gradually shift to larger growth in an adjacent region. Or, a function might be decaying steeply and then gradually shift to a slower decay. Both of these are instances of positive concavity. The opposite pattern of change in slope is called negative concavity. If the slope doesn’t change at all—only straight-line functions are this way— the concavity is zero. Concavity has a very clear appearance in a function graph. If a function is positive concave in a region, the graph looks like a smile or cup. Negative concavity looks like a frown. Zero concavity is a straight line. 432 Referring to the three function examples in Figure 4.1, we’ll use the traditional terms concave up and concave down to refer to positive and negative concavity respectively. The exponential is concave up everywhere in its domain. The sinusoid alternates back and forth between concave up and concave down. This particular power law \\(x^{-1}\\) is concave up for \\(x &gt; 0\\) and concave down for \\(x &lt; 0\\). When a function switches between positive concavity and negative concavity, as does the sinusoid as well as the gaussian and sigmoid functions, there is an input value where the switch occurs and the function has zero concavity. (Continuous functions that pass from negative to positive or vice versa must always cross zero.) Such in-between points of zero concavity are called inflection points. A function can have zero, one, or many inflection points. For instance, the sinusoid has inflection points at \\(x = \\ldots, -\\pi, 0, \\pi, 2\\pi, \\ldots\\), the cubic power function \\(f(x)\\equiv x^3\\) has one, and the exponential has none. Figure 4.2: A diagram showing a cubic function which is concave up until a point of inflection and concave down thereafter. [Source: Maj. Austin Davis] “Inflection point” appears in news stories, so it is important to know what it means in context. The mathematical definition is about the change in the direction of curvature of a graph. In business, however, it generally means something less esoteric, “a time of significant change in a situation” or “a turning point.”5 The business sense effectively means that the function—say profits as a function of time, or unemployment as a function of time—has a non-zero concavity, up or down. It’s about the existence of concavity rather than about the change in the sign of concavity. One of the benefits of learning calculus is to gain a way to think about the previous paragraph that’s systematic, so it’s always easy to know whether you are talking about the slope of a function or the change in slope of a function. 4.3.2 Continuity A function is continuous if you can trace out the graph of the function without lifting pencil from the page. A function is continuous on an interval (a,b) if you can trace the function over that whole interval. All of the pattern-book functions are continuous over any interval in their domain except for power-law functions with negative exponents. (This includes the reciprocal since it is a power-law with a negative exponent: \\(1/x = x^{-1}\\).) Those exceptions are not defined at \\(x=0\\). To illustrate, consider the power-law function graphed in Figure 4.1. On any interval (a,b) that does not include 0, the function is continuous. For inputs \\(x &lt; 0\\), the function is negative. For inputs \\(0 &lt; x\\), the function is positive. So, on an interval that includes \\(x=0\\) the function jumps discontinuously from negative to positive. 433 4.3.3 Monotonicity A function is monotonic on a domain when the sign of the slope never changes on that domain. Monotonic functions either steadily increase in value or, alternatively, steadily decrease in value. Another way of thinking about monotonicity is to consider the order of inputs and outputs compared to a number line. If a function is monotonically increasing then it will preserve the order of inputs along the number line when it maps inputs to outputs, whereas a monotonically decreasing function will reverse the order. For instance, if the input \\(x\\) comes before an input \\(y\\) (i.e., \\(x&lt;y\\)), then \\(f(x)&lt;f(y)\\) for monotonically increasing functions (the order is preserved), but \\(f(y)&lt;f(x)\\) for monotonically decreasing functions (the order of outputs is reversed). Of the pattern-book functions in Figure 4.1: both the exponential and the logarithm function are monotonic: the exponential grows monotonically as does the logarithm. The sinusoid is not monotonic over any domain longer than half a cycle: the function switchs between positive slope and negative slope in different parts of the cycle. 434 4.3.4 Periodicity A phenomenon is periodic if it repeats a pattern over and over again. The pattern that is repeated is called a cycle; the periodic function as a whole is one cycle placed next to the previous one and so forth. The day-night cycle is an example of a periodic phenomenon, as is the march of the seasons. The period is the duration of one complete cycle; the period of the day-night cycle is 24 hours, the period of the seasonal progression is 1 year. Real-world periodic phenomena often show some slight variation from one cycle to the next. Of the pattern-book functions, only the sinusoid is periodic. And it is exactly periodic, repeating exactly the same cycle over and over again. The period—that is, the length of an input interval that contains exactly one cycle—has a value of \\(2\\pi\\) for the pattern-book sinusoid. When used to model a periodic phenomenon, the model function needs to be tailored to match the period of the phenomena. The idea of representing with sinusoids phenomena that are almost but not exactly periodic, for instance a communications signal or a vibration, is fundamental to many areas of physics and engineering. 435 4.3.5 Asymptotic behavior Asymptotic refers to two possible situations depending on whether the input or output is being considered: When the input to a function gets bigger and bigger in size, going to \\(\\infty\\) or \\(-\\infty\\). If, as the input changes in this way the output gets closer and closer to a specific value, the function is said to have a horizontal asymptote of that value. An example in Figure 4.1 is the exponential function. As \\(x \\rightarrow -\\infty\\), that is, as \\(x\\) goes more and more to the left of the domain, the output tends asymptotically to zero. When the output of a function gets bigger and bigger in size, going to \\(\\infty\\) or \\(-\\infty\\) without the input doing likewise. The visual appearance on a graph is like a sky-rocket: the output changes tremendously fast even though the input changes only a little. The vertical line that the skyrocket approaches is called a vertical asymptote. The power-law function \\(x^{-1}\\) has a vertical asymptote at \\(x=0\\). If you were to consider inputs closer and closer to \\(x=0\\), the outputs would grow larger and larger is magnitude, tending toward \\(\\infty\\) or \\(-\\infty\\). Several of the pattern-book functions have horizontal or vertical asymptotes or both. For instance, the function \\(x^{-1}\\) has a horizontal asymptote of zero for both \\(x \\rightarrow \\infty\\) and \\(x \\rightarrow -\\infty\\). 436 The sinusoid has neither a vertical nor a horizontal asymptote. As input \\(x\\) increases either to \\(-\\infty\\) or \\(\\infty\\), the output of the sinusoid continues to oscillate, never settling down to a single value. And, of course, the output of the sinusoid is everywhere \\(-1 \\leq \\sin(x) \\leq 1\\), so there is no possibility for a vertical asymptote. 4.3.6 Locally extreme points Many continous functions have a region of the input domain where the output is gradually growing, then reaches a peak, then gradually diminishes. This is called a local maximum. “Maximum” because the output reaches a peak at a particular input, “local” because in the neighborhood of the peak the function output is smaller than at the peak. Likewise, functions can have a local minimum: the bottom of a bowl rather than the top of a peak. Of the three pattern-book functions in Figure 4.1, only the sinusoid has a local maximum, and, being periodic, it repeats that every cycle. The sinusoid similarly has a local minimum in every cycle.. Many modeling applications involve finding an input where the function output is maximized. Such an input is called an argmax. “Argument” is a synonym for “input” in mathematical and computer functions, so “argmax” refers to the input at which the function reaches a maximum output. For instance, businesses attempt to set prices to maximize profit. At too low a price, sales are good but income is low. At too high a price, sales are too low to bring in much income. There’s a sweet spot in the middle. 437 Other modeling applications involve finding an argmin, the input for which the output is minimized. For instance, aircraft have a speed at which fuel consumption is at a minimum for the distance travelled. All other things being equal, it’s best to operate at this speed. The process of finding an argmin or an argmax is called optimization. And since maxima and minima are very much the same mathematically, collectively they are called extrema. Any function that has an extremum cannot possibly be monotonic, since the growth is positive on one side of the extremum and negative on the other side. 4.4 Computer function names As you might expect, computer programmers and language developers have written software implementing several of the pattern-book functions: exp(), log(), sin(), dnorm(), and pnorm(). For these functions, the name tells everying, so far as the computer is concerned, that is needed to calculate the output from any given input. 440 Computer notation for the power-law and proportional functions is different because the body of these functions is so short. So instead of using parentheses to apply a named function, invoking the power-law or proportional functions is done using a syntax like x^p or x or z^4.6 When a function like \\(\\sqrt[3]{x}\\) is written as \\(x^{1/3}\\) make sure to include the exponent in grouping parentheses: x^(1/3). Similarly, later in the course you will encounter power-law functions where the exponent is written as a formula. Particularly common will be power-law functions written \\(x^{n-1}\\) or \\(x^{n+1}\\). In translating this to computer notation, make sure to put the formula within grouping parentheses, for instance x^(n-1) or x^(n+1). 4.5 Mathematical notation You have grown up with traditional mathematical notation and are likely familiar with the notation for several of the pattern-book functions: \\(\\ln x\\), \\(\\sin x\\), \\(e^x\\), \\(x^p\\) (as in \\(x^2\\) where \\(p=2\\) or \\(\\sqrt{x}\\) where \\(p=1/2\\)). 450 Traditional notation mixes up several things that computer notation sensibly keeps separate. From the computer programmer’s point of view, traditional notation is idiosyncratic rather than systematic. If you are interested in these things, three concepts from computing may help you appreciate the the differences: Functional notation In computing, the notation in which a function name is followed by parentheses7 with the inputs inside the parentheses is called “functional notation.” For instance, exp(x) is functional notation, since the input x is between parentheses. Traditional mathematical notation sometimes leaves out the parentheses, as in \\(\\sin \\frac{\\pi}{2}\\) or \\(\\ln 10\\). But in this course I always include the parentheses, which are abolutely required in the computer notation, in the traditional notation as well, i.e. \\(\\sin\\left(\\frac{\\pi}{2}\\right)\\). Infix notation For functions with two inputs, computing languages often support a different arrangement of the function name and the inputs where the name comes inbetween the arguments. You’ve seen this “infix” notation in parts of traditional arithmetic notation, for instance, \\(3 + 5\\) or \\(8/2\\). In R, power-law functions are often written in infix notation, e.g. 3^2 or x^3. When you see a traditional notation like \\(e^x\\), you will be tempted at first to write this as e^x. But in R, the exponential function is written in functional notation: exp(x). Markup notation You are undoubtedly familar with word processing and, particularly, a style of word processing called What-you-see-is-what-you-get (WYSIWYG). In WYSIWYG, you can enter plain text just using the keyboard, but if you want to make something boldface or italics, you use the mouse to select the text involved and select a style from a menu. Typically, WYSIWYG mathematical content involves a similar mouse-based process. In contrast, in mainstream computer languages, the mouse is not needed at all. The computer commands are constructed from plain, linear sequences of letters and other characters. Traditional mathematical notation includes features such as superscripts and special symbols that are easily written out with pencil in hand. Often this notation is beautiful and aesthetically cherished by mathematicians. But computer commands in most computer languages are straight sequences of characters using function or infix notation.8 4.6 Exercises Exercise 4.1: H2eu2 Answer these questions about the pattern-book functions. You can refer to the graphs in Figures 2.2 through 2.4. Question A Which of these best describes the concavity of the gaussian function? It’s not concave.︎✘ If it curves, it’s either concave up or down. It’s concave down.︎✘ In some places, but not in others. It’s concave down in the center and concave up on both flanks.Nice!  It’s concave down on the left and concave up on the right︎✘ Look again Question B Which of these best describes the concavity of the sigmoid function? It’s not concave.︎✘ If it curves, it’s either concave up or down. It’s concave down.︎✘ In some places, but not in others. It’s concave down on the left and concave up on the right.︎✘ Look again It’s concave up on the left and concave down on the right.Excellent!  Question C Which of these best describes the concavity of the second-order monomial \\(m_2(x) \\equiv x^2\\)? It’s not concave.︎✘ If it curves, it’s either concave up or down. It’s concave down.︎✘ Is it a smile or a frown? It’s concave down on the left and concave up on the right.︎✘ Look again It’s concave up everywhere.Correct.  Exercise 4.2: PYKG5 In this activity, you will be examining the various pattern-book functions to look for two different features: Slope: whether the graph has a slope that is consistently positive, negative, both, or neither, and Concavity: whether the function being graphed is concave up, concave down, neither, or both (i.e., concave up in some regions of the domain and down for others). Copy and paste the R/mosaic command below in a SANDBOX to draw a function graph. Remember to press “Run code.” slice_plot(exp(x) ~ x, domain(x=c(-3, 3))) To modify the command to draw another function, replace the exp(x) with another formula, for instance 1/x. Make a list of the pattern-book functions. For each function in the list, write down the R expression for the function, say whether the function has a consistently positive or negative slope, whether it is consistently concave up or down, and if the value of the function appears to be reaching a horizontal asymptote at zero for very negative \\(x\\), for very positive \\(x\\), for both, or neither. We’ll show you the answers for the exponential and sinusoid functions. You’ll have to modify the computer command to graph the other pattern-book functions. function name R formula slope concavity horiz. asymptote exponential exp(x) positive concave up \\(x \\rightarrow -\\infty\\) logarithm sinusoid sin(x) both both neither square proportional constant reciprocal gaussian sigmoid Some other computer languages, like MATLAB and Python, do allow use of the concise notation [-5, 5]. R doesn’t, so you will see an awful lot of the c() function.↩︎ Google dictionary, provided by Oxford Languages↩︎ If you insist on using a named function for power-law and proportional functions, there is `^`() and I().↩︎ Or sometimes square braces or curly braces or another token, depending on the language.↩︎ Some computer languages use notation where the name of the function is contained inside the parentheses as in (+ 2 3).↩︎ "],["fun-notation.html", "Chapter 5 Notation for functions 5.1 A notation for computing 5.2 Words for using functions 5.3 Formulas and algorithms 5.4 Algorithms without formulas 5.5 Computer notation 5.6 CalcZ naming conventions 5.7 Functions in R 5.8 \\(=\\), \\(\\equiv\\), \\(\\rightarrow\\), &lt;- 5.9 Exercises", " Chapter 5 Notation for functions Part of the difficulty of mathematics for many people is making sense of the nomenclature and notation. What you were taught in high school is a highly idiomatic system that can be mastered only with extensive experience. Mathematicians are undoubtedly skilled in logic, but mathematics itself has an ancient history which has littered the language with synonyms, near synonyms, inconsistencies, diacritical marks, and letters in unfamiliar alphabets. 500 To illustrate the cultural admiration for abstraction in mathematics, consider this famous poem, The Jabberwocky, by a University of Oxford mathematician, Charles Lutwidge Dodgson (1832-1898): ’Twas brillig, and the slithy toves        Did gyre and gimble in the wabe: All mimsy were the borogoves,        And the mome raths outgrabe. Here are some words commonly encountered in traditional mathematics notation. equation, formula, function, variable, unknown, root And here are a few mathematical sentences. \\(y = x\\) \\(y = \\sqrt{x}\\) \\(y^2 = x\\) \\(x^2 = x\\) \\(x = \\sqrt{x}\\) All five sentences are equations. That’s easy, because they each have an equal sign between the two sides. Which are formulas? Which are functions? You’re used to calling \\(x\\) and \\(y\\) variables. When do they become unknowns? Sentence (v) involves roots (as in “square root”). But sentence (v) says the same thing as (iv) which is about squares rather than roots.510 5.1 A notation for computing The traditional notation is practically useless for computing. A programmer has to have a deep understanding of what the notation is intended to mean in any given circumstance before she can construct a computer expression that will carry that same meaning in the computer’s work. To illustrate, consider these statements in traditional math notation, each of which has a sensible meaning. \\[y = x\\\\ y = \\sqrt{x}\\\\ y^2 = 3\\\\ y = \\sqrt{3}\\\\ y - x = 0\\\\ 0 = (x+3)(x-2)\\] Imagine translating these statements into R, fixing things a little by inserting the required * in (x+3)*(x-2), and using sqrt() instead of \\(\\sqrt{\\strut\\ }\\). 520 y = x y = sqrt(x) y^2 = 3 y = sqrt(3) y - x = 0 0 = (x+3) * (x-2) Running these statements in R (for instance, by copying them to a SANDBOX) will generate an error. Even if you copy and run the statements individually, one at a time, into the sandbox, you’ll get an error for all but one of the statements. Before reading on, see if you can figure out, just by reading the R statements, which one is valid. For some of the statements, the left-hand side of &lt;- is not a valid name in R (0 and y^2 and y-x). For others, the name x is being used before any value has been assigned to it. One of the reasons we use &lt;- for assignment in R, rather than = (which, technically, is allowed) is to remind us that assignment is different from equality. The student who knows how to make sense of math notation will find this not of much help in writing computer notation. It’s like a well educated foreigner trying to make sense of how some of these sentences are meaningful and others not. “Chair a meeting,” but not “seat a meeting.” “Seat a guest,” but not “chair a guest.” “I’m bushed,” but not “I’m treed.” “Tree a cat,” but not “bush a cat.” “Table a motion,” but not “desk a motion.” “Bench a player,” but not “couch a player.” “Couch a meaning” but not “bench a meaning.” In this book, we’re going to use a mathematical notation that corresponds to a usable computer notation. The first step is to stop using \\(=\\) to mean so many different things. 530 5.2 Words for using functions Throughout this course, I use the words inputs and output to refer to what is handed off to a function and what is received back as the result. But “handed off” is a metaphor and not a clear naming of what we mean when we use a function. This section simply gives some vocabulary to describe various aspects of using functions. The concept of functions is so fundamental in mathematics and computing, that there are many synonyms for each aspect. It helps to be aware of these synonyms since different people will write about functions in different—but equivalent!—ways. 540 In everyday speech, an “argument” is a discussion between people with differing views. But in computing, argument means something else entirely: it is a synonym for “input to a function.” It’s good to have a concrete image in mind, so I’ll suggest thinking of a computer printer as an analogy for a function. A computer printer takes several different kinds of input: electricity, paper, ink or toner, instructions transmitted via cable or wireless connection. Each of these inputs arrives at the printer through a particular interface: the electrical supply cord, a tray for holding paper, a tank or cartridge for ink, a radio receiver. These interfaces are the different inputs—or, to use the other word, arguments—of the printer. Common sense tells you that you shouldn’t put toner in the paper tray, or connect the electrical supply cord to the ink tank. You have to provide the right kind of stuff to each input interface in order to get the anticipated output from the printer. Our pattern-book functions all have a single input. With such functions it’s appropriate to speak of “the input to” or “the argument of” the function. In general, the functions we will construct for modeling purposes with have multiple inputs or arguments. For instance, the function \\(g(x, y) \\equiv e^x \\sin(y)\\) has both an “x-input” and a “y-input”. You can just as well say “the x-argument of g()” or the “y-argument of g(),” or even the “first argument of g()” and the “second argument of g().” Whether you use the preposition “of” or “to” is a matter of personal style; either will do. The act of employing a function to produce the output that corresponds to a given set of inputs is much like “printing a file.” Of course, the word “printing” is not the right choice for mathematical or computational functions. Instead, there are several equivalent phrases in common use: \"Apply a function to arguments. “Invoke a function.” “Evaluate a function.” “Run a function.” In (ii) and (iv), there is an implicit “on its arguments.” But any application/evaluation/running of a function necessarily involves giving specific values for the inputs. The difference between “a function” and “applying a function” is much the same as the difference between a printer and “printing a document,” or a screwdriver and “driving (or extracting) a screw, or, for wizard-world fans, the difference between a”spell\" and the act of “casting a spell.” In R/mosaic, the application of a modeling function like g() (defined in an earlier paragraph) to its two arguments looks like g(5, pi) with the two arguments separated by a comma. It might also look like g(z, pi), or even g(x=z, y=pi) or g(y=pi, x=z) where the use of the argument names save us the trouble of remembering which argument came first in the definition. 550 When applying a function of one argument, refrain from using the argument name. It’s unnecessary since you can hardly get the order of arguments wrong and, depending on who wrote the software for the function, they might not have used x as the name of the argument. It’s another matter when you are defining a function. For instance, \\[g(x, y) \\equiv e^x \\sin(y)\\] does not mean “apply \\(g()\\) to the arguments \\(x\\) and \\(y\\).” Instead, it means, “I’m setting up \\(g()\\) as a function, a kind of promise in the future that whenever you write \\(g(3, \\pi)\\) or something similar, the defined function will be applied to those arguments. But for now, you don’t need to do any arithmetic or other calculation, just remember that you’ve made a promise named \\(g()\\).” In R/mosaic, using a tilde-expression signals that you are asking for the same kind of promise to do something when the time for it comes. A 5.3 Formulas and algorithms In high-school math, you got used to seeing formulas like \\(3x + 2\\) or \\(x^2 \\sin(y)\\). So it will likely be natural to you to think of defining mathematical functions in R with tilde expressions like 3*x + 2 ~ x or x^2 * sin(y) ~ x &amp; y. But formulas are hardly the only way to define a function. Functions can also be defined using another kind of computation of the sort not typically covered in high-school math: an iterative process, a branching process, a neural network, and so on. These processes are usually expressed using a computer programming language and so they will be unfamiliar to many students. The idea of “algorithm” generalizes that of formulas. You will be using many mathematical computations that do not involve evaluating formulas but instead are written in terms of iteration, branching, and searching. A computer programming course is a good place to learn about these concepts but, for now, what’s important is that you know that much of the work going on behind the scenes in a computation is “algorithmic” rather than based on formulas. A starter definition is: An algorithm is a set of instructions for performing a computation. High-school math typically involves presenting an algorithm as a formula. You learned, maybe in middle school, how to follow the arithmetic steps involved in algorithms described as formulas. You also have likely used a calculator to perform some of the arithmetic or to evaluate functions such as \\(\\sin()\\) and \\(\\ln()\\) and \\(\\sqrt{\\strut}\\) for which you don’t know how to evaluate using simple arithmetic. The calculator is implementing an algorithm with which its been programmed to enable the calculation of \\(\\sin()\\) and \\(\\ln()\\) and such. A slightly more detailed definition of “algorithm” highlights that algorithms are written in terms of other, simpler algorithms. An algorithm is a set of instructions for performing a computation written in terms of other algorithms that we already know how to perform. For our purposes, the “algorithms that we already know how to perform” will be taken to be arithmetic—addition, subtraction, multiplication, division—as well as the evaluation of the pattern-book functions. Admittedly, people cannot compute logarithms as fluently as they can add numbers, but you already have the R implementations of the basic modeling functions: exp(), log(), sin(), power-law, dnorm(), and pnorm(). The vast majority of functions you will see in this book (and in mathematical modeling in general) can be constructed out of basic arithmetic and the application of the pattern-book functions. 560 5.4 Algorithms without formulas Many functions are described by algorithms that use concepts common in computer programming but unknown to traditional mathematical notation. Some of these have names like iteration or branching and many refer to stored lists of fixed numbers (like the office workers in the street, building, floor, corridor, door image of a function). We’ll deal with some of these things later, but for now … We are going to use the word algorithm to name the kind of expression to the right of \\(\\equiv\\) in a function definition. A formula is a specific kind of algorithm generally written in traditional math notation. Algorithms, including the ones that are formulas, are written in terms of a set of symbols that stand for inputs. For instance, in \\(mx + b\\), the \\(x\\), \\(m\\), and \\(b\\) are the names we give to the quantities being used in the calculation. The notation we are using for function definition lists some of these names in two places, and others in only one place. Again, look at \\[g(x) \\equiv m x + b\\] The \\(x\\) appears both in the algorithm and the list of input name \\((x)\\) to the left of \\(\\equiv\\). The \\(m\\) and \\(b\\) are different; they appear only in the algorithm. The word for such quantities in mathematics is parameter. Eventually, when the algorithm is followed, we’re going to have to put in specific numerical values in place of each parameter. 570 Where will these parameter values come from? This is a subject on which mathematical notation is silent. You have to figure it out from context and experience. This is potentially very confusing, especially when a human is not around to sort things out. 5.5 Computer notation The notation used in computer programming lets us be explicit about which symbols refer to function inputs and which to parameters of the function. Depending on the computer language things can be handled in one way or another. (For experienced computer programmers: This is the issue of scope and can be complex in its own right.) 580 In the software used in CalcZ (R/mosaic, which is the R language augmented with the mosaic package of extensions), we will take a simple-to-use approach. It works like this: All modeling functions we construct with R/mosaic will list parameters formally as arguments to the function. It is as if we wrote in traditional notation \\[g(x, m, b) \\equiv m x + b\\] There is also a way to give default numerical values to parameters so that you can write \\(g(3.5)\\) and the computer will know where to find the parameter values. In writing about formulas using math notation, we’ll extend the traditional notation to write, for instance, \\(g(x, m=2, b=3) \\equiv m x + b\\). In R/mosaic, we would construct a mathematical function like \\(g()\\) using the makeFun() function: g &lt;- makeFun(m*x + b ~ x, m=2, b=3) You could also write g &lt;- makeFun(m*x + b ~ x) but this notation means that you will have to give specific numerical values for the m and b inputs whenever you evaluate g(). There won’t be any default values for the “parameters-as-inputs” m and b. 590 5.6 CalcZ naming conventions We’re going to be using and creating a lot of functions in CalcZ. Some of these functions already have proper names, usually written using short sequences of letters: for instance the pattern-book functions \\(\\sin()\\), \\(\\ln()\\), \\(\\exp()\\). 600 Other functions will be needed just for a sentence or a paragraph or a section, perhaps being used in an example or to lay out the steps of an algorithm. In natural languages such as English, we often use pronouns for such purposes: she, he, it, they, we, I, …. We also will use pronouns for identifying functions. Our policy is this: A pronoun for a function will be usually named \\(f()\\) or \\(g()\\) or \\(h()\\) or the corresponding upper-case letters \\(F()\\), \\(G()\\), or \\(H()\\). The particular choice of letter f, g, or h has no significance whatsoever. It is just a way to give an unambiguous handle for a function that we are going to be using for a little while. On occasion, we will use subscripts or superscripts on these pronoun letters, for instance \\(f_1()\\) or \\(g^\\star()\\). This is a way to give us many more possible pronouns when we need them. Perhaps this is analogous to words like “sister,” “parent,” “husband,” “cousin,” etc. that allow us to refer, without a proper name, to a specific person. On other occasions, where a function relates to a specific quantity such as position or velocity, we will use the names \\(x()\\), \\(y()\\), \\(z()\\), \\(u()\\), \\(v()\\), \\(w()\\), and such. These letters are, of course, the same ones we frequently use to name the inputs to functions. How do you know whether the letter is meant to refer to an input rather than a function? The parentheses provide the clue: \\(x()\\) is a function name, \\(x\\) is an input name. 610 It can become tedious to give a name to every function, even if it’s not being used again. Consider this sentence as an example: “The functions \\(g(x) \\equiv \\sqrt{\\strut x}\\) and \\(h(x) \\equiv x^3\\) are examples of power-law functions.” Long and awkward. So we’ll feel free to write instead, “\\(\\sqrt{\\strut x}\\) and \\(x^3\\) are examples of power-law functions.” Without the formality provided by “\\(g(x) \\equiv\\)” it can be hard to know whether \\(\\sqrt{\\strut x}\\) means “the square-root function” or \"take the square root of a specific number \\(x\\). The convention we will use is based on the name used in the expression. When standard argument names from the end of the alphabet are being used with a subscript (e.g. \\(x_0\\)) or with a special symbol used in a superscript (e.g. \\(t^\\star\\)), we intend the expression to be a function. However, when we want to apply a function to specific values for inputs we will write in any of the following styles: \\[f(x^\\star) \\ \\ \\text{or}\\ \\ \\sqrt{\\strut x^\\star}\\ \\ \\text{or}\\ \\ \\sqrt{\\strut x=3}\\ \\ \\text{or}\\ \\ \\left.\\sqrt{\\strut x}\\right|_{x=3}\\ \\ \\text{or}\\ \\ \\left.g(x)\\strut \\right|_{x=3}\\] One of the important techniques of calculus is to take something we often think of as a number and turn it into a function whose output is a number. It will take you time to get used to the calculus notation and to be able to tell at a glance whether something is a function or a number. 620 Here’s an illustration that will only make sense to those who have already studied some calculus: \\[\\int_0^3\\!\\! f(t) dt\\ \\ \\text{is a number, but }\\int_0^x\\!\\! f(t) dt \\ \\ \\text{is a function.}\\ \\ \\] In high-school math notation, it can be hard to tell if an expression is intended to be a function or a number. Careful attention to the CalcZ conventions will make it easier to figure whether an expression resolves to a function or a number. When you first read a mathematical expression, a good first question to ask is, “What kind of thing is this? A function? A number?” It is essential that you can apply these conventions reflexively. Being able to say what kind of thing a symbol stands for is a key to understanding what a mathematical expression means. 5.7 Functions in R Any name in the R language can refer to any sort of object. We will use the CalcZ naming conventions in our use of R, so that the ability you develop to read math notation should help reading R and vice versa. 630 R/mosaic provides additional clues to distinguish between numbers and functions. Almost all the time we will create a function using makeFun(). So when you see an R expression starting as name &lt;- makeFun(tilde expression) you know for sure the name refers to a function. As we get deeper into calculus, you will meet additional R operators that generate functions. We’ll introduce these in good time, but for someone reviewing the course, these include D(), antiD(), compose() and iterate(). Some readers may have encountered R previously in a statistics or data science course. Those readers will be wondering what is the purpose of makeFun(). Experienced programmers know that the way you make functions in R is by using the function keyword. For instance: f &lt;- function(x) { 3 + 2*x } That’s a completely correct and legitimate way to define a function in R and in most settings is the universal practice. We developed makeFun() to handle a situation where computers, in their insistence on avoiding ambiguity, will do something that is not what the person familiar with math notation is likely to suspect. The problem comes up in something as simple as g &lt;- function(x) { m*x + b } In traditional math notation, \\(g(x) \\equiv m x + b\\), we are usually silent on where parameters like \\(m\\) and \\(b\\) are coming from. And, to be honest, you don’t have to worry about this until you try to evaluate the function. 630 If you evaluate, say, the command \\(g(3)\\), the R system knows how to find the right values for \\(m\\) and \\(b\\). If there are no such objects in the appropriate places in the R system, an error message will be generated. The rules that computer languages follow in tracking down symbols that aren’t in the argument list are called scoping rules. Scoping is an advanced programming concept and different languages use different rules. For those few whose programming background includes an understanding of scoping here’s an explanation. The ordinary scoping rules in R would make undefined parameters like \\(m\\) and \\(b\\) in a function definition have bindings in the environment in which the function was defined. This would typically be the global environment, an unsatisfactory arrangement it would be difficult to customize an individual function or invocation of a function to use a specific value for the parameters. makeFun() is arranged to add any parameters in the function algorithm to the argument list. The makeFun() command creates a function with 3 arguments. makeFun(m*x + b ~ x) ## function (x, m, b) ## m * x + b The point of the ~ x part of the tilde expression is simply to name which arguments should come first. To evaluate the function, you’ll have to provide values for m and b. But some operations on a function—differentiation and anti-differentiation, in particular—can be done without having to specify parameter values. For those of you who know what differentiation or anti-differentiation are, here is an example: D(m*x + b ~ x) ## function (x, b, m) ## m antiD(m*x + b ~ x) ## function (x, C = 0, m, b) ## m * (1/2 * x^2) + b * x + C Sometimes you have particular numerical values in mind for the parameters. For instance, if you are modeling the trajectory of a ball, you will undoubtedly need to make use of gravitational acceleration at the Earth’s surface, which is \\(9.8 \\text{m}/\\text{s}^2\\). You might prefer not to include the specific number 9.8 in your function definitions so that you can use the same functions to model a ball’s trajectory on Mars. But since most balls are thrown on Earth, maybe it’s not worthwhile to insist that the value 9.8 be specified every time the function is used. You can have it both ways by using g as the parameter name and instruct R to set g to 9.8 unless otherwise specified. The function will look like this: 640 ball_velocity &lt;- makeFun(g*t + t0 ~ t, g = 9.8, t0 = 0) # For Earth: falling 3 seconds from a standstill ball_velocity(3) ## [1] 29.4 # For Earth when the ball has an initial upward velocity of 10 m/s ball_velocity(3, t0 = -10) ## [1] 19.4 # For Mars ... ball_velocity(3, t0 = -10, g = 3.711) ## [1] 1.133 5.8 \\(=\\), \\(\\equiv\\), \\(\\rightarrow\\), &lt;- The \\(=\\) sign carries a lot of weight in high-school notation. Too much weight. It is used for several meanings that ought to be distinguished one from another. Combining them all into one symbol leads to confusion and error. Meaning 1: “Is defined to be …” We use \\(\\equiv\\) in mathematical notation and &lt;- in R. The notation in R is a bit simpler than the mathematical notation: it is a way of giving something a name. name &lt;- something If the “something” is a function, you will see that on the left side of &lt;-, for instance by use of the makeFun() operator in h &lt;- makeFun(x^2 ~ x). The left side is simply a name. In math notation, the equivalent would be written \\(h(x) \\equiv x^2\\). The left side isn’t exactly a name. It’s a name followed by parentheses in which are the names being used in the algorithm. Keep in mind that in writing about functions, we will generally provide a hint that the name refers to the function, writing \\(h()\\) or h(). The parentheses aren’t part of the name; the name here is \\(h\\). But the parentheses remind us that \\(h\\) is a function. 650 Meaning 2: “Happens to be …” The acceleration due to gravity is often given the name \\(g\\). On Earth’s surface, it happens to be \\(9.8 \\text{m}/\\text{s}^2\\). In our math notation, we will use the equal sign for this narrow meaning, as in \\(g=9.8\\text{m}/\\text{s}^2\\). In R we will use =. Meaning 3: “Gets closer and closer to …” Calculus is about relationships: the connection between two (or more) things. So you will hear phrases like, “As \\(x\\) increases, \\(f(x)\\) decreases.” Or, in everyday experience, “As it gets more humid, the weather becomes more uncomfortable.” Or, “slower is safer,” or “the spicier the better” or “the heavier the blanket, the warmer I’ll be.” (One of the important uses of derivatives in calculus is to represent such statements quantitatively. But that’s a subject for the next Block.) In calculus, sometimes you have to distinguish between “\\(x\\) is zero” and “\\(x\\) gets closer and closer to zero.” We’ll need this when we want to say, “It gets smaller and smaller, but doesn’t disappear entirely.” The symbol for “gets closer and closer to” is \\(\\rightarrow\\), as in \\(x \\rightarrow 0\\) In reading math, take care to notice which of \\(=\\), \\(\\rightarrow\\), or \\(\\equiv\\) is being used. The sign has something important to say and is intended to help you make sense of what you read. 5.9 Exercises Exercise 5.1: TKWEW Use the CalcZ naming conventions to answer these questions. Question A What is \\(h()\\)? The name of a functionRight! Right. Typically we use \\(f()\\), \\(g()\\), \\(h()\\) or something similarly generic to stand for a function that we’re going to be working with for a little while. Think of these as pronouns. Just as we can say, meaningfully, “She gave it to him,” we can say \\(h(x) \\equiv f(x) + g(2*x)\\) The name of an input.︎✘ Sorry, these will usually be letters like \\(x\\), \\(y\\), \\(t\\). A specific numerical value︎✘ Sorry, but we’ll use constructions with a subscript like \\(x_0\\) or \\(y_\\star\\) and the like for these. Question B How come we write \\(f()\\) for the name of a function rather than just \\(f\\) or \\(f(x)\\)? No good reason︎✘ We certainly intend with the empty parentheses to remind the reader that a name refers to a function. If you spot a place where we violate this intention, point it out to us. It’s a reminder that we’re talking about a function with the name “\\(f\\)”.Correct.  The parentheses are part of the name.︎✘ Not at all. Names in R never contain parentheses. So f, fbar, fred are all valid names in an R command, but f() is not. We use the parentheses when writing to a human audience as a reminder that the name is referring to a function. The computer doesn’t need any such reminders Question C What sort of thing is denoted by \\(x_0\\) or \\(y_\\star\\) or \\(y_{max}\\)? A particular numerical valueNice! Right. For instance, it might be the particular value for the input to a function which produces an output of zero. Or it might be a particular location in the domain of a function. The name of an input︎✘ Sorry. We won’t typically use subscripts when referring to an input name. Question D Which of these symbols might stand for the entire domain of a function? \\(y\\)Nice! Right. Another term to use for a symbol standing for a domain is “name of an input”. \\(f()\\)︎✘ No, this is how we write the name of the function called “\\(f\\)” \\(y_0\\)︎✘ No. \\(y_0\\) might be used to stand for a single point in the domain. Question E Suppose you come across \\(v(w) \\equiv w + 3\\) in this book. What do \\(v\\) and \\(w\\) stand for? \\(v()\\) is the name of a function and \\(w\\) is the name of the input to that function.Excellent! Right. Whenever we write something like “name(another_name) \\(\\equiv\\)”, we’re saying explicitly that “name” refers to a function and “another_name” refers to an input. It’s meaningless.︎✘ We’ll try not to write meaningless mathematical expressions. If we do by mistake, let us know. It’s the same thing as \\(v = w + 3\\).︎✘ \\(v = w+3\\) is an equation. But \\(v(w) \\equiv w+3\\) is the format for defining a function named \\(v()\\). Question F Are \\(g(x) \\equiv x^2\\) and \\(h(w) \\equiv w^2\\) the same function? Yes, although that function is being given two different names.Excellent! The only thing that’s significant about the name of an input is that it be used consistently in the function algorithm. Of course not!︎✘ Sorry. I suppose you might ask, “What do you mean by the same function?” Remember that a function is a relationship between inputs and the output. \\(g(x) \\equiv x^2\\) and \\(h(w) \\equiv w^2\\) describe exactly the same relationship: the output will be the square of the input. Exercise 5.2: LDNE According to the notation style we use in CalcZ, which of these things is a function? Which a number? Question A What kind of a thing is \\(\\sqrt{z}\\)? A functionExcellent!  A number︎✘ \\(z\\) is one of the standard names we will use for an input to a function. If we had given the function a name, for instance \\(g(z) \\equiv \\sqrt{z}\\), we would be able to tell from the \\((z)\\) that \\(g()\\) is a function. But whenever we use a standard input name, the expression is a function. Question B What kind of a thing is \\(\\sqrt{y^\\star}\\)? A numberCorrect.  A function︎✘ According to our convention, the name \\(y^\\star\\) refers to a particular value as opposed to the name of a function input. Question C What kind of a thing is \\(e^{k t}\\)? A functionNice!  A number︎✘ The letter \\(t\\) is one of our standard letters for input names. \\(k\\) is a letter, but since it is not from the end of the alphabet, you have a hint that it is intended to be a parameter, that is a symbol representing a specific numerical quantity. Question D What kind of a thing is \\(k\\) in the definition \\(g(k) \\equiv e^k\\)? A number︎✘ The name of an input to a function.Good.  A function︎✘ Notwithstanding our convention that \\(k\\) is not on its own a name used for inputs, when we use the full function-definition style, anything in the parentheses following the function name is explicitly stated as an input name. Exercise 5.3: kZG5Fj The following traditional-style notation is intended to define a function that is 2 times the pattern-book sinusoid. But something is wrong. \\[g(t) \\equiv 2 \\sin(x)\\] Question A What’s wrong with the definition? \\(g()\\) isn’t an appropriate name︎✘ You can name functions what you like. The formula should be written \\(2 \\times \\sin(x)\\)︎✘ You are welcome to write things that way if you want to emphasize the multiplication, but you don’t have to. On the other hand, in R it would be absolutely required to write the multiplication operator: 2 * sin(x). \\(t\\) is not a good choice for the input name.︎✘ It’s a fine choice, especially when the input is time. The input name in the formula doesn’t match the input name on the left side of \\(\\equiv\\).Good. That’s it. Once you choose an input name (here, \\(t\\)), make sure to write the formula in terms of that name. Exercise 5.4: aeOnO5 Consider this expression in math notation: \\[\\frac{e^{k t}}{k}\\] Question A Which of the following R expressions implements the math-notation expression? k exp(kt)︎✘ You must always express multiplication explicitly, using * between the quantities to be multiplied. e^k*t / k︎✘ Use exp(x) for \\(e^x\\). exp(k t) / k︎✘ k t should be written k*t exp(k*t) / kNice!  1/k e^kt︎✘ 1) Use * for multiplication. 2) Use exp(x) for \\(e^x\\). "],["graphs-and-graphics.html", "Chapter 6 Graphics &amp; function graphs 6.1 The graphics frame 6.2 Data graphics: the point plot 6.3 Function graphs 6.4 Graphics layers 6.5 Data and functions 6.6 Inputs to output 6.7 Outputs to inputs 6.8 Graphs of functions with two inputs 6.9 Contour plots 6.10 Slice plots 6.11 Exercises", " Chapter 6 Graphics &amp; function graphs Scientific and statistical graphics are visual depictions of information and data. For displaying a function with a single input, mathematicians and others favor a particular style of graphics. This favored style is called a function graph, which has a specific technical meaning in mathematics. Notice that we’re writing “function graph” rather than “function graphic.” A function graph is a particular sort of graphic: there are many other types of graphics some of which we’ll use to display data or features of functions. 700 6.1 The graphics frame Technical graphs are usually drawn in a graphics frame that has several components: The frame is a region on the piece of paper or computer screen that is marked off by a horizontal and a vertical axis. The horizontal axis stands for one quantity. The vertical axis stands for another quantity. Both the horizontal and vertical axes are drawn with a scale that enables you to translate between a numerical value and position. Figure 6.1: An empty graphics frame with scales for both the horizontal and vertical axes. 6.2 Data graphics: the point plot One of the most common uses of a graphics frame is to display visually two columns from a table containing data. Data are stored in a spreadsheet-like format called a data frame. There are many ways to access data frames and many different ways to store them. In CalcZ we supply data frames in the simplest possible way: giving them a name that you can use to refer to the data frame. For instance, here is a small part of a data frame about the size of penguins in the Palmer Archipelago in Antarctica. 710 species body_mass flipper_length bill_length Chinstrap 3.600 19.3 4.57 Chinstrap 3.850 19.5 4.76 Adelie 3.300 18.7 3.62 Gentoo 4.300 20.8 4.38 Chinstrap 3.950 21.0 4.90 Chinstrap 2.700 19.2 4.69 Gentoo 5.650 22.4 4.95 Adelie 4.300 19.5 4.15 Adelie 3.325 19.0 3.85 Chinstrap 3.775 19.4 5.17 The output above shows what a data frame looks like. Now we need to look at how to use a data frame in an R command. The particular data frame shown just above has the name penguins in R. To refer to the data frame, just use the name. Open a SANDBOX and give the name itself as a command. This simple command causes the data frame to be displayed on the screen. penguins You should see as a result a table that can be scrolled through interactively with all 344 rows of the penguins data frame. Looking at a data frame, or part of one, is sometimes what’s required. But in general you will use the name of the data frame of interest as an argument to an R function. Typically the argument will be named data = as you’ll see below. The name penguins is very general and it wouldn’t be at all surprising if some other penguin fan or researcher created a different set of data with the same name. R, like many other modern languages, makes room for such multiple uses of a name by a facility called a namespace. R programmers can create their own namespace. This is not something we will do in this course. But it’s helpful to know when the namespace mechanism is at work. For instance, the particular penguins we’ve provided with this course comes from a namespace called palmerpenguins. Thus, the “full” name of the data fr is palmerpenguins::penguins. You may see such name constructions occasionally in exercises in this course. You don’t have to understand how namespaces work other than to know that when you are given the full name, you should use it, double colons and all. Before you can use gf_point() to plot a pair of columns from a data frame, you have to know the names of the columns. A useful function for this is names(). Similarly, to look at the first few rows, use the head() function. Try these commands in a sandbox: names(penguins) head(penguins) A point plot displays two columns from a data frame. Each row in the data frame is represented by one point in the graphic. For instance: gf_point(flipper_length_mm ~ body_mass_g, data=penguins) Figure 6.2: Data from 344 penguins on flipper length (mm) and body mass (g). Each penguin has a specific mass and flipper length. If you focus your attention on the penguins with a mass of around 4 kg (that is, 4000 gm), you can see that the different penguins have a variety of flipper lengths. That’s typical natural variability. 6.3 Function graphs Back in Section 4.1 you saw how to use R to create a graph of a function with a single input. (Review that section now if you’ve forgotten.) The slice_plot() function takes two arguments: A tilde expression giving the function you want to plot and naming the horizontal axis. The domain to use when making the plot. For example: slice_plot(sin(z) ~ z, domain(z=c(-10, 10))) The tilde expression can be more elaborate of course, for instance sin(z)*z + z^2 ~ z, but it will always have the name to be used for the horizontal axis on the right-hand side of the tilde character. The domain to be shown in the graph is specified using a special-purpose function, called domain(). The argument to domain is named: Use the same name as on the right-hand side of the tilde expression then an equal sign, then a collected pair of numbers specifying the lower and upper ends of the domain. The collected pair must always be given as the arguments to a very basic function named c(), which simply collects it’s arguments. Later, when we graph functions with two inputs, you’ll see why domain() is set up this way. 6.4 Graphics layers You will often want to compare two functions, or compare a function to data. You can do this using the ordinary graphics functions, e.g. slice_plot() or gf_point(), arranging things so that both types of graphics are drawn together in the same graphics frame. To create this kind of compound graphic, arrange the individual graphics commands into a pipeline, which is a list of commands connected together by %&gt;%. Your pipeline might include two commands or twenty, depending on how complicated is the graphic you want to draw. As long as you use %&gt;% after each command, the next command is taken to build upon the previous command. The very last command in that pipeline should not be followed by %&gt;%.” 720 Here is an just-for-demonstration plot composed from three graphs, each displaying one of the pattern-book functions. At the start of the pipeline, the domain() must be given explicitly as an argument to slice_plot(). You’re welcome to specify other domains in the commands further along the pipeline, but if you don’t the original domain() will be passed down the pipeline. slice_plot(dnorm(x) ~ x, domain(x=c(-4,4))) %&gt;% slice_plot(pnorm(x) ~ x, color=&quot;red&quot;, size=2) %&gt;% slice_plot(sin(x) ~ x, color=&quot;green&quot;, size=4, alpha = 0.2) Just to show how these things are done, the functions have been drawn in different colors, different widths (e.g., size=2) and different levels of transparency (e.g. alpha=0.2). You can use such styling arguments in any slice-plot. 6.5 Data and functions In Figure 6.2, the data point plot of the penguin flipper length vs body mass, there are generally multiple penguins with the same body mass but different flipper lengths. The overall impression is that of a cloud of points. When we construct a function to model the pattern observed in that cloud, we need to respect the mathematical definition of function, part of which is that a function has only one output for any given input. Figure 6.3: Connecting the penguin data points with lines (left) doesn’t directly describe any sensible mathematical function. We use modeling to create a smooth function (right) that stays close, but not too close, to the data points. To create the model of flipper length as a function of body mass, we used one of a set of techniques called machine learning. That is, we didn’t specify that the form should be an exponential or a gaussian or a sigmoid or any other particular shape. We simply asked the computer to figure out a smooth function that stays close to the data. The result, as it happens, was a sigmoid. 730 6.6 Inputs to output You can easily evaluate a function for a given input from its graph. As you know, just put your finger at the horizontal coordinate for the input. Then move your finger upward to reach the point on the curve directly above that horizontal coordinate. You read off the value of the function at that input by reference to the scale on the vertical axis. 740 It’s not possible to show with a graph the whole of a function whose domain is \\(-\\infty\\) to \\(\\infty\\). Consequently, when drawing a graph we choose to show only that part of the domain that we expect will be relevant to our needs. Sometimes, the graphic’s domain includes parts that are not in the domain of the function being drawn. In such cases, the function’s graph does not extend into the invalid part of the graphic domain, as in this plot of a function whose domain is only the positive numbers. This function has a range that runs from \\(-\\infty\\) to \\(\\infty\\), but the limits of paper and display mean that we can show only part of this range. With experience, you’ll learn to read the hints in a graph that the underlying function might have a range larger than the one shown in the graphic. 6.7 Outputs to inputs Graphs are relatively modern, coming into mainstream use only in the 1700s. Much of mathematics was developed before graphs were invented. One consequence of this is that function tasks that are easy using a graph might be very hard with the previous ways of implementing functions. This is analogous to the way that arithmetic is pretty easy with Arabic numerals, but really hard with Roman numerals. 750 A function graph makes it easy to evaluate the function inverse. For all the basic modeling functions we have a way to calculate numerically the output for any given input (in the function’s domain). Often, working with a function goes another way: you know the output and you want to find a corresponding input. It’s easy to do this with a graph. Pick the position on the vertical axis that represents the given input. Then trace horizontally to where the ink is. From there, trace vertically to read off the value of an input that would produce the given output. Mathematicians are careful to distinguish between functions where there is one and only one possible input that generates each given output, and functions where there can be more than one input that generates the same output. (Mathematicians use the word unique to mean “one and only one.”) Functions with a one-to-one relationship between output and input are called “invertible.” Invertible or not, it is a common procedure for working with functions to find an input corresponding to a specific, given output. In high-school algebra, this was called “solving for \\(x\\).” A special case of solving is finding the roots of a polynomial. The name we give to the procedure is zero finding, which correctly points out that we are trying to find an input. 6.8 Graphs of functions with two inputs We can draw graphs of functions with two inputs. Now the points need to be marked in a 3-dimensional space: one axis for each of the two inputs and another axis for the output. Like this: 760 Figure 6.4: A graph of a function of two inputs is a surface. It is very hard to read a graph of a function with two inputs. Think of the graph as a kind of tent suspended over a domain of ground. The graph itself is a surface. To show the graph on a display, some tricks of the trade are used: color to give an additional scale for the output; computer graphics to let us rotate the surface to look at it from various perspectives, added grid lines and marks on the surface to help us read out the numerical value. 6.9 Contour plots A mathematical graph is just one way to draw a picture of a function with two inputs. There are other ways. One helpful mode of picture is called a contour plot, familiar to many non-mathematicians in the form of topgraphical maps showing landscape elevation as a function of latitude and longitude. Figure 6.5 shows a contour plot of the same function shown in Figure 6.4. 770 Figure 6.5: A contour plot displays the surface in the same manner as a topographical map shows the terrain. This contour plot is a topographical map of the mathematical graph in Figure @ref(fig:fun-1b-1-2). It may take some practice to learn to read contour plots fluently but it is a skill that’s worthwhile to have. Note that the graphics frame is the Cartesian space of the two inputs. The output is presented as contour lines. Each contour line has a label giving the numerical value of the function output. Each of the input value pairs on a given contour line corresponds to an output at the level labeling that contour line. To find the output for an input pair that is not on a contour line, you interpolate between the contours on either side of that point. For example, the input pair (0, 0)—which is at the bottom of the frame, midway from left to right—falls between the contours labeled “20” and “22.” This means that the output corresponding to input (0, 0) is somewhere between 20 and 22. The point is much closer to the contour labeled “20”, so it’s reasonable to see the output value as 20.5. This is, of course, an approximation, but that’s the nature of reading numbers off of graphs. Often, the specific numerical value at a point is not of primary interest. Instead, we may be interested in how steep the function is at a point, which is indicated by the spacing between contours. When contours are closely spaced, the hillside is steep. Where contours are far apart, the hillside is not steep, perhaps even flat. Another common task for interpreting contour plots is to locate the input pair that’s at a local high point or low point: the top of a hill or the bottom of a hollow. Such points are called local argmax or local argmin respectively. The output of the function at a local argmax is called the local maximum; similarly for a local argmin, where the output is called a local minimum. (The word “argmax” is a contraction of “argument of the maximum.” We will tend to use the word “input” instead of “argument”, but it means exactly the same thing to say “the inputs to a function” as to says “the arguments of a function.”) Here are some additional tasks which you should learn to perform at a glance when reading a contour plot: Start at a given input pair and determine two directions: the direction to move which is most steeply uphill, the direction to move which will keep the function output the same. Translate a small region of a contour plot into the word for a corresponding geographical feature with that topology: hills, valleys, crests, coves, hollows, and so on. 6.10 Slice plots As mentioned before, mathematical modeling is the process of constructing mathematical representations of situations or phenomena of interest. In CalcZ, we are primarily interested in using functions as such representations. 780 Almost always, when mathematically modeling a real-world situation or phenomenon, we do not try to capture every nuance of every relationship that might exist in the real world. We leave some things out. Such simplifications make modeling problems easier to deal with9 and encourage us to identify the most important features of the most important relationships. On the other hand, it’s easy to go wrong and leave out something that’s important. To mitigate this risk, many modeling projects involve a modeling cycle where we propose a candidate model, examine the consequence of that model to see if it corresponds well to the parts of reality that are important to us in our task, and modify the model as needed to produce a new and better candidate. 790 In this spirit, it’s useful always to assume that our models are leaving something out and that a more complete model involves a function with more inputs than the present candidate. The present candidate model should be considered as a slice of a more complete model. Our slice leaves out one or more of the variables in a more complete model. To illustrate this, suppose that we have a “more complete model” in the form of a function of two inputs, as shown in the contour plot below. As you become practiced reading contour plots, you might prefer to read this one as a hilltop (shaded yellow) side-by-side with a hollow or bowl (shaded purple), with green, almost level flanks at the left and right edges of the frame. The most common forms of slice involve constructing a simpler function that has one input but not the other. For example, our simpler function might ignore input #2. There are different ways of collapsing the function of two inputs into a function of one input. An especially useful way in calculus is to take the two-input function and set one of the inputs to a constant value. For instance, suppose we set input #2 to the constant value 1.5. This means that we can consider any value of input #1, but input #2 has been replaced by 1.5. In Figure 6.6, we’ve marked in red the points in the contour plot that give the output of the simplified function. 795 Figure 6.6: Left: A slice through the domain of a contour plot. Right: The value of the function along that slice, presented as a mathematical graph, as generated by slice_plot(). Each point along the red line corresponds to a specific value of input #1. From the contours, we can read the output corresponding to each of those values of input #1. This relationship, output versus input #1 can be drawn as a mathematical graph (to the right of the contour plot). Study that graph until you can see how the rising and falling parts of the graph correspond to the contours being crossed by the red line. Slices can be taken in any direction or even along a curved path! The blue line below the slice constructed by letting input #2 vary and holding input #1 and the constant value 0. 6.11 Exercises Exercise 6.1: 9LB8hK Question A What is the exact input to the pattern-book logarithm function where the output is 0?     0︎✘        0.3989423︎✘        1/2︎✘        1\\(\\heartsuit\\ \\) Question B What is the exact input to the pattern-book reciprocal function where the output is 1?     0︎✘        0.3989423︎✘        1/2︎✘        1\\(\\heartsuit\\ \\) Question C What is the exact input to the pattern-book proportional function where the output is 1/2?     0︎✘        0.3989423︎✘        1/2\\(\\heartsuit\\ \\)       1︎✘ Question D The pattern-book square function just touches the horizontal axis. What’s the input where this happens?     0\\(\\heartsuit\\ \\)       0.3989423︎✘        1/2︎✘        1︎✘ The word “tractable” is used to describe problems that can be productively handled.↩︎ "],["params-intro.html", "Chapter 7 Parameters for functions 7.1 Parallel scales 7.2 Scaling the input 7.3 Scale the output 7.4 Linear combinations 7.5 Exercises", " Chapter 7 Parameters for functions The pattern-book functions provide the modeler with a collection of shapes. They are not yet fully suited to represent real-world phenomena. To illustrate, consider Figure 7.1 which shows the number of officially confirmed COVID-19 cases in the US in March 2020. 800 The COVID pandemic was widely and appropriately described as “exponential,” so alongside the data Figure 7.1 shows the function \\(e^x\\). Figure 7.1: Cumulative officially confirmed COVID-19 cases during the month of March, 2020. The red curve is \\(e^x\\) There’s an obvious mismatch between the data and the function \\(e^x\\). Does this mean the COVID pattern is not exponential? A hint comes from the formula \\(e^x\\). What is \\(x\\)? Plotted as it is in the graph, \\(x\\) is the calender day in March. But why shouldn’t \\(x\\) be the given in hours or minutes or weeks? If we want the input to \\(\\exp()\\) to be in “hours” instead of “days,” we can multiply \\(x\\) by 24. If the input is to be in weeks, the multiplier should be \\(\\frac{1}{7} = 0.1429\\). In both cases, the function will be \\(e^{kx}\\), where \\(k\\) would be 24 for hours or 0.1429 for weeks. Exploring a bit, we found that \\(0.3 \\leq k &lt; 0.5\\) will produce functions graphs that match the data much better than pattern-book \\(e^x\\). 810 Figure 7.2: COVID-19 data compared to the exponential functions \\(e^{kt}\\). A variety of possible numerical values for \\(k\\) is shown. The multiplier \\(k\\) in \\(e^{kx}\\) is called a parameter of the function: a number that we can use to set the scale of the input. To use the exponential function to model COVID, we’ve had to stretch out the red curve in Figure 7.1 by tailoring pattern-book \\(x\\) as \\(k x\\). Perhaps it’s a matter of personal choice which size of \\(k\\) will be best suited to model the data. My personal choice is \\(k=0.30\\). My reasoning? The \\(k=0.30\\) curve roughly parallels the COVID data. The flaw with \\(k=0.30\\) is that the curve lags the data by several days. But we can fix this by pulling the \\(k=0.30\\) curve to the left. Mathematically this can be accomplished by subtracting a few days from \\(x\\) before multiplying by \\(k\\), that is, using the function \\[f(x) \\equiv e^{k(x-x_0)}\\] where \\(x_0\\) stands for the shift. (A positive value for \\(x_0\\) is a shift to the right, a negative value is a shift to the left.) Figure 7.3 shows (in red) the \\(k=0.30\\) curve after pulling it 10 days to the left. It’s now a pretty good match to the data. Figure 7.3: COVID-19 data compared to the exponential functions \\(e^{k(t-x_0)}\\). Here, \\(x_0\\) is negative because the shift is to the left. Note that once we’ve aligned the red curve horizontally, it seems to curve too much. The green curve does much better. It has a much gentler curve, \\(k=0.19\\) and is pulled about a little more than a month to the left. 820 By parameterizing the exponential function as \\(e^{k(x-x_0)}\\) and finding suitable values for \\(k\\) and \\(x_0\\), we get a good match to the March data. But models can sometimes tell us more. For the green curve in Figure 7.3 the value of \\(x_0\\) is -32 days. 32 days before March 1 is late January. We know from other sources of information, the outbreak began in late January. It’s remarkable that even though the curve was constructed without any data from January or even February, the data from March, translated through the curve-fitting process, pointed to the start of the outbreak. 7.1 Parallel scales The graphical format we have been using to display functions of one variable places the input on the horizontal axis and the output on the vertical axis. This is not the only way to draw a function. Consider these everyday objects: a thermometer and a ruler.       Each object presents a read-out of what’s being measured—temperature or length—on two different scales. At the same time, the objects provide a way to convert one scale to another. A function gives the output for any given input. We represent the input value as a position on a number line—which we call an “axis”—and the output as a position on another output line, almost always drawn perpendicular to one another. But the two number lines can just as well be parallel to one another. To evaluate the function, find the input value on the input scale and read off the corresponding output. The inverse function can be evaluated just as easily: switch the roles of the input and output scales. 830 Taking the traditional (“imperial”10) unit scale as the input and the metric scale as the output, the two functions implemented on the objects are: \\[\\underbrace{C(F) = \\frac{5}{9}(F-32)}_\\text{Fahrenheit to Celcius}\\ \\ \\ \\text{and}\\ \\ \\ \\ \\underbrace{\\text{cm(inches)} = 2.54 \\times (\\text{inches}-0}_\\text{inches to cm})\\] These are very simple, straight-line functions, but they play an important role in modeling. Each conversion function can be written in the form \\(\\line(x) \\equiv m (x - x_0)\\). Of course, if you multiply the \\(m\\) through both terms in parentheses, you get \\(\\line(x) = m x - m x_0\\) which can be written even more simply as \\(mx + b\\) by setting \\(b\\equiv m x_0\\). so the conversion function does conform to the straight-line formula we’re used to. \\(m\\) and \\(x_0\\) are the parameters of the straight-line function. In terms of the graph of a straight-line function, \\(m\\) is the slope and \\(x_0\\) is the x-intercept respectively. Often, functions can be parameterized in other ways. For instance, you likely learned the parameterization \\(m x + b\\), in which \\(m\\) is (still) the slope of the graph but \\(b\\) is the y-intercept. (Expanding out \\(m(x-x_0)\\) and comparing to \\(m x + b\\), you can see that \\(b = m x_0\\).) We can call \\(m(x - x_0)\\) the “x-intercept parameterization” and \\(m x + b\\) the \"y-intercept parameterization. They are equivalent and equally good ways of parameterizing the straight line. There are still other ways of parameterizing, each style reflecting its own format for specifying the two points that make up a line. 7.2 Scaling the input To turn a pattern-book function into a basic modeling function all we do is use \\(\\line()\\) to convert the input before applying the pattern-book function. 840 To illustrate the link between basic modeling functions and their pattern-book prototypes, Figure 7.4 shows the model we fit to the COVID-19 data for the cumulative number of confirmed cases for each day in March: \\(\\text{cases(day)} = e^{0.19(\\text{day}- -32)}\\) Figure 7.4: A graph of the pattern-book exponential with an additional scale displayed (blue) to match it to the COVID-19 data The function being drawn is simply \\(e^x\\): a function from the pattern book. The black horizontal scale shows \\(x\\), the input to the pattern-book function. Where does that value of \\(x\\) come from? It’s \\(0.19(\\text{day} - -32)\\), where day is the number of the day in March. For instance, on March 20, day\\(=10\\) and \\(0.19*(\\text{day}- -32) = 9.88\\). You can see that 20 on the blue scale matches 10 on the black scale. The model says that on day 20 (blue scale) the input to the pattern-book function will be 9.88 (black scale). Plugging the input 9.88 into the pattern-book exponential gives \\(e^{9.88} = 19536 \\approx 20,000\\) cases. The pattern-book function does not give a good model of the COVID case numbers. But if we scale the input before applying the pattern-book function, we are effectively laying a new axis, the blue one in Figure 7.4, that is stretched and shifted from the pattern-book input (blackscale). Using the blue axis lets us read off the number of cases as a function of the day in March. Input scaling empowers the pattern-book functions to model a huge variety of phenomena. There’s just one exponential function and it always looks exactly the same. But there is a huge variety of ways to draw a blue axis, that is, to scale the input. With input scaling, the pattern-book function is tailored to become one of our basic modeling functions. \\[\\underbrace{e^x}_\\text{pattern-book function}\\ \\text{versus}\\ \\underbrace{e^{k(x-x_0)}}_\\text{basic modeling function}\\] The straight-line function \\(\\line()\\) is being written here as \\(k(x-x_0)\\) rather than \\(m(x-x_0)\\). It’s traditional when writing exponential functions to use the letter \\(k\\) as the multiplier, but you can use whatever name you wish for a parameter. Knowing and using the idiom of mathematical notation will help you read and write mathematics more fluently. 850 The table shows a of the mathematical idioms used in parameterizing the pattern-book functions. Function Written form Parameter 1 Parameter 2 Exponential \\(e^{kt}\\) \\(k\\) “exponential constant”11 Not used Exponential \\(e^{t/\\tau}\\) \\(\\tau\\) “time constant”12 Not used Exponential \\(2^{t/\\tau_2}\\) \\(\\tau_2\\) “doubling time”13 Not used Power-law \\([x - x_0]^p\\) \\(x_0\\) x-intercept exponent Sinusoid \\(\\sin\\left(\\frac{2 \\pi}{P} (t-t_0)\\right)\\) \\(P\\) “period” \\(t_0\\) “time shift” Sinusoid \\(\\sin(\\omega t + \\phi)\\) \\(\\omega\\) “angular frequency” \\(\\phi\\) “phase shift” Sinusoid \\(\\sin(2 \\pi \\omega t + \\phi)\\) \\(\\omega\\) “frequency” \\(\\phi\\) “phase shift” Gaussian dnorm(x, mean, sd) “mean” (center) sd “standard deviation” Sigmoid pnorm(x, mean, sd) “mean” (center) sd “standard deviation” Straight-line \\(mx + b\\) \\(m\\) “slope” \\(b\\) “y-intercept” Straight-line \\(m (x-x_0)\\) \\(m\\) “slope” \\(x_0\\) “center” 7.3 Scale the output Just as the natural input usually needs to be scaled before it reaches the pattern-book function, so the output from the pattern-book function may need to be scaled before it presents a result suited for interpreting in the real world. Figure 7.5: Natural quantities must be scaled to pure numbers before being suited to the pattern-book functions. The output from the function is a pure number which is scaled to the natural quantity of interest. The overall result of input and output scaling is to tailor the pattern-book function so that it is ready to be used in the real world. 860 Name Pattern-book form Modeling form exponential \\(e^x\\) \\(A e^{kx} + C\\) sinusoid \\(\\sin(x)\\) \\(A \\sin\\left(\\frac{2 \\pi}{P} (x-x_0)\\right) + C\\) proportional \\(x\\) \\(a x + b\\) The parameter \\(C\\) is often called the baseline or the offset. Statisticians call it the “intercept,” because it plays the same role as \\(b\\) in the straight-line function. When working with sinusoids, parameter \\(A\\) is called the amplitude. Of course, you’re already familiar with \\(a\\) and \\(b\\): the slope and y-intercept of a straight line. Figure 7.6: Baseline (blue), amplitude (red), and period (green) for the sinusoid. Figure 7.7: The baseline for the exponential is the horizontal asymptote. There is no vertical asymptote. Our prefered form for the input scaling in the basic modeling functions is \\(m(x - x_0)\\). Sometimes it can be a little hard to see this form given the conventions for parameterization. For instance, in the basic modeling sinusoid \\[\\sin\\left(\\underbrace{\\frac{2 \\pi}{P}}_m\\ \\ (x-x_0)\\right)\\] the multiplier is written \\(\\frac{2\\pi}{P}\\) rather than \\(m\\). 863 In the basic modeling exponential and straight line functions \\[A e^{kx} + C \\ \\ \\ \\text{and}\\ \\ \\ a x + b\\] The \\(x_0\\) does not appear. Why not? Suppose we did write the exponential as \\[A_2 e^{k(x-x_0)} + B\\] This could be simplified algebraically to \\[A_2 e^{kx_0} e^{kx} + B\\] Although this looks a bit different, note that \\(e^{k x_0}\\) is simply a number, not a function of \\(x\\). We can therefore combine it with \\(A_2\\), giving \\(A = A_2 e^{k x_0}\\). The \\(A\\) coefficient in the exponential makes any use of \\(x_0\\) redundant and unnecessary. A similar algebra logic applies to the straight-line function \\(ax + b\\). We don’t need an \\(x_0\\) there, either. 7.4 Linear combinations We’ve discussed shifting the baseline of the exponential and sinusoid functions by adding a constant to the basic modeling function, like this:864 \\[f(t) \\equiv A e^{kt} + C\\\\ \\ \\\\ g(t) \\equiv A \\sin\\left(\\frac{2\\pi}{P} t\\right) + C\\] We’ve called this output scaling. It’s an example of a much more general and powerful way of contructing modeling functions called linear combinations. In a linear combination, you start with one or more basic functions. For discussion, let’s call these \\(f_1(t)\\), \\(f_2(t)\\), \\(f_3(t)\\) and so on. In making a linear combination, multiply each of the basic functions by some quantity and add the results together: \\[\\text{linear combination of}\\ f_1(t)\\ \\text{and}\\ f_2(t): \\ \\ A_1 f_1(t) + A_2 f_2(t)\\] The quantities \\(A_1\\) and \\(A_2\\) are called scalars because they scale the functions. (In Chapter ?? you will see that we make a distinction between a scalar, which is a single quantity, and a vector, which is a set of scalars.) It’s common to take linear combinations of functions with different inputs, for example \\[h(x, y, t) \\equiv 4 e^{-kt} + 7 y + 2\\,\\pnorm(x-3) - 19\\] In fields like statistics and economics and other social sciences, as well as clinical medical research, a great number of modeling techniques involve such combinations of functions of various inputs. 866 In engineering and physics, an important class of functions involves a linear combination of many sinusoids of different periods, e.g.  \\[\\text{signal}(t) \\equiv A_1 \\sin\\left(\\frac{2 \\pi}{P_1}t\\right) + A_2 \\sin\\left(\\frac{2 \\pi}{P_2}t\\right) + A_3 \\sin\\left(\\frac{2 \\pi}{P_3}t\\right) + \\cdots\\] Linear combination of functions provides a powerful and flexible general-purpose modeling technique in part because many physical systems seem to work this way and in part because the methods for finding the scalars—\\(A_1\\), \\(A_2\\), and so on—have an extremely strong theory and fast computer implementations that automatically solve the problem once the modeler has selected the functions she wants to combine. In Block 4, we use the name target problem to refer the problem of finding scalars to match as well as possible a linear combination to data. An expression like \\(A e^{kx} + C\\) combines the exponential (obviously!) and a second function that isn’t immediately obvious: the constant function \\(\\text{constant}(x) \\equiv 1\\). It might be overkill to re-write the expression as \\(A e^{kx} + C\\, \\text{constant}(x)\\) but get in the habit of seeing the constant function as a constant presence in linear combinations! Polynomials are an important example of linear combinations. Something like \\(p(x) \\equiv a + b t + c t^2\\) is a linear combination of the constant function, the proportional function, and the square function. 7.5 Exercises Exercise 7.1: MWLCS Recall that each basic modeling function is constructed from the corresponding pattern-book function by scaling the input. \\[\\text{pattern-book function}\\ \\ \\underset{x\\rightarrow a(x-x_0)}{\\overset{\\text{input scaling}}{\\Large\\Longrightarrow}} \\ \\ \\text{basic modeling function}\\] Figure ?? shows the pattern-book functions with some added annotations. When the function has horizontal or vertical asymptotes, the location is shown by orange arrows. There is also a blue dot placed on the graph of functions with asymptotes. For functions without asymptotes, there are two blue dots. The location of the asymptotes and blue dots mark characteristic features of each function. The positions of the blue dot and asymptotes, or the positions of the two blue dots, are useful for figuring out the values of parameters in basic modeling functions. For example, the basic modeling reciprocal function is \\(g(x) \\equiv \\frac{1}{m (x-x_0)} + C\\). The parameter \\(C\\) will be the value where the horizontal asymptote crosses the vertical axis. The parameter \\(x_0\\) will be the value where the vertical asymptote crosses the horizontal axis. As for the parameter \\(m\\): find the input where the function value is \\(C+1\\). Let’s call that \\(x^\\star\\). The \\(m = 1/(x^\\star - x_0)\\). For the sinusoid, the blue dots mark the positive-going zero crossings of the baseline. The horizontal distance between the blue dots is the period parameter, \\(P\\). The horizontal position of either of the two dots tells the phase offset \\(x_0\\). Each of the following plots shows a basic modeling function whose input scaling has the form \\(x - x_0\\). Your job is to figure out from the graph what is the numerical value of \\(x_0\\). (Hint: For simplicity, \\(x_0\\) in the questions will always be an integer.) Question A In plot (A), what is \\(x_0\\)?     -2︎✘        -1︎✘        0︎✘        1︎✘        2\\(\\heartsuit\\ \\)Right. Look for the input that generates the peak output value. Question B In plot (B), what is \\(x_0\\)?     -2︎✘        -1\\(\\heartsuit\\ \\)The fiducial point is a positive-going zero crossing.       0︎✘        1︎✘        2︎✘ Question C In plot (C), what is \\(x_0\\)?     -2︎✘        -1︎✘        0︎✘        1\\(\\heartsuit\\ \\)The vertical asymptote is the clue.       2︎✘ Question D In plot (D), what is \\(x_0\\)? -2︎✘ -1︎✘ 0︎✘ 1Nice! The input where the output is half way between the two horizontal asymptotes 2︎✘ Question E In plot (E), what is \\(x_0\\)?     -2\\(\\heartsuit\\ \\)Right. The location of the vertical asymtote is the clue.       -1︎✘        0︎✘        1︎✘        2︎✘ Exercise 7.2: uKCIE Each of the graphs shows two horizontal scales and one of the basic modeling functions. Which horizontal scale (black or blue) corresponds to the pattern-book function? Question A For graph (A), which scale corresponds to the pattern-book function? blackCorrect.  blue︎✘ neither︎✘ both︎✘ It can’t be both. There’s only one pattern-book function. When you scale the input, it becomes a “basic modeling function”. Question B For graph (B), which scale corresponds to the pattern-book function? black︎✘ blueNice! Right. The pattern-book function has an output of 1/2 when the output is zero. That’s what the blue scale shows. neither︎✘ both︎✘ It can’t be both. There’s only one pattern-book function. When you scale the input, it becomes a “basic modeling function”. Question C For graph (C), which scale corresponds to the pattern-book function? black︎✘ blueCorrect. The pattern-book sinusoid has a positive-going zero crossing at \\(x=0\\). That’s the blue scale. neither︎✘ both︎✘ It can’t be both. There’s only one pattern-book function. When you scale the input, it becomes a “basic modeling function”. Exercise 7.3: BLECL Find the straight-line function that will give the value on the black scale for each point \\(x\\) on the blue scale. The function will take the blue-scale reading as input and produce the black-scale reading as output, that is: \\[\\text{black}(x) \\equiv a (x - x_0)\\] Question A For Graph A, which function maps blue \\(x\\) to the value on the black scale? $ ext{black}( ext{blue}) x$Excellent!  $ ext{black}( ext{blue}) , x$︎✘ You’re going the wrong way, from black to blue. $ ext{black}( ext{blue}) x + 3$︎✘ Is there a horiztontal shift? $ ext{black}( ext{blue}) x - 3$︎✘ Is there a horizontal shift? Question B For Graph B, which function maps blue \\(x\\) to the value on the black scale? $ ext{black}( ext{blue}) -,x$Nice!  $ ext{black}( ext{blue}) x$︎✘ Look carefully at the \\(\\pm\\) signs on the scales. $ ext{black}( ext{blue}) x$︎✘ Look carefully at the \\(\\pm\\) signs on the scales. $ ext{black}( ext{blue}) -x$︎✘ You’re going the wrong way, from black to blue. Question C For Graph C, which function maps blue \\(x\\) to the value on the black scale? $ ext{black}( ext{blue}) (x - 2)$Good. Good. An interval of length 4 on the blue scale (say, from 2 to 6) becomes an interval of length 2 on the black scale. So you know that blue to black involves dividing by 2. $ ext{black}( ext{blue}) , x$︎✘ Is there a shift $ ext{black}( ext{blue}) ,x$︎✘ Is there a shift? $ ext{black}( ext{blue}) ,(x + 2)$︎✘ You’re going the wrong way, from black to blue. Question D For Graph D, which function maps blue \\(x\\) to the value on the black scale? $ ext{black}( ext{blue}) (x + 3)$Excellent!  $ ext{black}( ext{blue}) (x - 3)$︎✘ $ ext{black}( ext{blue}) (x+1)$︎✘ $ ext{black}( ext{blue}) rac{3}{2}(x - 2)$︎✘ You’re going the wrong way, from black to blue. Exercise 7.4: ILESX Question A True or false: \\(2^x\\) is a power-law function. TRUE︎✘ In a power-law function, the input is the base. In \\(2^x\\), the input is the exponent. So it’s an exponential function. FALSEExcellent!  Question B True or false: \\(3/x^2\\) is a power-law function. TRUEGood.  FALSE︎✘ This is the same as \\(3 x^{-2}\\). You can see that \\(x\\) is the base, so this is a power-law function. Question C True or false: \\(5\\sqrt{x}\\) is a power-law function. TRUEGood.  FALSE︎✘ This is the same as \\(5 x^{1/2}\\). The input \\(x\\) is the base, so this is a power-law function. Question D The gravitational force, F, between two bodies is inversely proportional to the square of the distance \\(d\\) between them. Then … \\(F = k d^{2}\\)︎✘ Inversely proportional to the square would be \\(d^{-2}\\) \\(F = kd^{-2}\\)Correct.  \\(F = k d^{1/2}\\)︎✘ This is a square-root relationship. \\(F = k d^{-1/2}\\)︎✘ This is inversely proportional to the square root. Exercise 7.5: FKLEU The graph shows a linear combination of two sinusoids, one of period 0.6 and the other of period 2. There is also a baseline shift. That is, the graph shows the function: \\[A_1 \\sin\\left(\\frac{2\\pi}{2}t\\right) + A_2 \\sin\\left(\\frac{2\\pi}{0.6} (t-.3)\\right) + A_3\\] Question A What is \\(A_3\\)?     -4\\(\\heartsuit\\ \\)       -2︎✘        0︎✘        2︎✘        4︎✘ Question B What is \\(A_1\\)?     0︎✘        1︎✘        2\\(\\heartsuit\\ \\)       3.5︎✘ Question C What is \\(A_2\\)?     0︎✘        1\\(\\heartsuit\\ \\)       2︎✘        3.5︎✘ Called “imperial” because it was codified in an 1825 Act of the British parliament. Inches are imperial, but temperature isn’t part of the Act.↩︎ \\(-\\tau_2\\) is sometimes called the “half life.”↩︎ "],["process-of-modeling.html", "Chapter 8 Finding parameters for the basic modeling functions 8.1 Variations from scaling 8.2 Curve fitting a periodic function 8.3 Curve fitting an exponential function 8.4 Curve fitting a power-law function 8.5 Gaussian and sigmoid functions 8.6 Exercises", " Chapter 8 Finding parameters for the basic modeling functions Seen very abstractly, a mathematical model is a set of functions that represent the relationships between inputs and outputs. 900 At the most simple level, building a model can be a short process: Develop an understanding of the relationship you want to model. Often, part of this “understanding” is the pattern seen in data. Choose a function type—e.g. exponential, sinusoidal, sigmoid—that you think would be a good match to the relationship. Find parameters that scales your function to be able to accept real-world inputs and generate real-world outputs. It’s important to distinguish between two basic types of model: Empirical models which are rooted in observation and data. Mechanistic models such as those created by applying fundamental laws of physics, chemistry, and such. We are going to put off mechanistic models for a while, for two reasons. First, the “fundamental laws of physics, chemistry, and such” are often expressed with the concepts and methods of calculus. We are heading there, but at this point you don’t yet know the core concepts and methods of calculus. Second, most students don’t make a careful study of the “fundamental laws of physics, chemistry, and such” until after they have studied calculus. So examples of mechanistic models will be a bit hollow at this point. We’ll start then with empirical modeling: finding functions that are a good summary of data. The process of constructing a model that is a good match for data is called curve fitting, or, more generally, fitting a model. 8.1 Variations from scaling A good place to start building a model is to pick one of the basic modeling functions. This works surprisingly often. To remind you, here are our nine pattern-book functions: 910 Pattern name Traditional notation R notation exponential \\(e^x\\) exp(x) logarithm (“natural log”) \\(\\ln(x)\\) log(x) sinusoid \\(\\sin(x)\\) sin(x) square \\(x^2\\) x^2 proportional \\(x\\) x constant \\(1\\) 1 reciprocal \\(1/x\\) or \\(x^{-1}\\) 1/x gaussian \\(\\dnorm(x)\\) dnorm(x) sigmoid \\(\\pnorm(x)\\) pnorm(x) The basic modeling functions are the same, but replace the plain \\(x\\) in the pattern-book function with a straight-line function, for instance \\(ax + b\\) or, equivalently \\(a(x - x_0)\\). In use, the parameter \\(a\\) is often written with some other letter and, often, the \\(b\\) or \\(-x_0\\) part is not needed. Here are some of the common forms of the basic modeling functions you will encounter: Name Common forms note Exponential \\(e^{k t}\\) or \\(e^{-k t}\\) or \\(e^{-t/ \\tau}\\) Sinusoid \\(\\sin\\left(\\frac{2 \\pi}{P} (t-t_0)\\right)\\), \\(\\sin\\left(\\frac{2 \\pi}{P} t\\right)\\), or \\(\\sin(\\omega t)\\) \\(P\\) is “period”, \\(\\omega\\) is “angular frequency.” Monomials \\([x-x_0]\\) or \\([x-x_0]^2\\), and so on Power-law generally \\(x^p\\) or \\([x-x_0]^p\\) \\(p\\) is “power.” Gaussian \\(\\dnorm(x, mean, sd)\\) Interpret “mean” as “center.” Sigmoid \\(\\dnorm(x, mean, sd)\\) \\(sd\\) is “standard deviation” or “spread.” It helps in making the selection to have ready to mind the basic shape of each of these function families. To review, revisit Section 2.4. Remember also that, in general, we scale the inputs and scale the output. This means that in choosing a model family, we don’t have to worry at first about the numbers on the axes. (Of course, those numbers will be critically important later on in the process!) The scaling does, however, allow us to consider some variations on the shapes of the modeling functions. In particular, the input scaling lets us flip the shape right-for-left. And the output scaling lets us flip the shape top-for-bottom. \\(f(t)\\), basic shape \\(f(-t)\\), flipped right-for-left \\(-f(t)\\), flipped top-for-bottom \\(-f(-t)\\), flipped both top-for-bottom and right-for-left For functions such as the sinusoid, flipping is not much use, since the flipped sinusoid curve is still a sinusoid, although with a shifted input. Similarly, a right-for-left flipped gaussian function has the same shape as the original. For the straight-line function, flipping of either sort accomplishes the same thing: changing the sign of the slope. For the exponential function, the two possible types of flipping—right-for-left and top-for-bottom—produce four different curves, all of which are exponential, shown in Figure 8.1. Figure 8.1: Four variations of the exponential function. 8.2 Curve fitting a periodic function Figure 8.2 shows the tide level in Providence, Rhode Island, starting at midnight on April 1, 2020 and recorded every minute for four and a half days. (These data were collected by the US National Oceanic and Atmospheric Administration. Link) 960 Figure 8.2: About four days of tide-level data from Providence, Rhode Island It’s not too hard to see what’s going on. The tide rises and falls about every 12 hours. The difference between high tide and low tide is a little more than one meter. The tide gauge is calibrated so that a typical reading is 1 meter, although we don’t know what that is respect to. (Certainly not sea level, since then the typical reading would be around zero.) This simple description tells almost everything needed to match a basic modeling function to the tide level. Given the clear pattern in the data, we’ll use a sinusoid, that is, a function of the form \\[\\text{tide}(t) \\equiv A \\sin(2\\pi t/P) + B\\] The procedure is straightforward: Step 0: Determine whether a sinusoid model is appropriate. As you know, sinusoids oscillate up and down repeatedly with a steady period. That certainly seems the case here. But sinusoids are also steady in the peak and trough values for each cycle. That’s only approximately true in the Providence data. Models inevitably involve approximation. We’ll have to keep an eye on whether modeling with sinusoids and their fixed amplitude still lets us extract useful information. Step 1: Choose a sensible value to represent the low point repeatedly reached. 0.5 m seems appropriate here, but obviously the exact position of the trough of each cycle varies over the 4.5 day duration of the data. Similarly, the peak is near 1.6 m. Parameter \\(B\\) is the mean of the peak and trough values: \\(\\frac{1.6 + 0.5}{2} = 1.05\\) m here. Parameter \\(A\\) is half the difference between the peak and trough values: \\(\\frac{1.6 - 0.5}{2} = 0.55\\). Parameter \\(B\\) is called the baseline of the sinusoid. Parameter \\(A\\) is the amplitude. (Note that by convention, the amplitude is always half the high-to-low range of the sinusoid.) Step 2: Estimate the period \\(P\\) of the sinusoid. This can be done with the horizontal axis scale: measure the horizontal duration of a complete cycle. I like to use the time between peaks, but the time between troughs would work just as well. Another good choice is the time between positive sloping crossings of the baseline. (But be careful. The time between successive baseline crossings, one positive sloping and the other negative, give just half the period.) On the scale of the above plot, it’s hard to read off the time of the first peak. So, zoom in until it becomes more obvious. Figure 8.3: Zooming in on the start of the data (left) and on the last part of the data (right). The left panel in Figure 8.3 shows about 24 hours at the start of the record. The first peak is at about 6 hours, the second at about 19 hours. That indicates that the period is roughly 19 - 6 = 13 hours. Step 3 Plot out the model over the data. Replacing the symbols \\(A\\), \\(B\\), and \\(P\\) with our estimates, the model is \\[{\\color{magenta}\\text{tide}(t) \\equiv 1.05 + 0.55 \\sin(2\\pi t/13)}\\] Figure 8.4 shows this model in \\(\\color{magenta}\\text{magenta}\\). Figure 8.4: The sinusoid fails to align with the timing of peaks and troughs. Figure 8.4 shows the model aligning beautifully with the data at around time 80 hours, but not so well near the very beginning of the record. Looking carefully, you can see the magenta peak gradually move to the left compared to the data as you look at the peaks of the cycles one at a time moving backward from \\(t=80\\) hours. This is diagnostic of our 13-hour estimate for the period being a little too long. A good way to refine the estimate is to change the model slightly and re-graph the data and model. Keep doing this until you have found the right alignment. In other words, parameter estimation is often an iterative process of estimate-and-refine. This is one of the aspects of the modeling cycle, where a modeler builds a tentative model, looks for systematic deviations from the data, and refines the model. Another sort of deviation of the model from the data seen in Figure 8.4 concerns the varying heights of the peaks and troughs in the data, which is not captured by the simple sinusoid pattern. Perhaps you can see that at the beginning of the record, the troughs are also wider than the peaks. Later on, as this extra width disappears, the amplitude of the peaks and troughs increases. You don’t yet have the calculus tools or experience to know how or whether this phenomenon can be modeled. For now, a hint: Earth has two large orbiting bodies, the Sun and the Moon. These have slightly different periods: 24 hours for the Sun and slightly longer for the Moon. Step 4 Our model omitted one of the parameters of the sinusoid basic modeling function: the time shift \\(t_0\\). A more complete model would be: \\[\\text{tide}_\\text{shifted}(t) \\equiv A \\sin(2\\pi (t - t_0)/P) + B\\] Whether including this parameter is important depends on our purpose for the model. If the goal is to find the period of the tides, the time shift hardly matters. But if the goal is to predict a future tide level, the time shift is critical. Estimating \\(t_0\\) can only be done once the period \\(P\\) is known precisely. In practice, as you’ll see in Chapter 14, we use a numerical method called polishing to estimate both \\(P\\) and \\(t_0\\) at the same time. 8.3 Curve fitting an exponential function The exponential function is particularly useful when the quantity we want to model shows constant proportional increase. Many quantities in everyday life are this way. For instance, an increase in salary is typically presented in a format like “a 3% increase.” The population growth of a country is often presented as “percent per year.” Inflation in the price of goods is similarly described in percent per year. Interest on money in a bank savings account is also described as percent per year. But if you have the bad fortune to owe money to a loan shark, the proportional increase might be described as “percent per month” or “percent per week.” 920 When you know the “percent increase per time” of a quantity whose initial value is \\(A\\), the exponential function is easy to write down: \\[f(t) = A (1+r)^t\\] The number \\(r\\) is often called the interest rate or discount rate and is given in percent. Regrettably, it’s extremely easy and common to forget the rules for addition with percent. If \\(r = 5\\%\\), then \\((1+r) = 1.05\\), not 6. Always keep in mind that \\(5\\%\\) means \\(\\frac{5}{100}\\). Another source of error stems from the tradition in mathematics of using the number \\(e=2.718282\\) as the “natural” base of the exponential function, whereas in \\(f(t) = A (1+r)^t\\) the base is \\(1+r\\). You can translate an exponential \\(b^t\\) in any base \\(b\\) to the “natural” base. This is just a matter of calculating the appropriate parameter \\(k\\) such that \\(e^k = b\\). Using logarithms, \\[e^k = b\\ \\ \\implies \\ \\ k=\\ln(b)\\] For instance, if \\(r=5\\%\\) per year, we’ll have \\(k = \\ln(1+r) = \\ln(1.05) = 0.488\\) per year. Almost everybody is happier doing arithmetic with numbers like 2 and 10 rather than \\(e=2.718282\\). For this reason, you may see formulations of the exponential function as \\(g(t) \\equiv 2^{a t}\\) or \\(h(t) \\equiv 10^{c t}\\). Remember that \\(2^{a t}\\) and \\(e^{at}\\), although both exponential functions, are quantitatively different. If you want to write \\(2^{at}\\) using the “natural” base, it will be \\(e^{\\ln(2) a\\, t }\\). Similarly, \\(10^{ct} = e^{\\ln(10) c\\, t}\\). Exponential functions also describe decrease or decay. Just replace \\(t\\) with \\(-t\\). That is, a movie of a decreasing quantity is just the movie of an increasing quantity played backwards in time! 930 Figure 8.5 shows some data collected by Prof. Stan Wagon to support his making a detailed mechanistic model of an everyday phenomenon: The cooling of a mug of hot beverage to room temperature. The mug started at room temperature, which was measured at 26 degrees C. At time 0 he poured in boiling water from a kettle and measured the temperature of the water over the next few hours. Figure 8.5: Stan’s data Our task is to translate this data into the form of a function that takes time as input and returns temperature as output. Such a model would be useful for, say, filling in the gaps of the data. For instance, we might want to find the temperature of the water immediately after being poured from the kettle into the mug. Looking at the data, one sees that the temperature decreases along a curve: cooling fast at first and then more slowly. This is the pattern of the flipped right-for-left exponential. (Figure 8.1(B)) We can imagine then that an exponential, \\(A e^{kt} + C\\) will be a suitable model form for the cooling water. What remains is to find the parameters \\(A\\), \\(k\\), and \\(C\\). Here is a general process for curve-fitting an exponential. Later, we’ll apply this process specifically to the water-cooling situation. General process for curve-fitting an exponential The goal is to find the parameters \\(A\\), \\(k\\), and \\(C\\) in the formula \\(A e^{kx} + C\\). Step 0: Check that the data show an exponential pattern in one of its varieties, namely a smooth increase or decrease and leveling out beyond some value of \\(x\\). If this isn’t true, reconsider whether you should be using an exponential function in the first place. Using your mind’s eye (or paper, if you like) sketch out an exponential-shaped curve that follows the overall trend of the data. We’ll call this imagined curve \\(f(x)\\). Step 1: Find the baseline. This is the output level at which the function has a horizontal asymptote, that is, at which the function levels off. \\(C\\) is this baseline level. Step 2: Find the numerical value of the imagined function \\(f()\\) at input \\(x = 0\\). We’ll call this value \\(f(0)\\). Then \\(A \\equiv f(0) - C\\). Step 3 Estimate parameter \\(k\\) using these steps: Pick any input value, which we’ll call \\(x_2\\), such that \\(f(x_2)\\) is far from the baseline. Find an input value, which we’ll call \\(x_1\\) such that \\(f(x_1)\\) is halfway14 between the baseline \\(C\\) and \\(f(x_2)\\), that is \\[f(x_1) = \\frac{f(x_2) + C}{2}\\] Once you have \\(x_1\\) and \\(x_2\\), you can immediately find \\(k\\): \\[k = \\frac{\\ln(2)}{x_2 - x_1} \\approx \\frac{0.693}{x_2 - x_1}\\] Using this simple test to double-check your work. If the horizontal asymptote of \\(f()\\) (that is, approach to the baseline) is for \\(x \\rightarrow \\infty\\), then \\(k\\) should be negative. If the horizontal asymptote is for \\(x \\rightarrow - \\infty\\), then \\(k\\) will be positive. Notice that the question of “growth or decay” depends only on the sign of the parameter \\(k\\). You can have an exponentially decaying process that’s increasing. Consider, for instance, the speed of a car as it merges onto a highway from a slow speed on the entrance ramp. The car’s velocity is increasing, but as you approach highway speed the rate of increase gets smaller. That’s exponential decay. The procedure in Step 3 for estimating \\(k\\) stems from a very important property of exponential functions: Exponential functions always double/half at a constant pace. By design, the parameter \\(k\\) directly determines that pace. Picking an \\(x_2\\) and finding the corresponding \\(x_1\\) gives the length of the input interval, \\(x_1 - x_2\\) over which the distance from the baseline doubles/halves. What’s remarkable about the doubling/halving time is that, for a genuinely exponential function, it doesn’t matter which point we choose for \\(x_1\\). In practice working with graphed data, it’s best to choose so that \\(f(x_1)\\) is discernibly far from the baseline. The \\(2\\) in \\(\\ln(2)\\) corresponds to idea of doubling/halving. The logarithm converts \\(2\\) to a scale that will generate 2 when exponentiated. Step 4 If you can plot the data, do so. Add to that a graphics layer showing the function \\(A e^{k x} + C\\) using the values for \\(A\\), \\(C\\), and \\(k\\) that you just found. If you are not satisfied with the way the plotted function approximates the data, tweak the parameters a bit until you are. Exponential curve fitting applied to the water-cooling data Let’s illustrate the general process on the water-cooling data, redrawn in Figure 8.6. 950 ## `geom_smooth()` using method = &#39;loess&#39; Figure 8.6: The cooling-water data, repeated here for convenience. We’ve sketched in an exponential-like curve that matches the data pretty well. Step 0: The data indicate a smooth curve. As \\(t\\) gets large, the curve approaches a constant. So an exponential model is reasonable. Step 1: The curve looks like it’s leveling out at a temperature of about 25 degrees C for large \\(t\\). So \\(C \\approx 25^{\\circ} \\text{C}\\). Step 2: Looking at our imagined curve (sketched in blue in Figure 8.6), it appears to intersect the \\(t=0\\) vertical axis at about \\(f(0) = 85^\\circ\\text{C}\\). Thus, \\[A = 85^\\circ\\text{C} - 25^\\circ\\text{C} = 60^\\circ\\text{C}\\] Step 3: Now choose a time \\(t_2\\) where \\(f(t_2)\\) is far from the baseline. … It looks like \\(t_2 = 25\\) will do the job, at which point we can read off the graph that the function value is \\(f(25) \\approx 65\\). Find an input value \\(t_1\\) such that \\(f(t_1) -C = (f(t_2)-C)/2.\\) This tells us that \\(f(t_1) = 25 + (65-25)/2 = (65+25)/2 = 45\\). Referring to the graph, the time at which the function is about 45 is \\(t_1 \\approx 65\\), that is, \\(f(t_1) \\approx 65\\). We have \\(t_1 \\approx 65\\) and \\(t_2 = 25\\). From this, we calculate \\(k\\): \\[ k = \\frac{\\ln(2)}{25 - 65} = 0.693/(-40) = -0.0173\\] The data show exponential decay, so we expect \\(k\\) to be negative. Happily, it is. If it hadn’t been, we would go back to look for a sign error someplace. Step 4. Graph the function on top of the data to confirm the fitted function is a good match to the data. Figure 8.7: An exponential function that roughly aligns with the data. Step 5: The flat zone of the data is to the right. So we’ve got exponential decay and \\(k &lt; 0\\). 8.4 Curve fitting a power-law function You have been using power-law functions from early in your math and science education. Some examples: 970 Setting Function formula exponent Circumference of a circle \\(C(r) = 2 \\pi r\\) 1 Area of a circle \\(A(r) = \\pi r^2\\) 2 Volume of a sphere \\(V(r) = \\frac{4}{3} \\pi r^3\\) 3 Distance traveled by a falling object \\(d(t) = \\frac{1}{2} g t^2\\) 2 Gas pressure versus volume \\(P(V) = \\frac{n R T}{V}\\) \\(-1\\) … perhaps less familiar … Distance traveled by a diffusing gas \\(X(t) = D \\sqrt{ \\strut t}\\) \\(1/2\\) Animal lifespan (in the wild) versus body mass \\(L(M) = a M^{0.25}\\) 0.25 Blood flow versus body mass \\(F(M) = b M^{0.75}\\) 0.75 One reason why power-law functions are so important in science has to do with the logic of physical quantities such as length, mass, time, area, volume, force, power, and so on. We’ll discuss this at length later in the course and the principles will appear throughout calculus. As for finding the power law \\(f(x) \\equiv A x^p\\) that provides a good match to data, we’ll need some additional tools to be introduced in Chapter 15. 8.5 Gaussian and sigmoid functions Our last two basic modeling functions express an important idea in modeling: localness. To put this in concrete terms, imagine creating a function to depict the elevation above sea level of a long road as a function of distance in miles, \\(x\\), from the start of the road. If the road were level at 1200 feet elevation, a sensible model would be \\(\\text{elevation}(x) = 1200 \\text{ft}\\). If the road were gently sloping, a better model would be \\(\\text{elevation}(x) = 1200 + 0.01 x\\). 980 Now let’s add a bump to the road. A bump is a local feature, often only a few feet wide. Or, perhaps the road is crossing a mountain range. That’s also a local feature, but unlike a bump in the road a mountain range extends for many miles. The basic modeling function suited to represent bumps in the road, or potholes, or mountain ranges is generically called a “hump function.” In this book, we use a specific hump function called the gaussian function (dnorm()). A gaussian function has two parameters: the location15 of the peak, which we’ll call the center parameter, and the sideways extent of the gaussian, which is called the standard deviation. Figure 8.8 shows a few gaussian functions with different parameters. Figure 8.8: Gaussians with various centers and standard deviations (sd). It’s easy to read off the center parameter from a graph of a gaussian. It’s the location of the top of the function graph. (We mentioned before that a mathematical word for “the location of the top” is argmax; the value for the input of the function that produces the maximum output.) The spread parameter is also pretty straightforward, but you first have to become familiar with an unusual feature of the gaussian function. The output of the gaussian far from the center is practically zero. But it is not exactly zero. You can see from the graphs that the gaussian function has long flanks which approach zero output more or less in the manner of an exponential function. This means that we can’t measure the spread of the gaussian function by the distance between the zeros on either side of the peak. Instead, we need a convention that will allow us to be precise in quantifying what is admittedly a vague concept of width. Technically, the convention is that the spread is the length of the interval from the argmax to the inflection point. This can be hard to judge from a graph, but a reasonable approximation is that the spread is the “half-width at half-height.” Come down half-way from the peak value of the output. Panel (c) of Figure 8.8 marks that elevation with a thin, tan, horizontal line. Along that line, measure the width of the gaussian, as marked by the thick tan line in Panel (c). The spread parameter is half the width of the gaussian measured in this way. 990 If you have a keen eye, you’ll notice that the tan line in Figure 8.8 is not exactly half-way down from the peak. It’s down 39.35% from the peak. This corresponds exactly to the technical convention. Another seeming oddity about the gaussian function is the value of the maximum. It would have seemed natural to define this as 1, so-called “unit height.” The way it actually works is different: the maximum height is set so that the area under the gaussian function is 1. This business with the area will make more sense when you’ve learned some calculus tools, specifically “differentation” and “integration.” For now though … Consider another road feature, a local change from one elevation to another as you might accomplish with a ramp. The basic modeling function corresponding to a local change from one level to another is the sigmoid function. Figure 8.9 shows three sigmoid functions. Figure 8.9: Sigmoids with various centers and standard deviations The name “sigmoid” comes from vague resemblance of the graph to the letter S (which is “sigma” in Greek: ). The parameters of the sigmoid function are the same as for the gaussian function: center and width. The center is easy to estimate from a graph. It’s the value of the input that produces an output of 0.5, half-way between the max and min of the sigmoid. As with the gaussian function, the width is measured according to a convention. The width is the change in input needed to go from an output of 0.5 to an output of 0.8413. This use of 0.8413 must seem loony at first exposure, but there is a reason. We’ll need more calculus tools before it can make sense. Gaussian functions and sigmoid functions with the same center and width parameters have a very close relationship. The instantaneous rate of change of the sigmoid function is the corresponding gaussian function. Figures 8.8 and 8.9 show corresponding gaussian and sigmoid functions. To the very far left, the sigmoid function is effectively flat: a slope near zero. Moving toward the center the sigmoid has a gentle slope: a low number. In the center, the sigmoid is steepest: a higher number. Then the slope of the sigmoid becomes gentle again before gradually falling off to zero. Near zero, then low, then higher, then low again, then falling off to zero: that’s also the description of a gaussian function! In R, the name of the sigmoid function is pnorm(). The gaussian is dnorm(). The parameters that specify center and spread are named mean and sd. The word “mean” accurately conveys the idea of “center.” It would be nice to be able to say that sd comes from spread, but in fact sd is short for standard deviation, a term familiar to students of statistics. 1000 Figure 8.10 shows the cumulative number of Ebola cases during an outbreak in Sierra Leone from May 1, 2014 to December 16, 2015. Figure 8.10: Cumulative Ebola cases in Sierra Leone Although the cumulative case data are roughly sigmoidal in shape, there are systematic differences in shape from a true sigmoid. For comparison, Figure 8.11 is a graph of genuinely sigmoidal data. Figure 8.11: A simulated sigmoidal growth process. The Ebola data have only a rough similarity to the sigmoid shape. Still, fitting a model and then examining closely the deviations of the model from the data can prompt questions that can lead to a better understanding of the data and what’s needed in an appropriate model. Here’s a methodology for estimating the parameters mean and sd of a sigmoid graphically. Sketch in a S-shaped curve that smoothly follows the data. In Figure 8.11 this has already been done for you. For the Ebola data, you will have to use your judgment. Find the top plateau of the S-curve. This is indicated by the tan line in Figure 8.11. The parameter A is simply the height of the plateau, in this case \\(y \\approx 15\\). Come down half way from the plateau. Here, that’s 15/2 or 7.5, indicated by the horizontal blue line segment. Find the inverse of the S-curve from that half-way point onto the horizontal-axis. Here, that gives \\(t \\approx 5\\). The parameter center is that value. From the center of the S-shaped curve, follow the curve upward about 2/3 of the way to the plateau. In the diagram, that point is marked with a green line at \\(t \\approx 7\\). The width is the distance along the horizontal axis from the blue centerline to the green line. Here, that’s \\(7 - 5\\) giving 2 as the width. You might also want to trace the S-curve downward from the centerline about 2/3 of the way to zero. That’s indicated by the left green line. In the standard sigmoid, the two green lines will be equally spaced around the centerline. Of course the data may not be in the shape of the standard sigmoid, so you might find the two green lines are not equally spaced from the center. 8.6 Exercises Exercise 8.1: 0rvpbu These three expressions \\[e^{kt}\\ \\ \\ \\ \\ 10^{t/d} \\ \\ \\ \\ \\ 2^{t/h}\\] produce the same value if \\(k\\), \\(d\\) and \\(h\\) have corresponding numerical values. The scaffolding has an expression for plotting out \\(2^{t/h}\\) for \\(-4 \\leq t \\leq 12\\) where \\(h = 4\\). It also plots out \\(e^{kt}\\) and \\(10^{t/d}\\) fa &lt;- makeFun(exp(k*t) ~ t, k = 4) fc &lt;- makeFun(2^(t/h) ~ t, h = 4) fb &lt;- makeFun(10^(t/d) ~ t, d = 4) slice_plot(fa(t) ~ t, domain(t = c(-4, 12))) %&gt;% slice_plot(fb(t) ~ t, color=&quot;blue&quot;) %&gt;% slice_plot(fc(t) ~ t, color = &quot;red&quot;) %&gt;% gf_lims(y = c(0, 8)) Your task is to modify the values of d and k such that all three curves lie on top of one another. (Leave h at the value 4.) You can find the appropriate values of d and k to accomplish this by any means you like, say, by using the algebra of exponents or by using trial and error. (Trial and error is a perfectly valid strategy regardless of what your high-school math teachers might have said about “guess and check.” The trick is to make each new guess systematically based on your previous ones and observation of how those previous ones performed.) After you have found values of k and d that are suited to the task … Question A What is the numerical value of your best estimate of k?     0.143︎✘        0.173\\(\\heartsuit\\ \\)       0.283︎✘        0.320︎✘ Question B What is the numerical value of your best estimate of d?     11.2︎✘        11.9︎✘        13.3\\(\\heartsuit\\ \\)       15.8︎✘ Exercise 8.3: YLWP1 Question A One of the curves in plot (A) is a pattern-book function. Which one?     black\\(\\heartsuit\\ \\)It’s the exponential function.       blue︎✘        green︎✘        tan︎✘        none of them︎✘ Question B Taking \\(f()\\) to be the pattern-book function in plot (A), which one of the curves is \\(f(-x)\\)?     black︎✘        blue︎✘        green︎✘        tan\\(\\heartsuit\\ \\)       none of them︎✘ Question C One of the curves in plot (B) is a pattern-book function. Which one?     black︎✘        blue︎✘        green︎✘        tan\\(\\heartsuit\\ \\)       none of them︎✘ Question D Taking \\(f()\\) to be the pattern-book function in plot (B), which one of the curves is \\(-f(x)\\)?     black︎✘        blue\\(\\heartsuit\\ \\)       green︎✘        tan︎✘        none of them︎✘ The blue curve in plot (C), as you know, is the sinusoid pattern-book function. Question E Which of these functions is the green curve? \\(\\sin(-x)\\)︎✘ \\(-\\sin(x)\\)︎✘ \\(-\\sin(-x)\\)︎✘ Both \\(\\sin(-x)\\) and \\(-\\sin(-x)\\)︎✘ Both \\(\\sin(-x)\\) and \\(-\\sin(x)\\)Excellent! The sine function has so-called “odd” symmetry around \\(x=0\\). Question F One of the curves in plot (D) is a pattern-book function. Which one?     black︎✘        dodgerblue︎✘        green\\(\\heartsuit\\ \\)       tan︎✘        none of them︎✘ Question G Taking \\(f()\\) to be the pattern-book function in plot (D), which one of the curves is \\(-f(-x)\\)?     black\\(\\heartsuit\\ \\)       dodgerblue︎✘        green︎✘        tan︎✘        none of them︎✘ Exercise 8.5: YELXG A person breathes in and out roughly every three seconds. The volume \\(V\\) of air in the person’s lungs varies between a minimum of \\(2\\) liters and a maximum of \\(4\\) liters. Assume time \\(t\\) is measured in seconds. Remember that a full cycle of the sine wave \\(\\sin(x)\\) involves \\(x\\) going from its starting value to that value plus \\(2 \\pi\\). Question A Which of the following is the most appropriate of these models for \\(V(t)\\)? \\(V(t) \\equiv 2 \\sin \\left( \\frac{\\pi}{3} t \\right) + 2\\)︎✘ This varies between a minimum of 0 and a maximum of 2. \\(V(t) \\equiv \\sin \\left( \\frac{2\\pi}{3} t \\right) + 3\\)Right! Good. In this class, we generally write the sine function like \\(\\sin(2 \\pi t/P)\\) which means that the overall argument to the sine function will go from 0 to \\(2 \\pi\\) when \\(t\\) goes from 0 to \\(P\\). \\(V(t) \\equiv 2 \\sin \\left( \\frac{2\\pi}{3} t \\right)+ 2\\)︎✘ This varies between a minimum of 0 and a maximum of 2. \\(V(t) \\equiv \\sin \\left( \\frac{\\pi}{3} t \\right) + 3\\)︎✘ Right amplitude and baseline: the minimum will be 2 liters and the maximum 4 liters. But the period is wrong. Going from \\(t=0\\) to \\(t=3\\) should produce a full cycle of the sine function. But here the argument would go only from 0 to $ 3 = \\(\\pi\\). After 3 seconds, only half a cycle has been completed. A respiratory cycle can be divided into two parts: inspiration and expiration. Please do an experiment. Using a clock or watch, breath with a total period of 3 seconds/breath, that is, complete one breath every three seconds. Once you have practiced this and can do it without forcing either phase of breathing, make a rough estimate of what fraction of the cycle is inspiration and what fraction is expiration. (The “correct/incorrect” answers here are right for most people. Your natural respiration might be different.) Question B Which is true? Inspiration lasts longer than expirationRight!  Expiration lasts longer than inspiration︎✘ Maybe it is for you, but not for most people. Try breathing in while counting 1-2-3 then exhaling while counting 1-2-3-4-5-6. Likely, that’s not a very natural pattern for you. Inspiration and expiration each consume about the same fraction of the complete cycle.︎✘ People can do this consciously by counting 1-2-3 for inspiration and another 1-2-3 for expiration. This usually feels forced and unnatural. Exercise 8.7: VBWD The graph below shows a recording from a “spirometer,” an instrument for recording respiration. Like many old instruments, the trace from this spirometer is made by a pen at the end of a swinging arm with paper moving steadily beneath it. The arm is not exactly aligned with the horizontal axis. Nonetheless, you should be able to estimate an appropriate amplitude and period for the trace. (dm\\(^3\\) is cubic-decimeters: a tenth of a meter cubed. This is the same as a liter.) Question A What are appropriate estimates for the period and amplitude of the respiration trace? About \\(\\pm 1\\) liter and 3 seconds.︎✘ If this were true, over the 120 seconds of the recording you would expect to see 40 cycles of respiration. About \\(\\pm 1\\) liter and 5 seconds.Right!  About \\(\\pm 1\\) liter and 7.5 seconds.︎✘ If this were true, you would expect to see about 16 cycles of respiration over 120 seconds of recording. Exercise 8.9: vkwl4 The Bargain Basement store wants to sell its goods quickly. Consequently, they reduce each product’s price \\(P\\) by 5% per day. Question A If a jacket costs $80 today, how much will it cost in \\(t\\) days? \\(P = 80 - 5t\\)︎✘ Remember, 5 percent is exactly the same as 0.05 \\(P = 80 - 4t\\)︎✘ Remember, 4 percent is exactly the same as 0.04 \\(P = 80 - 0.05t\\)︎✘ This would be a decrease in price by 5 cents every day. \\(P = 80 (0.05)^t\\)︎✘ Each day’s price would be only 5% that of the previous day’s price. \\(P = 80 (0.95)^t\\)Correct.  You’ll need to open a sandbox for the next question. You’re on your own here! Remember, to raise a number to a power, you can use an expression like 0.95^7. Question B You decided that you like the $80 jacket, but you have a budget of only $60. How long should you wait before coming back to the Bargain Basement store.? 3 days︎✘ On day 3 the price will be \\(0.95\\times 0.95 \\times 0.95 \\times 80\\). That’s above your budget. 4 days︎✘ On day 4 the price will be \\(80 \\times 0.95^4\\)= $65.16. Too much! 5 days︎✘ On day 5 the price will be \\(80 \\times 0.95^5\\)= $61.90. Close, but still higher than your budget. 6 daysNice!  Exercise 8.11: asevss The Wikipedia entry on “Common Misconceptions” used to contain this item: Some cooks believe that food items cooked with wine or liquor will be non-alcoholic, because alcohol’s low boiling point causes it to evaporate quickly when heated. However, a study found that some of the alcohol remains: 25% after 1 hour of baking or simmering, and 10% after 2 hours. The modeler’s go-to function type for events like the evaporation of alcohol is exponential: The amount of alcohol that evaporates would, under constant conditions (e.g. an oven’s heat), be proportional to the amount of alcohol that hasn’t yet evaporated. Question A A) Assume that 25% of the alcohol remains after 1 hour? If the process were exponential, how much would remain after 2 hours? 10%︎✘ That’s what the study is reported to have found, but that’s not consistent with an exponential process that decays to 25% after one hour 25%︎✘ Exponentials decay to zero eventually, so don’t expect things to stay still after one hour. 25% of 25%Nice! We know that 75% is eliminated over 1 hour, leaving 25%. The continuing exponential process will, over the next hour eliminate 75% of the amount at the start of that hour. So after hour 2 we’ll have 25% of the amount we had at hour 1, which was 25% of the original amount. 75%︎✘ That’s how much was eliminated in the first hour, not how much remains after 2 hours. 75% of 75%︎✘ In an exponential process, at any moment the rate of decay (e.g. 75% per hour) is a constant proportion of the amount that is still there. After one hour, there is 25% of the alcohol remaining. That will decay at a rate of 75% per hour. Over the next hour, we’ll lose 75% of the original 25%, giving us 25% of the original amount. Question B B) What is the half-life of an exponential process that decays to 25% after one hour? 15 minutes︎✘ This provides time for four halvings in one hour, which would leave \\(\\frac{1}{2} \\times \\frac{1}{2} \\times \\frac{1}{2} \\times \\frac{1}{2} = 1/16\\) of the original not 1/4. 30 minutesExcellent! This gives time for two halvings in one hour, bringing us to 25% as observed. 45 minutes︎✘ Two halvings bring us down to 25%. At this rate, it would take 90 minutes to get down to 25%, not 60 minutes as observed. none of the above︎✘ Let’s change pace and think about the “10% after 2 hours” observation. First, recall that the amount left after \\(n\\) halvings is \\(\\text{amount.left}(n) \\equiv \\frac{1}{2}^n\\) This is an exponential function with base 1/2. You’re going to carry out a guess-and-check procedure to find \\(n\\) that gives \\(\\text{amount.left}(n) = 0.10\\). Open a sandbox and copy over the scaffolding, which includes the definition of the amount.left() function. We started with a guess of \\(n=0\\), which is wrong. Change the guess until you get the output 10%. amount.left &lt;- makeFun((1/2)^n ~ n) amount.left(0) Question C C) Use amount.left() as defined in the scaffolding to guess-and-check how many halvings it takes to bring something down to 10% of the original amount.     2.58︎✘        3.32\\(\\heartsuit\\ \\)       3.62︎✘        3.94︎✘        4.12︎✘ Another way to find the input \\(n\\) that generates an output of 10% is to construct the inverse function to \\(\\text{amount.left}()\\). The computer already provides you with inverse functions for \\(2^n\\) and \\(e^n\\) and \\(10^n\\). Their names are log2(), log(), and log10() repectively. Using log2(), write a function named log_half() that gives the inverse function to \\((1/2)^n\\). Remember, the input to the inverse function corresponds to 10%; the output to the \\(n\\). log_half &lt;- makeFun( - log2(...your stuff here ...) ~ x) Question D D) The answer you got in part C) is the number of halvings needed to reach 10%. If this number occurs in 2 hours (that is, 120 minutes), what is the half life stated in minutes.     30︎✘        35︎✘        36\\(\\heartsuit\\ \\)       38︎✘        42︎✘        47︎✘ Suppose you compromise between the half-life needed to reach 25% after one hour and the half-life needed to reach 10% after two hours. Use, say, 33 minutes as the compromise half life. Using the sandbox, calculate how much would be left after 1 hour for this compromise half life, and how much left after 2 hours. Question E E) How much is left after 1 hour and after 2 hours when the half life is 33 minutes?     28% and 8%\\(\\heartsuit\\ \\)       31% and 4%︎✘        30% and 9%︎✘        27% and 9%︎✘ Exercise 8.13: IELWV The gaussian function is implemented in R with dnorm(x, mean, sd). The input called mean corresponds to the center of the hump. The input called sd gives the width of the hump. In a sandbox, make a slice plot of dnorm(x, mean=0, sd=1). By varying the value of width, figure out how you could read that value directly from the graph. slice_plot(dnorm(x, mean=0, sd=1) ~ x, domain(x = c(-4, 4))) In the plot below, one of the double-headed arrows represents the width parameter. The others are misleading. Question A Which arrow shows correctly the width parameter of the gaussian function in the graph with arrows?     top\\(\\heartsuit\\ \\)       middle︎✘        bottom︎✘        none of them︎✘ Question B What is the value of center in the graph with arrows? -2︎✘ The center parameter is the argmax of the function. -1︎✘ The center parameter is the argmax of the function. -0.5︎✘ The center parameter is the argmax of the function. 0︎✘ The center parameter is the argmax of the function. 0.5Right!  1︎✘ The center parameter is the argmax of the function. 2︎✘ The center parameter is the argmax of the function. Exercise 8.15: CKSLE Gaussian functions and sigmoidal functions come in pairs. For every possible sigmoid, there is a corresponding gaussian that gives, for each value of the input, the slope of the sigmoid. Each of the following graphs shows a sigmoid and a gaussian function. The two might or might not correspond to one another. That is, the output of the gaussian might be the slope of the sigmoid, or the gaussian might correspond to some other sigmoid. Remember, you’re comparing the output of the gaussian to the slope of the sigmoid. For each graph, say whether the gaussian and the sigmoid correspond to one another. If not, choose one of the reasons why not. Question A Graph (A) The gaussian and sigmoid correspond.Excellent!  The peak of the gaussian does not occur at the same value of \\(x\\) at which the sigmoid is steepest.︎✘ For what \\(x\\) is the sigmoid the steepest? For what \\(x\\) is the gaussian the highest? The numerical value of the output of the gaussian function is, for all \\(x\\), much larger than the numerical value of the slope of the sigmoid.︎✘ Did you calculate the numerical value of the slope of the sigmoid? Question B Graph (B) The gaussian and sigmoid correspond.︎✘ The peak of the gaussian does not occur at the same value of \\(x\\) at which the sigmoid is steepest.Nice! The gaussian peaks at about \\(x=2\\) while the steepest part of the sigmoid is at about \\(x=4\\) The numerical value of the output of the gaussian function is much larger than the numerical value of the slope of the sigmoid.︎✘ Did you calculate the numerical value of the slope of the sigmoid? Question C Graph (C) The gaussian and sigmoid correspond.Nice!  The peak of the gaussian does not occur at the same value of \\(x\\) at which the sigmoid is steepest.︎✘ For what \\(x\\) is the sigmoid the steepest? For what \\(x\\) is the gaussian the highest? The numerical value of the output of the gaussian function is, for all \\(x\\), much larger than the numerical value of the slope of the sigmoid.︎✘ Did you calculate the numerical value of the slope of the sigmoid? In the graph D, there are several gaussian functions shown, only one of which corresponds to the sigmoid. Question D Which gaussian corresponds to the sigmoid? A︎✘ The value of the gaussian output is much larger than the slope of the sigmoid. BRight! Right! The gaussian is centered on the steepest part of the sigmoid and falls to zero where the sigmoid levels out. C︎✘ The gaussian is too narrow. D︎✘ The gaussian is too broad and shifted to the left. Exercise 8.17: bllKR Have in mind a gaussian function and a sigmoid function that form a corresponding pair. Question A Which of these stories is consistent with the relationship between a gaussian and its corresponding sigmoid? The gaussian is the amount of water in a bathtub while the sigmoid is the time you spend in the bath.︎✘ The gaussian is the amount of water in the bathtub while the sigmoid is the rate at which water flows from the tap.︎✘ You turn the tap on and off after a while. That’s not what the sigmoid looks like. The gaussian is the rate at which water flows from the tap and the sigmoid is the amount of water in the bathtub.Right!  The gaussian indicates the amount the drain is open and the sigmoid is the amount of water in the bathtub.︎✘ Shouldn’t the amount of water go down when the drain is open? Exercise 8.19: YLWP2 Each of the curves in the graph is an exponential function \\(e^{kt}\\), for various values of \\(k\\). Question A What is the order from \\(k\\) smallest (most negative) to k largest? black, orange, red, green, blueGood. Exponential functions that grow slowly have \\(k\\) with a small absolute value black, orange, blue, green, red︎✘ Sorry. Notice the red curve grows the most slowly. This means it has the smallest \\(|k|\\). red, green, blue, orange, black︎✘ The orange and black curves have negative \\(k\\), so they will be smaller than the other curves with positive sign. Exercise 8.21: EKCIE Put aside for the moment that the Ebola data plotted in Figure 8.10 doesn’t look exactly like the standard sigmoid function. Follow the fitting procedure as best you can. Question A Where is the top plateau? About Day 600.︎✘ Measure the height of the plateau, not where it starts horizontally. About 14,000 casesExcellent!  About 20,000 cases︎✘ Read the vertical axis markings more carefully. None of the above︎✘ One of the above answers is pretty good. Question B Where is the centerline? Near Day 200Good.  Near Day 300︎✘ That’s the center of the vertical scale, not the day at which the curve reaches half-way to the eventual plateau. At about 7000 cases︎✘ That’s half-way up to the plateau, but the answer you want is the day at which the curve reaches that point. Question C Now to find the width parameter. The curve looks more classically sigmoidal to the left of the centerline than to the right, so follow the curve downward as in Step 4 of the algorithm to find the parameters. What’s a good estimate for width? About 50 daysCorrect.  About 100 days︎✘ Too wide! About 10 days︎✘ Too small About 2500 cases︎✘ The width is measured along the horizontal axis, not the vertical The motivation for the equation is that the distance between \\(f(x_1)\\) and \\(C\\) should be half that of the distance between \\(f(x_2)\\) and \\(C\\). In other words, \\[f(x_1) - C = \\frac{f(x_2) - C}{2}\\] Simplifying the algebra a little tells you to look for \\(x_1\\) such that \\[f(x_1) = \\frac{f(x_2) + C}{2}\\]↩︎ That is, the input value at which the function value is largest.↩︎ "],["fun-slopes.html", "Chapter 9 Slope function 9.1 Change and slope 9.2 Continuous change 9.3 Slope 9.4 The fitted line 9.5 Average rate of change 9.6 Instantaneous rate of change 9.7 Exercises", " Chapter 9 Slope function For our purposes, the definition of calculus is 1100 The use of functions to model and explore continuous change The agenda of this chapter is to give specific mathematical meaning to the word “change.” 9.1 Change and slope You have an solid, intuitive sense of what “change” means. In mathematics, and especially the mathematics of functions, change has a very simple meaning that you have already touched on in your previous math education. The word that encapsulates “change” in high-school math is slope. For instance, you’ve undoubtedly had to calculate the slope of a straight line in a graph. You learned about “rise” and “run” and how to read them from a graph or from a formula. The slope is the ratio: rise over run. Everyone has a intuitive sense of the slope of a road or of a hillside. You learned to apply this intuition to reading graphs and the slope of a line. We’ll exploit the intuitive ability to read a landscape in order to introduce abstract mathematical ideas in a down-to-earth setting. But you should learn to think of “slope” abstractly, not just as referring to the incline of a road. For instance, the population of a country can change, as can the number of new cases of an epidemic disease, the temperature of a cup of coffee, or the distance from Earth of a spacecraft. A major part of learning calculus is generalizing and abstracting the mathematical concept of which “slope” is an example and becoming proficient with mathematical procedures for working with change. 9.2 Continuous change Most people are comfortable with the ideas of daily changes in temperature or monthly changes in credit-card debt or quarterly changes in the unemployment rate or annual changes in the height of a child. Such things are easy to record in, say, a spreadsheet. For example, as this paragraph is being written, the weather forecast for the next several days (in southeastern Colorado in mid-May) is 1110 Day High Low Description Thursday 73 43 sunny Friday 72 48 windy Saturday 66 48 thunderstorms Sunday 68 43 windy Monday 70 39 sunny Tuesday 70 43 sunny Wednesday 66 45 partly cloudy Such data is said to be discrete. The day is listed, but not the time of day. The high temperature is forecast, but not the time of that high. The “description” is also discrete, one of the several words that are used to summarize the quality of the weather, as opposed to the quantity of rain. Calculus is about continuous change. For instance, if the weather bureau provide a web interface that let me enter the date and time to the nearest fraction of a second, they would be giving a way to track the change continuously. Many physical processes are intrinsically continuous, for instance the motion (change in position) of a spacecraft or the height of the tide or the stress on a tree as a function of wind velocity. Finding a language to describe continuous change—famously, the position of the moon or planets in their orbit, or the speed of a ball rolling down a ramp—was central to the emergence of what historians call the “Age of Enlightenment” or “modern scientific method.” The first complete presentation of that language was published by Isaac Newton based on his work in the 1660s. As you might guess, the name of the language is “calculus.” 9.3 Slope You already know pretty much everything there is to know about the straight-line function, Formula: \\(f(x) \\equiv a x + b\\). The parameters \\(a\\) and \\(b\\) are the “slope” and “intercept” respectively. (More precisely, \\(b\\) is the “y-intercept.” But in statistics and modeling, it’s just the “intercept.”) Reading parameters from a graph: You learned several ways to do this which are all equivalent. Maybe the easiest is to read the y-intercept off the graph. That’s \\(b\\). Then choose some non-zero \\(x_0\\) and read off from the graph the value of \\(f(x_1)\\). The slope is simply \\[\\frac{f(x_0) - b}{x_0}\\] The y-intercept method is a special case of a more general method, the two-point method, that you can use even if the y-intercept isn’t shown on the graph. Pick two specific values of \\(x\\), which we’ll call \\(x_0\\) and \\(x_1\\). Evalate the function at these input values and compute the rise over run: \\[\\text{rise over run} \\equiv \\frac{f(x_1) - f(x_0)}{x_1 - x_0}\\] The rise over run is the slope of the straight line. The y-intercept method is exactly the same as the two-point method with \\(x_1 = 0\\). Matching a straight-line function to data: You might not have been taught this formally, but the basic process is easy to imitate. The process is called line fitting or, in statistics and other fields, linear regression. 1120 9.4 The fitted line To illustrate line fitting, let’s return to the cooling mug of water. Figure 9.1 shows the data along with a dozen candidate straight line functions, each one drawn in its own color. Figure 9.1: Some candidate straight-line function models plotted on top of the cooling water data. Which one(s) would you pick as good matches to the data? Some of the straight-line models are a much better match to the data than others. The blue-shaded functions are pretty good fits, at least when you consider the limitations of matching data with a curved pattern by a straight line. The green-colored functions are maybe OK but not as good as the blue, and the purple-shaded functions are just horrible. Now that you know what a reasonable straight-line model looks like, you will find it pretty easy to draw one on data graphics that even remotely show a straight-line pattern. Step 1: Draw a reasonable straight-line through the data points. Step 2: Find the parameters that correspond to the line you drew. 9.5 Average rate of change Since the slope is our standard way of representing a relationship of change, we will often use it as a way of summarizing a function. To illustrate, consider the exponential model we constructed to match the cooling-water data in Section 8.3: 1130 water &lt;- makeFun(60*exp(-0.0173*t) + 25 ~ t) Figure 9.2: The exponential function that was previously matched to the cooling-water data. The slope of the straight line connecting two points on the function graph is the average rate of change during the interval. During the interval \\([t_0, t_1]\\) the rate at which the water cools is higher at first and lower at the end. The average rate of change is a single number that summarizes the whole interval. For all except straight-line models, the average rate of change depends on the interval chosen. “Slope” is a natural metaphor when thinking of a function as a graph. But a more general way to describe the concept is the rate of change of the output with respect to the input. The change in the output from one end of the interval is \\(f(x_1) - f(x_0)\\), the change in the input is \\(x_1 - x_0\\). If the input is time (in hours), and the output is the position of a car (in miles), then the rate of change is miles-per-hour: the car’s velocity. For a straight-line function—think of a car driving at constant speed on a highway—it doesn’t matter what you choose for \\(x_1\\) and \\(x_0\\) (so long as they are not identical). But for other functions, the choice does matter. Imagine a graph of the position of a car along a road as in Figure 9.3. Over the course of an hour, the car travelled about 25 miles. In other words, the average speed is 25 miles/hour: the slope of the tan line segment. Given the traffic, sometimes the car was stopped (time C), sometimes crawling (time D) and sometimes much faster than average (time B). Figure 9.3: The position of an imaginary car over time (black curve). The average rate of change over various intervals is the slope of the straight-line segment connecting the start and end of the black curve in that interval. During the interval from B to C, the car was travelling relatively fast. The slope of the \\(\\color{magenta}{\\text{magenta}}\\) segment connecting the position at times B and C is the average rate of change between times B and C. It’s easy to see that the average rate of change from B to C is larger than the overall average from \\(t=0\\) to \\(t=1\\). Calculating that slope is a matter of evaluating the position at the endpoints and dividing by the length of the interval. 1140 What is the average rate of change in the car’s position during the interval \\(t_B = 0.40\\) to \\(t_C=0.54\\)? The length of the interval is \\(t_C - t_B = 0.54-0.40=0.14\\). Evaluating the function gives \\(x(t_C) = 18\\) and \\(x(t_B) = 12.6\\). Rise is \\(x(t_C) - x(t_B) = 18 - 12.6 = 5.4\\). Run is \\(t_C - t_B = 0.54-0.40=0.14\\). The average rate of change during the interval is \\(5.4/0.14 = 38.6\\) miles/hour. Figure 9.4 shows a simplified model of the amount of usable wood that can be harvested from a typical tree in a managed forest of Ponderosa Pine. (You can see some actual forestry research models here.) 1145 Figure 9.4: A model, somewhat realistic, of the amount of wood that can be harvested from a Ponderosa Pine as a function of years since planting to harvest. You are writing a business plan for a proposed pine forest. Among other things, you have to forecast the revenue that will be generated and when you will have saleable product. They say that “time is money.” Every year you wait before harvest is another year that you don’t have the money. On the other hand, every year that you wait means more wood at the end. How to decide when to harvest? The tree continues to grow until year 50, when it seems to have reached an equilibrium: perhaps growth goes to zero, or rot balances what growth there is. There’s no point waiting until after year 50. At year 25, the tree is growing as fast as it ever will. You’ll get about 600 board-feet of lumber. Should you harvest at year 25? No! That the tree is growing so fast means that you will have a lot more wood at year 26, 27, and so on. The time to harvest is when the growth is getting smaller, so that it’s not worth waiting an extra year. The quantity of interest is the average rate of growth from seedling to harvest. Harvesting at year 25 will give a total change of 600 board feet over 25 years, giving an average rate of change of \\(600 \\div 25 = 24\\ \\text{board-feet-per-year}\\). But if you wait until year 35, you’ll have about 900 board feet, giving an average rate of change of \\(900 \\div 35 = 25.7\\ \\text{board-feet-per-year}\\). It’s easy to construct a diagram that shows whether year 35 is best for the harvest. Recall that our fundamental model of change is the straight-line function. So we’re going to model the model of tree growth as a straight line function. Like the more realistic model, our straight-line model will start out with zero wood at the time of planting. And to be faithful to the realistic model, we’ll insist that the straight-line intersect or touch the realistic model at some point in the future. Figure 9.5 reiterates the realistic model of the tree but adds on to it several straight-line models that all give zero harvest-able wood at planting time. Each of the green lines captures a scenario where the tree is harvested at the indicated time: \\(t_1\\), \\(t_2\\), and so on. For the perspective of representing the rate of growth per year from planting to harvest, the straight-line green models do not need to replicate the actual growth curve. The complexities of the curve are not relevant to the growth rate, which can be simplified down to a straight-line model connecting the output at planting time to the output at harvest time. In contrast, the \\(\\color{magenta}{\\text{magenta}}\\) curve is not a suitable model because it doesn’t match the situation at any harvest time; it doesn’t touch the curve anywhere after planting! Figure 9.5: Modeling the tree-growth model with straight lines connecting planting time to various harvest times. The slope of each line is the average rate of growth for that planting time. To maximize average lumber volume per year, choose a harvest time that produces the steepest possible green segment. From Figure 9.5 this is the model that glances the growth curve near year 31 (shown as \\(t_3\\) in the diagram). It’s best to find the argmax by creating a function that shows explicitly what one is trying to optimize. (In Chapter ?? we’ll use the name objective function to identify such function.) Here, the objective function is \\(\\text{ave.growth(year)} \\equiv \\text{volume(year)} / \\text{year}\\). See Figure 9.6. Figure 9.6: Graph of the average-growth function ave_growth(year), constructed by dividing volume(year) by year. The graph of ave_growth(year) makes it clear that the maximum average growth from planting to harvest will occur at about year 32. 9.6 Instantaneous rate of change The average rate of change is the slope of a line segment connecting two points on the graph of a function, the points \\(\\left(\\strut t_0, f(t_0)\\right)\\) and \\(\\left(\\strut t_1, f(t_1)\\right)\\). It reflects all the point-to-point changes in the value of the function over the interval \\(t_0\\) to \\(t_1\\) in the function’s domain. It turns out to be helpful to consider the rate of change of a function at an individual point \\(t_0\\) in the domain, rather than the interval between two points. This rate of change at a point is called the instantaneous rate of change. In Block 2, we’ll see that a good way to define an instantaneous rate of change at \\(t_0\\) is as the average rate of change over the interval \\(t_0 \\leq t \\leq t_0 + h\\) with the proviso that the interval length \\(h\\) goes as closely as it can to zero. Visually, this is the line that’s tangent to the function’s graph at the input value \\(t_0\\) as in Figure 9.7. 1150 Figure 9.7: A line tangent to a the curve at a single point. The slope of this line is the instantaneous rate of change. It’s convenient to be able to find the slope of such a tangent line using just the definition \\(f(t)\\), rather than having to draw a graph and eyeball the tangent. For now, let’s approximate the slope of tangent line by the average rate of change over a small run from \\(t_0\\) to \\(t_0 + 0.1\\): \\[\\text{slope of}\\ f(t) \\ \\text{at}\\ t_0 \\approx\\frac{f(t_0 + 0.1) - f(t_0)}{0.1} = \\frac{\\text{amount of rise}}{\\text{length of run}}\\] The \\(\\approx\\) symbol means “is approximately.” For now, I want to put off the question of what “approximately” means. In modeling, whether the 0.1 gives a good enough approximation will depend on the function \\(f()\\) and the context in which the slope is needed. For instance, in drawing Figure 9.7 I needed to find the tangent line. Using 0.1 is entirely satisfactory in this setting but it might not be in other settings. The notation “slope of \\(f(t)\\) at \\(t=t_0\\)” is long-winded and awkward. If we were looking at the “value of \\(f(t)\\) at \\(t_0\\) we have at hand a much more concise notation: \\(f(t_0)\\). But it doesn’t work to write”slope of \\(f(t_0)\\)\" because \\(f(t_0)\\) is a quantity and not a function. Instead, let’s make a concise notation for “slope of \\(f(t)\\).” Following tradition, we’ll write \\({\\cal D}f(t)\\). The name of this “slope of \\(f(t)\\)” function is \\({\\cal D}f()\\): a two-letter name. When we want to say, “the (approximate) slope of the tangent line to \\(f(t)\\) at \\(t_0\\), we can write simply: \\[{\\cal D}f(t_0)\\] meaning, evaluate the”slope function of f()\" at \\(t_0\\). To formalize this, we’ll define the slope function of f() as \\[{\\cal D}f(t) \\equiv \\frac{f(t + 0.1) - f(t)}{0.1}\\] Let’s look at the slope functions that correspond to some of pattern-book functions: \\(e^x\\), \\(\\sin(x)\\), \\(x^{-1}\\) and \\(\\ln(x)\\). We can define them easily enough in R: Dexp &lt;- makeFun((exp(t+0.1) - exp(t))/0.1 ~ t) Dsin &lt;- makeFun((sin(t+0.1) - sin(t))/0.1 ~ t) Dxm1 &lt;- makeFun(((1/(t+0.1)) - (1/t))/0.1 ~ t) Dlog &lt;- makeFun((log(t+0.1) - log(t))/0.1 ~ t) Figure 9.8: Comparing the pattern-book function (blue) to its slope function (tan) Why did you plot both the function and the slope function in the same graphics frame? 1160 Excellent question! In general, it is illegitimate to plot a function and it’s slope function on the same vertical axis. The reason is the units of the two functions will be different. For instance, the output of a function position(t) might have units of “miles,” while the output of the slope function of position (that is, \\({\\cal D}\\)position(t) would have units such as miles-per-hour.) So, as a general rule, never plot a function and its corresponding slope function on the same scale. An exception is for the pattern-book functions. These always take a number as input and produce a number as output. The slope function of a pattern-book function also produces a number as output. This exception is not a good excuse for indulging a bad practice. Perhaps you’ll forgive the authors if they claim they wanted to emphasize the point by demonstrating it. Here, we write the slope function of \\(f(t)\\) as \\({\\cal D}f(t)\\). That works for this chapter, which deals with functions of only one variable. But in general modeling functions have more than one variable, for instance \\(g(x, t)\\). To work with slope functions with more than one variable, we need to extend the notation a little. We will place a small subscript after \\({\\cal D}\\) to indicate which variable we are changing. Thus, there will be two slope functions for \\(g(x,t)\\): \\[{\\cal D}_{\\color{blue}x} g(x, t) \\equiv \\frac{g({\\color{blue}x + 0.1}, t) - g(x, t)}{0.1}\\] and \\[{\\cal D}_{\\color{magenta}t} g(x, t) \\equiv \\frac{g(x, {\\color{magenta}t + 0.1}) - g(x, t)}{0.1}\\] The input referred to in the subscript following \\({\\cal D}\\) is called the with-respect-to input. The idealization of the slope function involves replacing \\(h=0.1\\) with something much smaller. What “much smaller” means has been a complicated issue in the history of calculus. Today, we write \\(h \\rightarrow 0\\) to signify the process of making \\(h\\) smaller and smaller, but never zero. When \\(h\\) has this “much smaller” value, the rate of change over the interval \\(x\\) to \\(x+h\\) becomes a rate of change “at \\(x\\)”, also called the instantaneous rate of change at \\(x\\). For the pattern-book functions, \\(h=0.1\\) or smaller gives a pretty good approximation to the instantaneous rate of change. Later, in Block 2, we’ll see how to arrange \\(h\\) so that it’s “much smaller” for functions in general. In the previous section we looked at the optimal time to harvest a tree so that the average rate of growth in usable lumber over the tree’s life is maximized. Using a model of tree growth of a ponderosa pine we found the best harvest time to be 32 years. Let’s return to the modeling phase of the wood-harvest problem with a new perspective. The real objective of tree farming is to maximize the economic value of the wood. This depends on the market price of the wood which itself may be changing in time. A market-savvy modeler will want to exploit any information about the possibility of rising or falling prices in selecting the best harvest time. Companies often hire economists to forecast market trends, but this requires a deep knowledge of trends in supply and demand which is out of the scope of what we can cover in this book. However, there is one economic principle that we can incorporate into the model without such detailed, industry specific expertise. This is the economic principle of opportunity cost. Opportunity cost takes into account when valuing an asset the other possible uses of that asset. For example, lumber companies constantly invest in planting new trees for future harvest. In order to do this, they borrow money and they pay interest on the borrowed money. They need to borrow because their existing assets are tied up in the form of wood. The opportunity cost of not harvesting a tree is the interest on the loan the company needs to take out in order to invest for the future. Between year 30 and 32, there is hardly any change in the value of the average-rate-of-change function. It’s increasing a little, but is it really worthwhile to wait? One argument is that at year 30 you already have a valuable resource: wood that could be money in the bank. If the money were in the bank, you could invest it and earn more money and at the same time get a new seedling in the ground to start its growth. You’re doing two things at once. Efficient! To know what is the best year for harvest from this point of view, you want to calculate the effective “interest rate” on the present amount of wood that you earn in the form of new wood. That interest rate is the ratio of the instantaneous rate of growth of new wood divided by the amount of existing wood. Figure 9.9 shows this function. Figure 9.9: The instantaneous investment return from the tree is the instantaneous rate of change in wood volume divided by the wood volume itself. This falls over the age of the tree as the harvestable wood volume increases. Early in the tree’s life, the growth is high compared to the volume of the tree. That’s because the tree is small. As the years pass, the tree gets bigger. Even though the rate of growth increases through year 23, the accumulated volume increases even faster, so there is a fall in the rate of return. The best time to harvest is when the annual “interest rate” paid by the growing tree falls to the level of the next best available investment. Suppose that investment would pay 10% per year. Then harvest the tree when the function values falls below 10%. That happens at year 24. If the next best investment paid only 5% (blue horizontal line), the harvest should be made at about year 29. If money could be borrowed at 2%, it would be worthwhile to harvest the tree still later. 9.7 Exercises Exercise 9.4: WRWIX From the graph in Figure 9.2, compute the average rate of change over the interval \\(10 \\leq t \\leq 200\\). How does it compare to the average rate of change over the interval \\(10 \\leq t \\leq 125\\)? Exercise 9.5: KEWIX We will be working extensively with the change in output value of a function when the input value changes. The change in the output value of a function \\(f()\\) when the input changes from \\(x = a\\) to \\(x = b\\) is \\[f(x=b) - f(x=a)\\] Notice that when we talk about the change from \\(x=a\\) to \\(x=b\\) we subtract \\(f(a)\\) from \\(f(b)\\). That change is sometimes called the rise in the value of the function. Rise always compares (by subtraction) the two output values corresponding to two specific input values. Remember that \\(a\\) and \\(b\\) stand for specific numbers. Corresponding with the idea of the change in output being \\(f(b) - f(a)\\) the change in the input value to a function is \\(b - a\\). This is often called the run in the value of the input. Question A True or false: In Graph I, the rise from a to b is positive.     TRUE︎✘ \\(f(x=a) &gt; f(x=b)\\), so the rise \\(f(x=b) - f(x=a)\\) is negative.       FALSE\\(\\heartsuit\\ \\) Question B True or false: In Graph I, the run from \\(x=a\\) to \\(x=b\\) is positive. TRUENice!  FALSE︎✘ The run is about the relative positions of \\(x=a\\) and \\(x=b\\) on the x-axis. Since \\(a &lt; b\\), the run from \\(x=a\\) to \\(x=b\\) is positive. Question C True or false: In Graph II, the run from a to b is positive. TRUERight!                                     FALSE︎✘ The run is about the relative positions of a and b on the x-axis. Since a is to the left of b, the run from a to b is positive. Question D True or false: In Graph II, the rise from a to b is positive. TRUE︎✘ Remember, the rise from \\(x=a\\) to \\(x=b\\) is \\(f(x=b) - f(x=a)\\) FALSECorrect.                                     Question E True or false: In Graph II, the run from b to c is positive. TRUE︎✘ The run from \\(x=b\\) to \\(x=c\\) is \\(c - b\\). Since \\(b&gt;c\\) b to c is negative. FALSEGood.  Question F True or false: In Graph II, the rise from b to c is positive. TRUENice!  FALSE︎✘ The rise from \\(x=b\\) to \\(x=c\\) is \\(f(x = c) - f(x = b)\\). Since \\(f(x=c) &gt; f(x=b)\\), the rise is positive. Question G For an interval [2, 6] what is the value of the run? (The answer is independent of any particular graph/function.) 4Right! The run is always the second number in the interval minus the first number. That’s \\(6 - 2\\) here. -4︎✘ You got it backwards! The second number in the interval, 6, is numerically to the right of 2, so the run is positive. Question H Which is the run of the interval [6, 2]? (Again, the answer is independent of any particular graph/function.) 4︎✘ Sorry. The run from \\(x=6\\) to \\(x=2\\) is \\(2 - 6\\) which is \\(-4\\). -4Excellent! The run is \\(2 - 6\\), the second number in the interval minus the first number. Exercise 9.6: YQCLE Open an R sandbox. You can use these function definitions to help you in your calculations. f &lt;- makeFun(2*exp(x+1) ~ x) g &lt;- makeFun(3*exp(-x) ~ x) h &lt;- makeFun(x*exp(x) ~ x) Using R, compute the average rate of change of the function over the given interval. Choose the closest answer for each problem. Question A \\(f(x) \\equiv 2 e^{x+1}\\) over [-2, 2]     -2.99︎✘        1.54︎✘        2.72︎✘        4.68︎✘        9.85\\(\\heartsuit\\ \\)       11.32︎✘ Question B \\(g(x) \\equiv 3 e^{-x}\\) over [-1, 1.5]     -2.99\\(\\heartsuit\\ \\)       1.54︎✘        2.72︎✘        4.68︎✘        9.85︎✘        11.32︎✘ Question C \\(h(x) \\equiv x e^x\\) over [0, 1]     -3︎✘        1.54︎✘        2.72\\(\\heartsuit\\ \\)       4.68︎✘        9.85︎✘        11.32︎✘ It’s much less work if we use the R function c() to define the interval, and the R function diff() to calculate differences. The next sandbox contains an example asking you to compute the average rate of change of \\(f(x) \\equiv e^x\\) over the interval [0, 4]. You only need lines 1, 3, and 5. The other lines show intermediate results to help you understand what diff() is doing. interval &lt;- c(0, 4) # creates the interval diff(interval) # calculate the run f &lt;- makeFun(exp(x) ~ x) # create the function f(interval) # evaluate function at the endpoints of the interval diff(f(interval)) / diff(interval) # complete answer Question D True or false: The average rate of change of \\(f(x) \\equiv e^{x^2}\\) over [0.0, 0.1] is 0.1005017     TRUE\\(\\heartsuit\\ \\)       FALSE︎✘ Question E True or false: The average rate of change of \\(f(x) \\equiv \\log(x)\\) over [2, 3] is 0.5062353. (Hint: Change the code above so the interval variable goes from 2 to 3 and f becomes the function \\(f(x) \\equiv \\log(x)\\))     TRUE︎✘        FALSE\\(\\heartsuit\\ \\) Question F True or false: The average rate of change of \\(f(x) \\equiv \\sin(x)\\) over [0.0, 0.5] is 0.9588511     TRUE\\(\\heartsuit\\ \\)       FALSE︎✘ Exercise 9.7: rTSX3 Consider the sinusoid function, graphed below. Question A What is the average rate of change over the interval \\(0 &lt; x &lt; \\frac{1}{2}\\)? (Choose the closest value.) 0︎✘ For this to be true, the function output would need to be the same at the two endpoints of the interval. 0.5︎✘ Did you forget to divide the rise by the run? 1Nice! Right. From the interval you have that the run is 1/2. The rise over that interval is from 0 to 1/2, so a rise of 1/2. Question B What is the average rate of change over the interval \\(0 &lt; x &lt; 6.25\\)? (Choose the closest value.) -0.5︎✘ 0Good. Right. The function output is zero at both endpoints of the interval, so the rise is zero. Hence, the run is zero. 0.5︎✘ Question C What is the average rate of change over the interval \\(0 &lt; x &lt; 10\\)? (Choose the closest value.) -0.05Excellent! Right. The rise is -0.5 and the run is 10. -0.5︎✘ This is the “rise” over the interval, but it’s not the average rate of change. You’ll need to divide the rise by another quantity to get the average rate of change. 0︎✘ 0.5︎✘ The rise will be \\(f(10) - f(0) pprox -0.5 - 0 = -0.5\\). You’ve got the sign wrong. Exercise 9.8: URIMX For each of the following, compute the average rate of change of the function over the given interval. Question A The average rate of change of \\(f(x) \\equiv x + 5\\) over [3, 5] is -2︎✘ Remember, the difference from \\(x=3\\) to 5 is \\(f(5) - f(3)\\), not the other way around. And the average rate of change is the difference divided by the length of the interval. -1︎✘ Remember, the difference from \\(x=3\\) to 5 is \\(f(5) - f(3)\\), not the other way around. Similarly, the length of the interval from \\(x=3\\) to 5 is \\(5-3\\), not \\(3-5\\). 1Right! \\(f(x=5) = 10\\) and \\(f(x=3) = 8\\), so the difference in values is 2. Since this difference occurs over an interval of length 2 (that is, from #x=3$ to 5), the average rate of change is 2/2. 2︎✘ Are you sure you took the rate of change rather than simply the change? Question B The average rate of change of \\(f(x) \\equiv 3 - 2 x\\) over [-4, -2] is -4︎✘ This is the total difference over the interval, not the rate of change. -2Excellent! The difference from \\(x=-4\\) to \\(-2\\) is \\(f(-2) - f(-4) = (7) - (11) = -4\\). The length of the interval is \\((-2) - (-4) = 2\\). So the rate is -4/2, just as you got. 0︎✘ 1︎✘ When \\(x\\) changes by two units, \\(f(x)\\) changes by 4. The rate of change is 4/2 = -2. 2︎✘ Check your +/- signs. 4︎✘ This is the negative total difference over the interval, not the rate of change. Also check your +/- signs. Question C The average rate of change of \\(f(x) \\equiv -3 x^2\\) over [0, 4] is -24︎✘ Perhaps you are looking at the derivative at \\(x=4\\) and not the average rate of change from \\(x=0\\) to 4. -12Good. The difference in \\(f()\\) over the interval is \\(f(4) - f(2) = (-48) - 0 = -48\\). The length of the interval is \\(4-0\\), so the average rate of change over the interval is \\((-48)/4 = -12\\). 0︎✘ Perhaps you are looking at the derivative at \\(x=0\\) and not the average rate of change from \\(x=0\\) to 4. 1︎✘ 2︎✘ 12︎✘ Check the signs in your arithmetic. 24︎✘ Question D The average rate of change of \\(f(x) \\equiv x^3 - 2 x + 1\\) over [0, 2] is -2︎✘ Either check your +/- signs or perhaps you are looking at the derivative at \\(x=0\\) and not the average rate of change from \\(x=0\\) to 2. 1.5︎✘ 2Nice! The difference in \\(f()\\) over the interval is \\(f(2) - f(0) = 5 - 1 = 4\\). The length of the interval is \\(2 - 0\\) so the average rate of change is \\(4/2 = 2\\). 7︎✘ 10︎✘ I think you are looking at the derivative at \\(x=2\\) rather than the average rate of change from 0 to 2. Exercise 9.9: RDWKW In this question, we ask you to estimate the slope from a graph of the function. But the function is exponential, so not a straight line. A fundamental idea in calculus is that even a function with a curved graph, if you zoom in closely around a given point, will look like a straight line. And you know how to calculate the slope of a straight line. When the graph is curved, the slope will be different at different points along the graph. So there’s not a single slope for the function. Still, we can talk about the “slope at a point.” One way to specify a point on a function’s graph is to give the horizontal coordinate: the input to the function. But here we’re going to give you the output of the function. So long as the function passes the horizontal-line test, as the exponential does, specifying any particular output in the function’s range uniquely identifies a corresponding input. Estimate the slope of the exponential function \\(g(x) \\equiv e^x\\) at several inputs, which we’ll call \\(x_1\\), \\(x_2\\), \\(x_3\\) and \\(x_4\\). We won’t give you numerical values for the \\(x_i\\) points, but we will tell you the output of the function at each of those inputs. the values of \\(x\\) where: \\(g(x_1) = 1\\) \\(g(x_2) = 5\\) \\(g(x_3) = 10\\) \\(g(x_4) = 0.1\\) For each of (a)-(d), use a sandbox to plot the exponential function \\(e^x\\) on a domain zoomed in around around the appropriate value of \\(x_i\\). Then calculate the slope of the curve at that \\(x_i\\). Question A Using your answers for the slope at the points given in (a)-(d), choose the best answer to this question: What is the pattern in the slope as \\(x\\) varies? The slope at each value \\(x_i\\) is the same as \\(e^{x_i}\\).Nice! This property of the exponential function becomes important when describing a wide range of phenomena, from nuclear isotope decay to population growth. The slope at each value \\(x_i\\) is the same as \\(x_i\\).︎✘ That would being saying the slope at \\(x_3\\) is \\(\\approx 2.30\\). Is that what you got? The slope at each value of \\(x_i\\) is the same as \\(x_i^2\\).︎✘ That would being saying the slope at the \\(x_3\\) is \\(\\approx 5.30\\). Is that what you got? The slope at each value of \\(x\\) is the same as \\(\\sqrt{x}.\\)︎✘ That would being saying the slope at the \\(x_i\\) is \\(\\approx 1.52\\). Is that what you got? Exercise 9.10: HRTIX For each exercise, you are given a series of intervals that get smaller and smaller. Your job is to calculate the average rate of change of the function \\(f(x) \\equiv x^2\\) for each of the intervals. As the width of the intervals approach zero, our average rates of change become better approximations of the instantaneous rate of change. You should use the results you calculate to make an informed estimate of the instantaneous rate of change. interval &lt;- c(__start__ , __end__ ) f &lt;- makeFun(x^2 ~ x) diff(f(interval)) / diff(interval) A. Use these three intervals to estimate the instantaneous rate of change \\(\\partial_x f(x=3)\\) - [3, 3.1] - [3, 3.01] - [3, 3.001] B. Use these three intervals to estimate the instantaneous rate of change \\(\\partial_x f(x=5)\\) - [4.9, 5] - [4.99, 5] - [4.999, 5] C. Use these three intervals to estimate the instantaneous rate of change \\(\\partial_x f(x=-2)\\) - [-2, -1.9] - [-2, -1.99] - [-2, -1.999] Exercise 9.12: CUXLR There is a web of connections between the pattern-book functions and their slopes. Question A 1. Which pattern-book function has a slope function that is simply a input-shifted version of itself? (For small enough \\(h\\).)     exponential︎✘        sinusoid\\(\\heartsuit\\ \\)       logarithm︎✘        power-law \\(x^{-1}\\)︎✘ Question B 2. Which pattern-book function has a slope function that is identical to itself? (For small enough \\(h\\).)     exponential\\(\\heartsuit\\ \\)       sinusoid︎✘        logarithm︎✘        power-law \\(x^{-1}\\)︎✘ Question C 3. Which pattern-book function has a slope function that is another pattern-book function? (Hint: The other function is also listed among the choices.)     exponential︎✘        sinusoid︎✘        logarithm\\(\\heartsuit\\ \\)       power-law \\(x^{-1}\\)︎✘ Exercise 9.13: MW03ay Sometimes a bit of algebra can help us see what’s going on with the instantaneous rate of change. Consider the exponential function \\(e^x\\). Rather than writing the slope function definition with a 0.1, let’s substitute in the symbol \\(h\\). This gives \\[{\\cal D}\\exp(x) = \\frac{e^{x+h} - e^x}{h}\\] Extracting out the common term \\(e^x\\) in the numerator, we arrive at \\[{\\cal D}\\exp(x) = e^x \\left[\\frac{e^h - 1}{h}\\right]\\] Since \\(h\\) is a number, \\([e^h - 1]/h\\) is a number, not a function of \\(x\\). So, for any given value of \\(h\\), the slope function of the exponential is proportional to the exponential itself. Question A Using a sandbox, find the value of \\([e^h - 1]/h\\) when \\(h=0.1\\). Which of these is it?     1.271828︎✘        1.694343︎✘        1.718282\\(\\heartsuit\\ \\)       e = 2.718282︎✘ The instantaneous rate of change involves making \\(h\\) very small, but not quite zero. If you make \\(h\\) exactly zero, the result will be ambiguous. Question B Using a sandbox, compute \\([e^0 - 1]/0\\). What’s the result? Inf︎✘ This would be the result if the numerator were positive, however small. But both the numerator and the denominator are zero. NaNNice! Meaning, ‘not a number’. Bogus︎✘ This is not a value and can’t be used in arithmetic. But Inf and NaN each can be legitimately used in arithmetic. An error message result.︎✘ The point of Inf and NaN is to avoid creating error conditions while still signalling that the result is ambiguous. Question C Using a sandbox, compute \\([e^h - 1]/h\\). Make \\(h\\) as small as you can, for instance \\(0.00001\\) or \\(0.00000001\\). What’s the result? 1Right! Amazingly, the instantaneous rate of change of \\(e^x\\) is exactly \\(e^x\\). It varies with \\(h\\), but is always around 1.5 for \\(h\\) small enough︎✘ There’s no particular result.︎✘ "],["function-inverses-and-solving.html", "Chapter 10 Function inverses and “solving” 10.1 Function inverses 10.2 Solving graphically 10.3 Zero-finding 10.4 Exercises", " Chapter 10 Function inverses and “solving” Very much in the spirit of naming common tasks, the process of turning an output from a function into the corresponding input is called solving. In high-school mathematics, you may have heard the phrases “solve for \\(x\\)” or “find \\(x\\).” Generally what was mean can be expressed using functions this way: Given an output \\(g(x_0)\\) find the input \\(x_0\\) that would produce that output. In computer programming, “solving” is sometimes called zero finding. As is often the case, computer programming often involves re-arranging things to fit in a standard format. Here, the standard format is to find the input that corresponds to an output of zero. In other words, given only the output \\(A = g(x_0)\\) and not \\(x_0\\) itself, find a value for \\(x_0\\) that satisfies look for the input \\(x_0\\) at which \\(g(x_0) - A = 0\\). 10.1 Function inverses This may sound like a familiar word problem from your high-school algebra course: You are a facilities manager for a small town. The town contains approximately 400 miles of road that must be plowed following a significant snowfall. How many plows must be used in order to complete the job in one day if the plows can travel at approximately 7 miles per hour when engaged? — Source The task of answering such a question is often called solving a word problem. You don’t need calculus to solve this problem, but insofar as the format is familiar to you, it might help to depict how it would be addressed as a modeling task and how to use the model created to guide the mathematical work of getting a numerical answer to the problem. Modeling Phase: The objective is to create a function that represents snow plowing and that will let us answer the question about how much plowing activity is needed. Here’s a function that takes as input \\(x\\) a number of plows and provides as output the number of miles that can be serviced in a day. \\[\\text{miles.plowed}(x) \\equiv 7 \\ \\text{mph} \\times 24 \\ \\text{hours-per-day}\\times x\\ \\text{plows}\\] In reality, “miles plowed” depends on the amount of snow, the safe speed limit of the plows, the number of rest breaks needed by the drivers, how far the snowplow terminus is from the road system, how many cars are parked on the road and the available number of tow trucks, and the day of the week and the time of day. (Remember, there might be other traffic on the road. Plowing at rush hour is bound to be slow! And the reduced visibility at night calls for extra care!) It seems that textbook “word problems” never mention such issues, having been written in a world where plowing snow is exactly the same as doing simple arithmetic. Likely, we’re going to have to use the modeling cycle to end up with a genuinely useful model. Still, we have to start somewhere, so let’s start with \\(7 \\times 24 \\times x\\). We can use this function to solve the problem: How many plows are needed to get the 400-miles of road serviced in 1 day? It’s a matter of choosing a suitable method for applying the function to guide us to the answer. 1210 One simple method, which sometimes is called guess and check is to propose some answers and see what happens. Being experts in snow plowing, we know that you can’t have negative or fractional plows, so our guesses for \\(x\\) will be integers. Let’s do this systematically: Number of plows \\(x\\) Miles plowed in a day 1 \\(7 \\times 24 \\times 1 = 168\\) 2 \\(7 \\times 24 \\times 2 = 336\\) 3 \\(7 \\times 24 \\times 3 = 504\\) 4 \\(7 \\times 24 \\times 4 = 672\\) \\(\\vdots\\) … and so on. We really don’t need all the scratch work crowding up the table, so let’s streamline it, keeping the essentials: input \\(x\\) output \\(\\text{miles.plowed}(x)\\) 1 168 2 336 3 504 4 672 The domain of the miles_plowed() function is \\(x = 0, 1, 2, 3, \\ldots\\), so our table covers only a bit of the domain. Our purpose in constructing miles_plowed() is not to figure out the output given the input, but to do the opposite: given the output, find the input. The information we have is in the form of the output: 400 miles. The mathematical operation of solving consists of looking up what we do know in the output column of the table, then reading off the corresponding input as our answer. Since 400 doesn’t appear in the output column, we’ll look for an interval that includes 400. Of course, that’s the interval from 336 to 504. So the answer will be something bigger than \\(x=2\\) but doesn’t need to be any larger than \\(x=3\\). You’ve been in the facilities management business for many years, so you know to choose the answer \\(x=3\\). If you have a graph of a function, it can be easy to calculate what the input should be for a given output. Just reverse the finger action, looking up the output on the vertical axis, tracing horizontally to the function graph, then reading off the result from the input axis. Now let’s write the problem using math notation rather than a table. We’re looking for a value of \\(x\\) such that \\[\\text{miles.plowed}(x) = 400\\] This is an equation as opposed to a function definition. We write equations with \\(=\\) and definitions with \\(\\equiv\\). The point of writing equations is often to signal to us that the task is to “solve for \\(x\\).” An algebraic solution relies on replacing miles_plowed(\\(x\\)) with the function’s formula and then re-arranging numbers and possibly other symbols until we have an equation of the form \\(x = \\ldots\\). Here, that’s easy: \\[7 \\times 24 \\times x = 400\\ \\ \\implies\\ \\ x = 400/(7\\times 24)\\] Apply some arithmetic and we find \\(x = 2.381\\). Apply some common sense and we translate this into “three plows.” An industrious facilities manager might go further. “Today there is 400 miles of road. But next year there will be more, although I don’t yet know the exact number. While I’m doing all this math work, I’ll write up a memo with a formula so that next year, when I know how much road there will be, my assistant can find the answer with simple arithmetic.” 1220 You likely learned how to set up and solve the manager wants to put in her memo. The key is to replace 400 with a symbol standing for the number of miles of road. We’ll use \\(M\\). Then you do the re-arrangement with \\(M\\) in place of 400. \\[7 \\times 24\\, x = M\\ \\ \\implies\\ \\ x = M/168\\] All that remains is to give a more informative name in place of \\(x\\) and to write it as a proper function: \\(n_{plows}(M) \\equiv M/168\\). This process of starting with a function like \\(\\text{miles.plowed(x)}\\) and transforming it into a function in a more convenient format for the task at hand \\(n_{plows}(M)\\) is called inverting the function. High-school algebra emphasizes techniques for inverting functions by moving symbols around. This is great when it can be done, but it’s often impossible in real science and engineering problems. The guess and check method that was used in the snowplow mileage table is very simple. particularly when it’s paired with a process for refining the guess after every check. Newton’s method is one such method, it makes use of the idea of slope functions, particularly those introduced in Block 2. Another common strategy for inverting functions that are beyond our own reach algebraically is to rely on a specialist to develop the inverse function, give it a name, write down a formula in mathematical notation or, sometimes more usefully, write a computer program that implements the inverse function’s algorithm. With this strategy, all that’s needed to invert a function is to know the name or formula of the function’s inverse. Here’s a table of such names and formulas, most of which is likely familiar to you. function inverse function Exponential: \\(e^x\\) Logarithm (“natural”): \\(\\ln(x)\\) Exponential: \\(2^x\\) Log base 2: \\(\\log_2(x)\\) Exponential: \\(10^x\\) Log base 10: \\(\\log_{10}(x)\\). Power law: \\(x^2\\) Square root/power-law: \\(\\sqrt{x} = x^{1/2}\\) Power law: \\(x^{-1}\\) Power law: \\(x^{-1}\\) Trig: \\(\\sin(x)\\) Trig: \\(\\arcsin(x)\\) Trig: \\(\\tan(x)\\) Trig: \\(\\arctan(x)\\) You can of course read this table either from left to right or from right to left. For instance, the inverse of \\(\\ln(x)\\) is \\(e^x\\). As you know, for a function \\(g(x)\\), the set of valid values of \\(x\\) is called the domain of the function. The set of possible outputs from the function is called the range of the function. The inverse function to \\(g()\\) has a domain which is the range of \\(g()\\) and a range which is the domain of \\(g()\\). Sometimes the notation \\(g^{-1}(x)\\) is used for \"the inverse function of \\(g()\\). This is potentially confusing, since \\(g^{-1}(x)\\) might reasonable be interpretted as \\(1/g(x)\\) and, in general, those two things are not equal. Straight-line (with non-zero slope), exponential (\\(e^{kt}\\) where \\(k\\neq 0\\)), and logarithm functions aways have inverse functions. For power-law and sinusoid functions, there can be several (or many) different inverse functions. We’ll get to this when we need to. 1230 There’s an easy graphical test for whether there is a unique inverse function or not. Draw the graph, then see if any horizontal line touches the graph of the function in more than one place. If so, there is no unique inverse function. 10.2 Solving graphically Most readers are familiar with the sort of high-school math problem where you are presented with an equation written in terms of \\(x\\) and asked to “find \\(x\\)” or “find the solution.” For instance, the problem might be \\[\\text{Let}\\ \\ 3x - 2 = 7 x^2 .\\ \\ \\ \\text{Find} \\ x .\\] The above problem falls into one class of such tasks, the class of “finding roots of polynomials.” Here’s another problem in that same class: An investment club decided to buy $9000 worth of stock with each member paying an equal share. But two members left the club, and the remaining members had to pay $50 more apiece. How many members are in the club?16 Let’s pose the problem in terms of a function, money_raised\\((x)\\) where \\(x\\) is the original number of members in the investment club. Originally, the members were each going to pay \\(9000/x\\). But after the two people drop out, each of the remaining members has to pay \\(9000/x + 50\\). Since there are \\(x-2\\) remaining members, the total amount raised is \\[\\text{money.raised}(x) \\equiv (x-2) \\left(\\frac{9000}{x} + 50\\right)\\] Figure ?? graphs \\(\\text{money.raised}(x)\\) money_raised &lt;- makeFun((x-2)*(9000/x + 50) ~ x) slice_plot(money_raised(x) ~ x, domain(x=c(10,25))) The function tells us, for any number of members \\(x\\), how much money will be raised. So what’s \\(x\\) for the club? The function doesn’t tell us … until we add in a new fact. The club raised $9000. So look up $9000 on the vertical axis, trace horizontally over to the graph, and read off the resulting input that generates an output of $9000. This inverse way of using functions—we know the output and we need to calculate the input—is very common. One reason is that sometimes it’s relatively easy to construct a model that takes input \\(x\\) to an output, but the problem at hand is to figure out from a value of the output what is the corresponding value of the input. Seismograms and electrocardiograms Suppose that you have a function \\(f(x)\\) and you also know the inverse of that function. We’ll call the inverse \\(g(x)\\) for this example, but a more typical notation is \\(f^{-1}(x)\\) where the function name is \\(f^{-1}\\). Composing a function and its inverse gives back the input: \\(f(g(x)) = x\\) and \\(g(f(x)) = x\\). As part of your high-school mathematics education, you learned the inverses to several functions. For instance, \\(e^x\\) and \\(\\ln(x)\\) are inverses, meaning that \\(\\ln(e^x) = x\\) and \\(e^{\\ln(x)} = x\\). The identity function is its own inverse. The inverse of the square function is the square root: \\(\\sqrt{x^2} = x\\) and \\((\\sqrt{x})^2 = x\\). It’s helpful to keep in mind that if you have a function \\(f(x)\\) there is some other function—although you may not know its form yet—that is the inverse to \\(f()\\). There are two caveats: Mathematicians will say that for functions like \\(\\sin(x)\\) or \\(\\dnorm(x)\\) which fail the horizontal line test the inverse does not exist. That’s because mathematicians want the inverse to have a single, unique value, while functions like \\(\\dnorm()\\) have two inputs that generate any output in the function’s range. \\(\\sin()\\) has an infinite number of inputs that generate any output in the function’s range. But in practice, the problem is to find some input that will generate the known output. If there is more than one such input, we just have to choose one. We can even satisfy the mathematician’s insistence that there be a unique inverse if we restrict the domain of the forward function to a region where it is monotonically increasing or monotonically decreasing. There is always an algorithm to that can be applied to find a solution to any inverse problem. But this algorithm is rarely a simple formula. Not having a formula, we play a name game. For instance, the inverse of the square function is called the “square root,” but there is no simple formula for finding the square root of a number. Similarly, the inverse to \\(\\sin(x)\\) is called \\(\\arcsin(x)\\), but there is no simple formula for \\(\\arcsin()\\). Almost invariably we use such inverse functions not by doing arithmetic to calculate their output, but by using a calculator button or a software function that carries out the algorithm. For now, it suffices that you can compute the inverse to any function (over some sub-domain where the function is monotonically increasing or decreasing) by graphing the function and then reading from the vertical axis to the horizontal. As we encounter more concepts from calculus and computing, we’ll develop additional methods for evaluating an inverse function without first having to construct that function. 10.3 Zero-finding Zero-finding is the name of a process for finding a function input that produces a function output of zero. Usually, zero isn’t a an output value of interest. (If the snow-plow manager asked her assistant to figure out how many plows are needed to cover 0 miles in one day, the assistant would wonder if someone has lost their mind.) However, any solving problem can be translated into a zero-finding problem. For example, if the problem is to solve \\(g(x) = M\\), we can equally well state the problem as finding a zero of \\(h(x) \\equiv g(x) - M\\). Why would anyone want to do this? Often, mathematical algorithms in computer languages are written to accept a function as an input rather than an equation. For instance the R/mosaic operator findZeros() takes as it’s primary argument a tilde expression describing a function. For example, the investment-club problem given earlier in this chapter can be re-stated as a zero-finding problem. money_raised &lt;- makeFun((x-2)*(9000/x + 50) ~ x) findZeros(money_raised(x) - 9000 ~ x) ## x ## 1 -18.0000 ## 2 -0.0001 ## 3 20.0000 It turns out that there are three zeros for `money_raised(x) - 9000$. Only one of them has any sensible interpretation as the number of investors in the club. 10.4 Exercises Exercise 10.1: IWLDN1 The graphs of functions and their inverses are related by a flip around the line of identity, shown in green in the following graph. The black curve is the graph of \\(e^x\\). Question A Is the magenta curve the graph of a function? (Hint: Does it pass the vertical line test?) YesExcellent!  No︎✘ The magenta curve has a vertical asymptote at \\(x=0\\), but since it never reaches that asymptote, it passes the vertical line test. Question B Which of these functions is graphed in magenta? \\(1/x\\)︎✘ \\(\\ln(x)\\)Good.  \\(\\sqrt{x}\\)︎✘ \\(e^{-x}\\)︎✘ Sorry, but this would be the reflection of the black curve around the vertical line at \\(x=0\\) \\(-e^{x}\\)︎✘ No. This would be the reflection of the black curve around the horizontal line at output \\(f(x)=0\\) Exercise 10.3: 1kZXxT Consider the problem of finding a value of \\(x\\) such that \\(cos(x) = x^2\\). This is easy to do graphically: find the input where the graphs of \\(cos(x)\\) and \\(x^2\\) cross. In a sandbox, create a function \\(h(x)\\) that is zero when the equation is satisfied. Pass the tilde expression h(x) ~ x to the R/mosaic findZeros() operator to find a precise numerical answer to the problem: h &lt;- makeFun( __define_your_h_function__ ) findZeros(h(x) ~ x) This translates to an equation, where \\(x\\) is the number of members: \\[(x-2)(9000/x + 50) = 9000\\] Source↩︎ "],["fun-assembling.html", "Chapter 11 Assembling functions 11.1 Linear combination 11.2 Function composition 11.3 The modeling polynomial 11.4 Function multiplication 11.5 All together now! 11.6 Exercises", " Chapter 11 Assembling functions When we need a new function for some purpose, we practically always build it out of existing functions. For instance, a parameterized function like \\[A \\sin\\left(\\frac{2 \\pi}{P}x\\right) + C\\] is built by assempling together a straight-line input scaling, a pattern-book \\(\\sin()\\) function, and another straight-line function for scaling the output from \\(\\sin()\\). 1300 In this chapter, we’ll introduce three general frameworks for combining functions: linear combination, composition, and multiplication. 11.1 Linear combination One of the most widely used sorts of combination is called a linear combination. The mathematics of linear combination is, it happens, at the core of the use of math in applications, whether that be constructing a Google-like search engine or analyzing medical data to see if a treatment has a positive effect. You’ve worked for many years with one kind of linear combination: polynomials. No doubt you’ve seen functions17 like \\[f(x) \\equiv 3 x^2 + 5 x - 2\\] There are three pattern-book functions in this polynomial. In this case, as in polynomials generally, they are all power-law functions: \\(g_0(x) \\equiv 1\\), \\(g_1(x) \\equiv x\\), and \\(g_2(x) \\equiv x^2\\). With these functions defined, we can write the polynomial \\(f(x)\\) as \\[f(x) \\equiv 3 g_2(x) + 5 g_1(x) - 2 g_0(x)\\] Each of the functions is being scaled by a quantity—3, 5, and -2 in this example—and the scaled functions are added up. That’s a linear combination; scale and add. (Later, we’ll see that the scalars generally come with units. So we might well have a metric polynomial and an equivalent traditional-unit polynomial. Just wait.) There are other places where you have seen linear combinations: The parameterized sinusoid \\[A \\sin\\left(\\frac{2 \\pi}{P}t\\right) + C\\] is a linear combination of the functions \\(h_1(t) \\equiv \\sin\\left(\\frac{2 \\pi}{P} t\\right)\\) and \\(g_0(t) \\equiv 1\\). The scalars are \\(A\\) and \\(C\\). The parameterized exponential \\[A e^{kt} + C\\] The functions being combined are \\(e^{kt}\\) and \\(1\\). The scalars are, again, \\(A\\) and \\(C\\). The straight line function \\(a x + b\\). The functions being combined are \\(x\\) and \\(1\\), the scalars are \\(a\\) and \\(b\\). 1310 Note that neither the parameterized exponential or the parameterized sinusoid is a polynomial. There are a few reasons for us to be introducing linear combinations here. You will see linear combinations everywhere once you know to look for them. There is a highly refined mathematical theory of linear combinations that gives us powerful ways to think about them as well as computer software that can quickly find the best scalars to use to match input-output data. The concept of linear combination generalizes the simple idea that we have been calling “scaling the output.” From now on, we’ll use the linear-combination terminology and avoid the narrower idea of “scaling the output.” Many physical systems are described by linear combinations. For instance, the motion of a vibrating molecule or a helicopter in flight or a building shaken by an earthquake are described in terms of simple “modes” which are linearly combined to make up the entire motion. More down to Earth, the timbre of a musical instrument is set by the scalars in a linear combination of pure tones. Many modeling tasks can be put into the framework of choosing an appropriate set of simple functions to combine and then figuring out the best scalars to use in the combination. (Generally, the computer does the figuring.) 11.2 Function composition To compose two functions, \\(f(x)\\) and \\(g(x)\\), means to apply one of the functions to the output of the other. “\\(f()\\) composed with \\(g()\\)” means \\(f(g(x))\\). This is generally very different from “\\(g()\\) composed with \\(f()\\)” which means \\(g(f(x))\\). For instance, suppose you have recorded the outdoor temperature over the course of a day and packaged this into a function \\(\\text{AirTemp}(t)\\): temperature as a function of time \\(t\\). Your digital thermometer uses degrees Celsius, but you want the output units to be degrees Kelvin. The conversion function is \\[\\text{CtoK}(C) \\equiv C + 273.15\\] Notice that CtoK() takes temperature as input. With this, we can write the “Kelvin as a function of time” as \\[\\text{CtoK}\\left(\\text{AirTemp}(t)\\right)\\] It’s important to distinguish the above time \\(\\rightarrow\\) Kelvin function from something that looks very much the same but is utterly different: \\(\\text{AirTemp}\\left(\\text{CtoK}(C)\\right)\\). In the first, the input is time. In the second, it is temperature in celsius. Here is a simple, approximate formula for the length of day (in hours) as a function of latitude \\(L\\) and the declination angle \\(\\delta\\) of the sun. \\[\\text{day_length}(L, \\delta) \\equiv \\frac{2}{15} \\arccos\\left(-\\tan(L)*\\tan(\\delta)\\right)\\] The declination angle is the latitude of the point on the earth’s surface pierced by an imagined line connecting the centers of the earth and the sun. On the summer solstice, the longest day of the year, it is \\(23.44^\\circ\\). A computer implementation must look different, since \\(L\\) and \\(\\delta\\) are typically provided in degrees while the tan() and other trigonometric functions in most computer languages expect units of radians. The conversion is easy: \\(\\text{deg2rad}(d) \\equiv \\frac{\\pi}{180} d\\). The conversion the other way is \\(\\text{rad2deg}(r) \\equiv \\frac{180}{\\pi} r\\). In order to get the day-length formula to work in a computer, we can compose the \\(\\tan()\\) function with deg2rad(). The output of acos() is in radians, so we have to convert it back to degrees. Like this: day_length &lt;- makeFun( (2/15)*rad2deg( acos( -tan(deg2rad(L))*tan(deg2rad(d)) ) ) ~ L &amp; d) Now to make a plot of day length as a function of day of the year. Of course, day_length(L, d) does not take day of the year into account. What’s missing is to know the declination of the sun as a function of calendar day. The input is a number \\(n\\) that runs from 0 at the start of January 1st to 365 at the end of December 31. In terms of this input, the declination of the sun is known to be approximately delta_sun &lt;- makeFun(-23.44*cos((2*pi/365)*(n+10) ) ~ n) Composing day_length() with delta_sun() (on the d argument only), and setting the latitude to be, say, \\(39^\\circ\\)N, we get a function of day of year n: slice_plot( day_length(39, delta_sun(n)) ~ n, domain(n=c(0,365)) ) Income inequality is a matter of perennial political debate. In the US, most people support Social Security, which is an income re-distribution programming dating back almost a century. But other re-distribution policies are controversial. Some believe they are essential to a healthy society, others that the “cure” is worse than the “disease.” 1330 Whatever one’s views, it’s helpful to have a way to quantify inequality. There are many ways that this might be done. A mathematically sophisticated one is called the Gini coefficient. Imagine that society was divided statistically into income groups, from poorest to richest. Each of these income groups consists of a fraction of the population and has, in aggregate, a fraction of the national income. Poor people tend to be many in number but to have a very small fraction of income. Wealthy people are few in number, but have a large fraction of income. The table shows data for US households in 2009:18 group label population aggregate income cumulative income poorest 20% 3.4% 3.4% low-middle 20% 8.6% 12.0% middle 20% 14.6% 26.6% high-middle 20% 23.2% 47.8% richest 20% 50.2% 100.0% The cumulative income shows the fraction of income of all the people in that group or poorer. The cumulative population adds up the population fraction in that row and previous rows. So, a cumulative population of 60% means “the poorest 60% of the population” which, as the table shows, earn as a group 14.6% of the total income for the whole population. A function that relates the cumulative population to the cumulative income is called a Lorenz function. The data are graphed in Figure 11.1 and available as the US_income data frame in the SANDBOX. Later, in Figure 11.2, we’ll fit parameterized functions to the data. Figure 11.1: Data on household incomes in the US in 2009. Lorenz curves must: Be concave up, which amounts to saying that the curve gets steeper and steeper as the population percentile increases. (Why? Because at any point, poorer people are to the left and richer to the right.) Connect (0,0) to (1, 1). Calling the income percentile \\(L\\) a function of the population percentile \\(p\\), a Lorenz function is \\(L(p)\\) that satisfies the requirements in the previous paragraph. Here are some functions that meet the requirements: \\(L_b(p) \\equiv p^b\\) where \\(1 \\leq b\\). \\(L_q(p) \\equiv 1 - (1-p)^q\\) where \\(0 &lt; q \\leq 1\\) Notice that each of these functions has just one parameter. It seems implausible that the workings of a complex society can be summarized with just one number. We can use the curve-polishing techniques that will be introduced in Section 14 to find the “best” parameter value to match the data. 1340 Lb &lt;- fitModel(income ~ pop^b, data = Income, start=list(b=1.5)) Lq &lt;- fitModel(income ~ 1 - (1-pop)^q, data = Income, start=list(q=0.5)) Figure 11.2 compares the polished functions to the data. Figure 11.2: Lorenz curves \\(L_b(p)\\) (blue) and \\(L_q(p)\\) (magenta) fitted to the household income data. Neither form \\(L_b(p)\\) or \\(L_q(p)\\) gives a compelling description of the data. Where should we go from here? We can provide more parameters by constructing more complicated Lorenz functions. Here are two ways to build a new Lorenz function out of an existing one: The product of any two Lorenz functions, \\(L_1(p) L_2(p)\\) is itself a Lorenz function. A linear combination of any two Lorenz functions, \\(a L_1(p) + (1-a) L_2(p)\\), so long as the scalars add up to 1, is itself a Lorenz function. For instance, the magenta curve in Figure 11.2 is the linear combination of 0.45 times the tan curve plus 0.55 times the blue curve. Question: Is the composition of two Lorenz functions a Lorenz function? That is, does the composition meet the two requirements for being a Lorenz function? To get started, figure out whether or not \\(L_1(L_2(0)) = 0\\) and \\(L_1(L_2(1)) = 1\\). If the answer is yes, then we need to find a way to compute the concavity of a Lorenz function to determine if the composition will always be concave up. We’ll need additional tools for this. We’ll introduce these in Block 2. 11.3 The modeling polynomial Sometimes, in order to model some simple relationship you need to build a function whose graph has a simple, curving shape. 1350 A simple but surprisingly powerful approach is to use a low-order polynomial. The order of a polynomial is the highest exponent on the input. For example: A straight-line function, \\(g_1(x) \\equiv a_0 + a_1 x\\), is a first-order polynomial. A quadratic, \\(g_2(x) \\equiv b_0 + b_1 x + b_2 x^2\\) is a second-order polynomial. Many modelers are tempted to extend the technique to third-, fourth-, fifth-order and even higher. This is only rarely worthwhile since all second-, fourth-, sixth- and higher-even-order monomials have basically the same U-shape, like a referee signalling a touch-down. Similarly, first-, third-, fifth- and higher odd-order monomial have similar shapes. An ofttimes better approach is to compose the polynomial with a curved but monotonic function, such as a logarithm. Notice that in writing low-order polynomials like \\[g_1(x) \\equiv a_0 + a_1 x\\] or \\[g_2(x) \\equiv b_0 + b_1 x + b_2 x^2\\] we are using a specific naming convention for the scalars in the linear combinations. For each different function, we use a different start-of-the-alphabet name, like \\(a\\) and \\(b\\). That same name is used for all the scalars in the function, and a subscript is used to make the distinction between the different functions being combined. Thus, we have \\(a_1\\) for the \\(x\\) function in \\(g_1()\\) and \\(b_2\\) for the \\(x^2\\) function in \\(g_2()\\). In high-school mathematics, polynomials are often written without subscript, for instance \\(a x^2 + b x + c\\). This can be fine when working with only one polynomial at a time, but in modeling we often need to compare multiple, related polynomials. 11.4 Function multiplication The third in our repertoire of methods for making new function out of old is plain old multiplication. With two functions \\(f(x)\\) and \\(g(x)\\), the product is simply \\(f(x)g(x)\\). It’s essential to distinguish between function multiplication and function composition: \\[\\underbrace{f(x) g(x)}_\\text{multiplication}\\ \\ \\ \\ \\underbrace{f(g(x)) \\ \\ \\text{or}\\ \\ \\ g(f(x))}_\\text{composition}\\] In function composition, only one of the functions—the interior function is applied to the overall input, \\(x\\) in the above example. The exterior function is fed its input from the output of the interior function. In multiplication, each of the functions is applied to the input individually. Then their outputs are multiplied to produce the overall output. In function composition, the order of the functions matters: \\(f(g(x))\\) and \\(g(f(x))\\) are in general completely different functions. In function multiplication, the order doesn’t matter because multiplication is commutative, that is, if \\(a\\) and \\(b\\) are each quantities, \\(a \\times b = b \\times a\\). 1360 Transient vibration A guitar string is plucked to produce a note. The sound is, of course, vibrations of the air created by vibrations of the string. After plucking, the note fades away. An important model of this is a sinusoid (of the correct period to correspond to the frequency of the note) times an exponential. Function multiplication is used so often in modeling that you’ll see it in many modeling situations. Here’s one example that is important in physics and communication: the wave packet. Overall, the wave packet is a localized oscillation as in Figure 11.3. Figure 11.3: A wave packet constructed by multiplying a sinusoid and a gaussian function. This is the product of two simple functions: a gaussian times a sinusoid. Figure 11.4: The two components of the wave packet in Figure 11.3 Each simple function such as a gaussian, a sigmoid, a straight-line function, or a sinusoid can be likened to a character in a story. For instance, a sinusoid with a period of 10 seconds and an amplitude of 5 feet might be sufficient for the purpose of describing the shaking encountered during an earthquake. A sigmoid might be a good description of the uptake of a successful social media platform such as Facebook. But not every social media firm succeeds and you may need two or more characters to express the drama: the rising young firm and the rapid fall in popularity when competition provides a better alternative. For instance, the initial rise in popularity of the social media platform Yik Yak was exponential. Then popularity leveled off, promising a steady, if static, business into the future. But, the internet being what it is, popularity collapsed to near zero and the company closed. On way to model this pattern is by multiplying a sigmoid by an exponential.(See Figure 11.5.) yikyak &lt;- makeFun(pnorm(year, mean=2014.5, sd=0.7) * exp(- (year-2014)) ~ year) slice_plot(yikyak(year) ~ year, domain(year=c(2010,2018))) Figure 11.5: Subscriptions to the web messaging service Yik Yak grew exponentially in 2013 and 2014, then collapsed. The company closed in 2017. 11.5 All together now! Two or all three of the techniques for combining functions—linear combinations, function composition, and function multiplication—can be used in the same function. 1370 Consider the function for the length of the day \\[\\text{day_length}(L, \\delta) \\equiv \\frac{2}{15} \\arccos\\left(-\\tan(L)*\\tan(\\delta)\\right)\\] The 2/15 is scaling the output of \\(\\arccos()\\). The \\(\\arccos()\\) is being composed with an interior function that is itself a scaled product of two functions. 11.6 Exercises Exercise 11.1: JWUVA The graph shows two gaussian functions, \\(g_1(t)\\) and \\(g_2(t)\\) A linear combination of the gaussian functions is shown in Graph (A). Question A What is the linear combination of \\(g_1(t)\\) and \\(g_2(t)\\) shown in Graph (A)? \\(0.5\\,g_1(t) + g_2(t)\\)Good.  \\(g_1(t) + 0.25\\,g_2(t)\\)︎✘ If this were the case, the right bump would be only one-quarter as big as the left bump. \\(g_1(t) + 2\\,g_2(t)\\)︎✘ Since \\(g_2(t)\\) has a maximum value of 20, \\(2\\,g_2(t)\\) would reach a value of 40. That isn’t what’s shown in the graph. Another linear combination of the gaussian functions is shown in Graph (B). Question B Which linear combination of \\(g_1(t)\\) and \\(g_2(t)\\) is shown in Graph (B)? \\(g_1(t) - 2\\, g_2(t)\\)Good.  \\(g_1(t) - g_2(t)\\)︎✘ The second (downward) gaussian hump is bigger than the first (upward) gaussian hump. \\(0.5\\,g_1(t) - 0.5\\, g_2(t)\\)︎✘ If this were so, the second gaussian hump would reach a value of -4 rather than the -8 seen in Graph (B). \\(-g_1(t) - g_2(t)\\)︎✘ The first gaussian hump is positive. Exercise 11.2: AVNOW The graph shows a function that is a linear combination of three x-shifted gaussian functions \\[a_1 \\dnorm(x-3.5) + a_2 \\dnorm(x-0.5) + a_3 \\dnorm(x-(-4))\\] Question A Estimate the scalars \\(a_1, a_2\\), and \\(a_3\\) for the function drawn in Plot (A). (Be sure to get the order right!) \\(a_1 = 0.3, a_2 = 0.15, a_3=0.2\\)Right!  \\(a_1 = 0.15, a_2 = 0.2, a_3=0.3\\)︎✘ \\(a_1 = 0.2, a_2 = 0.3, a_3=0.15\\)︎✘ \\(a_1 = 0.15, a_2 = 0.3, a_3=0.2\\)︎✘ Plot (B) shows a function that is a linear combination of four x-shifted sigmoid functions. Each the multiplicative scalars is either 1 or \\(-1\\). Recall that a handy fiducial point for the sigmoid function is the input at which the output is 1/2. Question B Where are the fiducial points for the four sigmoids?     \\(-8, -2, 3, 7\\)\\(\\heartsuit\\ \\)       \\(-6, -4, 0, 6\\)︎✘        \\(-9, -8, 1, 5\\)︎✘        \\(-2, 2, 4, 6\\)︎✘ Question C What are the scalar multipliers on each sigmoid, in order from the leftmost to rightmost?     \\(1, -1, 1, -1\\)\\(\\heartsuit\\ \\)       \\(1, -1, -1, 1\\)︎✘        \\(-1, 1, 1, -1\\)︎✘        \\(-1, 1, -1, 1\\)︎✘ Exercise 11.3: FISHU According to data from the US National Health and Nutrition Evaluation Survey, the average height of adult females is 157 cm vs 167 for adult males. The standard deviations are 17 cm and 22 cm respectively. A good model for the person-to-person variation for females is dnorm(height, mean = 157, sd = 17) and similarly for males. To see the overall distribution of adult height, regardless of sex, make a linear combination of the distribution for females and for males, giving each a scalar of one-half (since the population is roughly 50-50 female/male). Open a SANDBOX and construct the linear combination function for the overall distribution. Use the scaffolding to plot out the distributions for the individual sexes and the overall distribution. female &lt;- makeFun(dnorm(height, mean = 157, sd=17) ~ height) male &lt;- makeFun(dnorm(height, mean = 167, sd=22) ~ height) # fill in the blanks in the next line overall &lt;- makeFun( _your_scalar_f_ * female(height) + _your_scalar_m_ * male(height) ~ height) slice_plot(female(height) ~ height, domain(height=c(100,220)), color=&quot;orange3&quot;, label_x=.5, label_text=&quot;F&quot;) %&gt;% slice_plot(male(height) ~ height, color=&quot;dodgerblue&quot;, label_text=&quot;M&quot;, label_x=.8) %&gt;% slice_plot(overall(height) ~ height, color=&quot;black&quot;, size=2) Some people erroneously think that since the mean height of men is larger than women by 10cm, you can readily distinguish between the sexes based on height. However, notice that the overall distribution (plotted in black) does not show a dip between the sexes: there is no clear separation based on height. As a thought experiment, let’s increase the separation in mean height from the actual value of \\(167-157=10\\) cm to something larger. You can increase the separation by 5 cm, for example, by making the men’s mean height 167+5. Question A What’s the smallest increase in separation (in cm) that produces a barely visible dip between the sexes in the overall height distribution?     5︎✘        10︎✘        15︎✘        20︎✘        25︎✘        30\\(\\heartsuit\\ \\) Exercise 11.5: fmwTFj Question A How long is the day on April Fools (\\(n=90\\)) at Latitude 39\\(^\\circ\\)N? (Use a sandbox for the calculation.)     12.38 hours\\(\\heartsuit\\ \\)       12.59 hours︎✘        12.64 hours︎✘        12.74 hours︎✘ Exercise 11.6: LPhyTb The graph shows (in black) a function constructed as the product of two basic modeling functions. The graph also shows a pair of blue curves that encompass the black function. These are called the envelope of the black function. Question A What are the two basic modeling functions being multiplied? A sinusoid and another sinusoid with a faster period.Excellent!  A gaussian and a sinusoid.︎✘ A sigmoidal function and a sinusoid.︎✘ Question B What is the period of the envelope? 10︎✘ It’s true that the broad peaks in the overall function occur every 10 time units. But a sine wave has two excursions from zero every cycle, one positive and one negative. So if the period of the envelope were 10, we would see an amplitude of the faster sinusoid near zero every 5 time units. 20Correct.  30︎✘ If this were so, the dips in amplitude of the faster sign would occur every 15 time units. Exercise 11.7: LDKKVA Being able to add or multiply functions can enable us to tell a somewhat complicated story. For example, the graph shows a simple model of the hourly temperature in from June through September temp &lt;- makeFun(20*cos(2*pi*(t-120)/365) + 10*sin(2*pi*t/1) + 50 ~ t) slice_plot(temp(day) ~ day, domain(day=c(90, 180)), npt=1000) %&gt;% gf_labs(y = &quot;Temperature (F)&quot;, x = &quot;Day of year&quot;) You can see in the graph the slow seasonal change in temperature represented by a sine function with a period of 365 days, as well as the relatively rapid hour-by-hour variation over the course of 24 hours. There are two different mechanisms at work, 1) the annual orbit of the Earth around the Sun which creates the seasons, 2) the daily rotation of the Earth around its axis. Each mechanism is approximated by a simple function. The overall pattern can be represented by a sum of functions. We are going to use this strategy of modeling complex phenomena as a sum of two or more simple functions. Problem 1 Epidemics are often modeled as a series of “waves.” Each wave involves different people. Let’s imagine two epidemic waves, one passing through the “dodgerblue” population and a smaller one through the “orange3” population, like this: Question A Assuming that there were no way to distinguish between red and blue cases, the epidemic would look like just one curve. Which of the following curves would the overall epidemic look like? (The colors are just to help you distinguish the different functions) A︎✘ The cumulative number of cases can’t possibly go down! B︎✘ The cumulative number of cases can’t possibly go down! C︎✘ You can’t see the separate waves in (C) even though the rise in the blue wave is clearly distinct in time from the rise in the red wave. DCorrect. Yes. Each wave adds another layer to the cumulative number of cases Each of the functions shown in the above graph is a “linear combination” of the red function and the blue function. The real total cumulative cases is “wave1(t)” plus “wave2(t)”. The other functions are made up and are irrelevant to the real epidemic. Still, we can ask what arithmetic combination of “wave1(t)” and “wave2(t)” was used to create the made-up function. Question B For made-up function (A) in the graph, what was the linear combination? 1000 - wave1(t) + wave2(t)Correct.  2wave1(t) - 3wave2(t)︎✘ When t=0, both wave1(t) and wave2(t) are zero, so the sum would also be zero. That’s not true in function (A) 1000 + wave1(t) - wave2(t)︎✘ This linear combination would rise from 1000 to 2000 (at time t=100) and then fall off to 1500 as the negative wave2(t) comes into play. Exercise 11.8: MWDKVA It’s very common in communications systems to have a signal that is a sine-wave carrier that is modulated by another function. That is, the carrier is multiplied by the other function: waveform(t) = modulator(t) \\(\\times\\) carrier(t). Here are four examples in each of which a sine with a period of about 2 units is modulated by another function. In each case, that other function is one of the modeling functions we have studied. Question A (A) Of what sort is the function that is modulating the carrier?     exponential\\(\\heartsuit\\ \\)       gaussian︎✘        sigmoid︎✘        sine︎✘ Question B (B) Of what sort is the function that is modulating the carrier?     exponential︎✘        gaussian\\(\\heartsuit\\ \\)       sigmoid︎✘        sine︎✘ Question C (C) Of what sort is the function that is modulating the carrier?     exponential︎✘        gaussian︎✘        sigmoid\\(\\heartsuit\\ \\)       sine︎✘ Question D (D) Of what sort is the function that is modulating the carrier?     exponential︎✘        gaussian︎✘        sigmoid︎✘        sine\\(\\heartsuit\\ \\) Exercise 11.9: AMBXI Use a SANDBOX to answer the following questions: Question A What is the shape of the graph of the composition \\(\\pnorm(\\pnorm(x))\\)?     a sigmoid\\(\\heartsuit\\ \\)       a gaussian︎✘        an exponential︎✘ Question B What is the shape of the graph of the composition \\(\\pnorm(\\dnorm(x))\\)?     a sigmoid︎✘        a gaussian\\(\\heartsuit\\ \\)       an exponential︎✘ Question C What is the shape of the graph of the composition \\(\\dnorm(\\pnorm(x))\\)?     a sigmoid\\(\\heartsuit\\ \\)       a gaussian︎✘        an exponential︎✘ Question D What is the shape of the graph of the composition \\(\\ln(\\dnorm(x))\\)? a sharp rise from (0,0) followed by an asymptotic approach to 0 as \\(x\\rightarrow \\infty\\)︎✘ a fishhook︎✘ You have a creative imagination! a parabolaExcellent!  Question E What is the shape of the graph of the composition \\(\\ln(x^2)\\)?     similar to the log function itself\\(\\heartsuit\\ \\)       a gaussian function︎✘        a sigmoid︎✘ Question F What is the shape of \\(\\exp(x^2)\\)?     U-shaped\\(\\heartsuit\\ \\)       V-shaped︎✘        W-shaped︎✘        a gaussian function︎✘ Question G What is the shape of \\(\\exp(abs(x))\\)?     U-shaped\\(\\heartsuit\\ \\)       V-shaped︎✘        W-shaped︎✘        a sigmoid function︎✘ Question H What is the shape of \\(\\exp(-x^2))\\)?     U-shaped︎✘        V-shaped︎✘        W-shaped︎✘        a gaussian function\\(\\heartsuit\\ \\) Question I What is the range of \\(\\sin(1/x)\\)? \\(-1 \\leq \\sin(1/x) \\leq 1\\)Right!  \\(\\infty &lt; \\sin(1/x) &lt; \\infty\\)︎✘ \\(0 \\leq \\sin(1/x) &lt; \\infty\\)︎✘ \\(-\\infty &lt; \\sin(1/x) \\leq 1\\)︎✘ Question J What is the range of \\(1/\\sin(x)\\)? \\(-1 \\leq | \\sin(1/x) |\\)Excellent! Or, in words, less than -1 or greater than 1 \\(\\infty &lt; \\sin(1/x) &lt; \\infty\\)︎✘ \\(0 \\leq \\sin(1/x) &lt; \\infty\\)︎✘ \\(-\\infty &lt; \\sin(1/x) \\leq 1\\)︎✘ Question K What is the shape of the graph of the composition \\(\\ln(\\pnorm(x))\\)? a rise followed by an horizontal asymptotic approach to 0 as \\(x\\rightarrow \\infty\\)Excellent!  a fishhook︎✘ You have a creative imagination! a parabola︎✘ It’s likely that you saw polynomials as things to be factored, rather than as functions taking an input and producing an output. So they were written as equations: \\(e x^2 + 5x - 2 = 0\\)↩︎ These data, as well as the general idea for the topic come from La Haye and Zizler (2021), “The Lorenz Curve in the Classroom”, The American Statistician, 75(2):217-225↩︎ "],["fun-multiple-inputs.html", "Chapter 12 Functions with multiple inputs 12.1 f(x) times g(t) 12.2 Two-variable modeling polynomial 12.3 Exercises", " Chapter 12 Functions with multiple inputs We can use linear combination and function multiplication to build up custom functions from the basic modeling functions. Similarly, linear combination and function multiplication provide ways to construct functions of multiple inputs. 1400 12.1 f(x) times g(t) For example, when a guitar string is at rest it forms a straight line connecting its two fixed ends: one set by finger pressure along the neck of the guitar and the other at the bridge near the center of the guitar body. When a guitar string is plucked, its oscillations follow a sinusoid pattern of displacement. With the right camera and lighting setup, we can see these oscillations in action: For a string of length \\(L\\), the string displacement is a function of position \\(x\\) along the string and is a linear combination of functions of the form \\[g_k(x) \\equiv \\sin(k \\pi x /L)\\] where \\(k\\) is an integer. A few of these functions are graphed in Figure 12.1 with \\(k=1\\), \\(k=2\\), and \\(k=3\\). Figure 12.1: Vibrational modes of a guitar string. Shapes of the sort in Figure 12.1 are a stop-motion flash snapshot of the string. The string’s shape also changes in time, so the string’s displacement is a function of both \\(x\\) and \\(t\\). The displacement itself is a sinusoid whose time period depends on the length and tension of the string as well as the number of cycles of the spatial sine: \\[g_k(x, t) \\equiv \\sin(\\frac{k \\pi}{L} x) \\ \\sin(\\frac{k \\pi}{P}t)\\] Figure 12.2 shows a few snapshots of the 1.5 cycle string at different moments in time, and the motion of the linear combination.1410 Figure 12.2: String position changes over time. 12.2 Two-variable modeling polynomial In Section 11.3 we introduced the low-order polynomial, either \\(g_1(x) \\equiv a_0 + a_1 x\\) or \\(g_1(x) \\equiv b_0 + b_1 x + b_2 x^2\\) as a general-purpose way of generating a function with a smoothly curved shape. The same applies in constructing simple functions of two variables. Almost always, you should use at least a first-order polynomial, which is: \\[h_1(x, y) \\equiv a_0 + a_x x + a_y y\\] But there is an important extension of this, using what’s called a bilinear term or, more evocatively in statistics, an interaction term. This is \\[h_2(x, y) \\equiv \\underbrace{b_0}_\\text{intercept} + \\underbrace{b_x\\, x + b_y\\, y}_\\text{linear terms} + \\underbrace{b_{xy}\\,x\\, y}_\\text{bilinear term}\\] The bilinear term arises in models of phenemona such as the spread of epidemics, the population dynamics of predator and prey animals, and the rates of chemical reactions. In each of these situations one thing is interacting with another: a predator killing a prey animal, an infective individual meeting a person susceptible to the disease, one chemical compound reacting with another. 1420 Under certain circumstances, modelers include one or both quadratic terms, as in \\[h_3(x, y) \\equiv c_0 + c_x\\, x + c_y\\, y + c_{xy}\\,x\\, y + \\underbrace{c_{yy}\\, y^2}_\\text{quadratic in y}\\] The skilled modeler can often deduce which terms to include from basic facts about the system being modeled. We’ll need some additional calculus concepts before we can explain this in a straightforward way. In writing polynomials like \\[h_1(x, y) \\equiv a_0 + a_x x + a_y y\\] or \\[h_3(x, y) \\equiv c_0 + c_x x + c_y\\ y + c_{xy} x\\ y\\] we are using letters as subscripts on the coefficients. Think of \\(c_x\\) as saying, “I am the coefficient on the \\(x\\) term in the polynomial.” Using this style lets us use different letters from the start of the alphabet for the names of coefficients in the different polynomials while still making it clear which term each coefficient is scaling. We left function composition out of the list of ways to build multivariable functions out of simpler functions with a single input. For instance, consider the two functions \\(f(x)\\) and \\(g(t)\\). The composition \\(f(g(t))\\) has only one input: \\(t\\). Similarly, \\(g(f(x))\\) has only one input: \\(x\\). 12.3 Exercises Exercise 12.1: ICLSE Many printed tables are meant to be used as functions; you plug in the input values and read off the output. Here’s a table published by the National Oceanic and Atmospheric Administration for the heat index, a way of summarizing the perceived comfort (or discomfort) of summer-like weather conditions. Question A What are the inputs to the heat-index function temperature and relative humidityGood.  temperature and wind speed︎✘ Those are the inputs to the wind-chill function, not the heat index. temperature, latitude, and longitude︎✘ The heat index doesn’t depend on location. The table actually shows three different functions: The heat index in \\(^\\circ\\) F. The heat index in \\(^\\circ\\) C. A caution warning level. Question B For inputs of 70% relative humidity and \\(88^{\\circ}\\) F, what are the outputs of the three functions? \\(100^{\\circ}\\) F, \\(38^\\circ\\) C, and “extreme caution”.Correct.  \\(100^\\circ\\) F, \\(38^\\circ\\) C, and “danger”.︎✘ Check again! \\(100^\\circ\\) F, \\(33^\\circ\\) C, and “extreme caution”.︎✘ 33C does is not the same temperature as 100F. Question C Holding the relative humidity at 70%, how much would the ambient temperature have to increase (from \\(88^\\circ\\) F) to change the caution-level output to “dangerous”? Increase by \\(2^\\circ\\) FRight!  Increase by \\(6^\\circ\\) F︎✘ It looks like you’re increasing the humidity to the point where the heat index is \\(106^circ\\) F. But we asked you how much the temperature input has to change, not the heat-index output. Increase relative humidity to 80%.︎✘ It’s true that at \\(100^\\circ\\) F and 80% humidity, the caution-index is “dangerous”. But the problem specified holding humidity constant. Question D From a starting point of \\(88^\\circ\\) F and 70% humidity, what is the slope of the increase in heat index when moving to 80% humidity. \\(6^\\circ\\) F per 10 percentage points humidityNice!  \\(6^\\circ\\) F︎✘ A slope is always “rise over run”. You’ve got the rise right, but what about the run? \\(6^\\circ\\) F per 80% humidity.︎✘ The slope is the change in output divided by the change in input, i.e. “rise over run”. 80% is the humidity at the endpoint, but the run is the change in humidity from the starting point to the endpoint. Question E What is the heat-index output when the inputs are 52% relative humidity and \\(91^\\circ\\) F? Choose the best answer. \\(98.4^\\circ\\) FRight! Of course, the 4 in the last digit is sketchy, but it’s reasonable to calculate the interpolated output by averaging over neighboring outputs. \\(101^\\circ\\) F︎✘ That’s the output at 55% humidity and \\(92^\\circ\\) F. The table doesn’t say.︎✘ While it’s true that there is no table entry specifically for 52% and \\(91^\\circ\\) F, you can make a very reasonable guess by interpolation, that is, reading between the rows and columns. Question F True or false: The caution-level output could have been presented as a function of just one variable, rather than needing both temperature and humidity both. TRUEExcellent! The caution-level output is not a function of ambient temperature alone or of humidity alone. But if you know the heat-index, you know that caution level exactly. FALSE︎✘ Notice that the caution-level output is the same for any given level of the heat index, regardless of the ambient temperature or humidity separately. The US National Weather Service also publishes a heat index graphic, the one below. Source link Exercise 12.2: EDKKW Recall the Pythagorean theorem: \\(C^2 = A^2 + B^2\\). Let’s write this as a function that takes as inputs the lengths of the two legs and produces as output the length of the hypotenuse. \\[\\text{hypotenuse}(a, b) \\equiv \\sqrt{\\strut a^2 + b^2}\\] This can be seen as a composition of a function \\(f(x) \\equiv \\sqrt{x}\\) into a linear combination of square functions of different inputs: \\(g(a, b) \\equiv a^2 + b^2\\). Question A What is the function \\(f()\\)? \\(f(x) \\equiv a^2\\)︎✘ This wouldn’t make sense. The output of \\(f()\\) doesn’t depend on its input. \\(f(x) \\equiv \\sqrt{x}\\)Correct.  \\(f(x) \\equiv x^2\\)︎✘ This is part of the interior function, not the outer function. \\(f(x) \\equiv +\\)︎✘ Sorry, but the output of the hypothenuse() function needs to be a quantity, and \\(+\\) is not a quantity. Question B What is the function \\(g()\\)? \\(g(x) \\equiv a^2\\)︎✘ This wouldn’t make sense. The output of \\(f()\\) doesn’t depend on its input. \\(g(a) \\equiv x^2\\)︎✘ This wouldn’t make sense. The output of \\(f()\\) doesn’t depend on its input. \\(g(x) \\equiv x^2\\)Excellent! Right, a power-law function. It doesn’t matter what we call the input, so long as it’s used consistently in the definition. \\(g(x) \\equiv a^2 + b^2\\)︎✘ Sorry, but the input name is \\(x\\) and the formula on the right side of the tilde expression has \\(a\\) and \\(b\\) in it. Question C There are two functions in the linear combination. What are they?     \\(g(a)\\) and \\(g(b)\\)\\(\\heartsuit\\ \\)       \\(f(x)\\) and \\(g(x)\\)︎✘        \\(f(b)\\) and \\(g(b)\\)︎✘ Question D What are the scalars in the linear combination? \\(1\\) and \\(1\\)Correct.  \\(1\\) and \\(-1\\)︎✘ There are no scalars.︎✘ I think I know what you’re getting at. The tradition in mathematics is that when a scalar is \\(1\\), we don’t write it down. But still, the scalar is \\(1\\). You used \\(a\\) and \\(b\\) as the names of the inputs to hypotenuse(). Aren’t \\(a\\) and \\(b\\) meant to be parameters, not input names? You can use whatever you want as input names, so long as they are used consistently between the left and right sides of the \\(\\\\equiv\\). Names like \\(x\\), \\(t\\), and \\(y\\) scream out to be recognized as input names, so these are what we use most of the time. But the Pythagorean theorem is usually written using A, B, and C. I’m honoring that convention so that a human reader gets a cultural hint what the inputs stand for. I’m unapologetic about this, since you got fair warning by the left side of the \\(\\\\equiv\\) what the argument names are. Exercise 12.4: dB1r5F Auckland, New Zealand is in a field of dormant volcanos. The highest, at 193 meters above sea level, is Maungawhau. Formerly, tourists could drive to the peak and look down into the crater, as seen in the picture. Figure 12.3: The crater of Maungawhau, near Auckland, New Zealand. Source The initial creator of R, Ross Ihaka, teaches at the University of Auckland. His digitization of a topographic map is easily plotted, as here: Figure 12.4: A combination surface and contour plot of the topography of Maungawhau. The z-axis is height and is in meters. The x- and y-axes are latitude and longitude, measured in 10-meter units from a reference point. (So, \\(x=10\\) is 100 meters from \\(x=20\\).) Get used to the presentation of the surface plot and how to rotate it and zoom in. To see the crater clearly, you can rotate the surface plot to look straight downwards, effectively presenting you with a color-coded contour plot. Moving the cursor over the surface will display the \\(x\\) and \\(y\\) coordinates, as well as the \\(z\\)-value at that coordinate point. Question A What is the \\((x, y)\\) location of the low-point of the crater? (Choose the closest answer.)     \\((x=34, y=29)\\)\\(\\heartsuit\\ \\)       \\((x=31, y=25)\\)︎✘        \\((x=25, y=34)\\)︎✘        \\((x=29, y=34)\\)︎✘ Question B What color is used to designate the lowest elevations?     dark blue\\(\\heartsuit\\ \\)       green︎✘        yellow︎✘ If you were to climb up Maungawhau, at some point you would be at the same elevation as the low-point of the crater, even though you are outside the crater. Think of the contour that corresponds to that elevation. Let’s call it the “half-way” contour since it’s roughly half-way up the volcano. Question C What is the shape of the “half-way” contour?     a line segment︎✘        a crescent︎✘        a closed curve\\(\\heartsuit\\ \\)       a cross︎✘ Imagine that you are filling up the crater with water. At some point, the water rises to a level where it will spill over the lip of the crater. Question D What is the elevation at which the water will start to spill over the crater lip? (Pick the closest answer.)     169 meters\\(\\heartsuit\\ \\)       172 meters︎✘        175 meters︎✘        178 meters︎✘ Question E Explain in terms of the shapes of contours how you can identify the elevation at which the water would spill over the rim. Exercise 12.5: drawing We’ve created a function named \\(\\text{twins}(x,y)\\) to help you practice making contour plots. You’ll need to open a sandbox to draw the plot. Here is some scaffolding for the command: twins &lt;- mosaic::rfun(~ x + y, seed = 302, n=5) contour_plot(twins(x, y) ~ x + y, domain(x=c(0,1), y=c(-1,1))) Question A The domain of the plot should be large enough to show a mountain next to a deep hole. Which of these domains will do the job? domain(x=c(-5, 5), y=c(-5, 5)Right!  domain(x=c(1, 5), y=c(1, 5)︎✘ This shows the mountain, but not the hole. domain(x=c(1,1), y=c(-1,1)))︎✘ Some of the hole is shown, but none of the mountain. domain(x=c(5,10), y=c(0,10)))︎✘ There’s hardly anything going on in this domain. The function here is pretty flat except for a dip in the lower left. In a different sandbox (so you can still see the contour plot in the first sandbox), draw a slice through the function along the line \\(y=0\\). Use the same \\(x\\)-domain as in the correct answer to the previous question. In the slice_plot() command below, you will need to replace __tilde-expression___ and __domain__ with the correct syntax. twins &lt;- mosaic::rfun(~ x + y, seed = 302, n=5) slice_plot(__tilde-expression__, __domain__) Question B Which of these expressions will accomplish the task? slice_plot(twins(x, y=0) ~ x, domain(x=c(-5,5)))Excellent!  slice_plot(twins(x) ~ x, domain(y=c(-5, 5)))︎✘ The domain should be over \\(x\\), not \\(y\\). And twins() takes two inputs, even if one of them is fixed at zero. slice_plot(twins(x, y=0) ~ x, domain(x=c(-5, 5), y=c(-5, 5)))︎✘ A slice plot has a domain that includes only one input. slice_plot(twins(x, y=0) ~ x + y, domain(x=c(-5, 5), y=c(-5, 5)))︎✘ A slice plot has only one input on the right side of the tilde expression. Exercise 12.6: daylength Consider this graph of the length of the day at different levels of latitude and different days of the year. Source. First, orient yourself to the graph and what the contours mean. Note the vertical lines indicating the days of the equinoxes and solstices. Question A True or False: There is a place on the equator when the day length is exactly 12 hours at some time of year. TRUE︎✘ If there were, the horizontal (dashed) line denoting the equator would cross the 12-hour contour. It doesn’t. FALSENice! Since the dashed equator line no where overlaps with the 12-hour contour line, there is no time of year when the length of day on the equator is exactly 12 hours. Presumably this is because daylight starts somewhat before the sun rises above the horizon and ends somewhat after the sun goes below the horizon. The word “equinox” comes from the Latin for “equal night.” Question B True or False: To judge from the contour plot, on the equinox every latitude has a length of day somewhat longer than the length of night. TRUENice!  FALSE︎✘ Note that neither of the lines for the March or September equinoxes cross the 12-hour length-of-day contour. Question C US Air Force Academy is at latitude 38.9983° N. Reading from the contour plot, roughly what is the length (in hours) of the longest day of the year?     13︎✘        14︎✘        15\\(\\heartsuit\\ \\)       16︎✘        17︎✘        18︎✘        19︎✘ Exercise 12.7: kelxlB The contour plot below is marked with several colored lines which represent slices through the surface. Your job is to match these up with the slice plots presented below. In the slice plots, the input \\(t\\) reflects the position on the slice. At \\(t=0\\), position is at the leftmost point of the slice, while at \\(t=1\\) position is at the right terminus of the slice. Question A Which color line corresponds to slice 1?     black︎✘        gray︎✘        blue︎✘        tan\\(\\heartsuit\\ \\)       yellow︎✘ Question B Which color line corresponds to slice 2?     black︎✘        gray\\(\\heartsuit\\ \\)       blue︎✘        tan︎✘        yellow︎✘ Question C Which color line corresponds to slice 3?     black\\(\\heartsuit\\ \\)       gray︎✘        blue︎✘        tan︎✘        yellow︎✘ Question D Which color line corresponds to slice 4?     black︎✘        gray︎✘        blue︎✘        tan︎✘        yellow\\(\\heartsuit\\ \\) Exercise 12.8: ticlw The gradient plot below is marked with several colored lines which represent slices through the surface. Your job is to match these up with the slice plots presented below. In the slice plots, the input \\(t\\) reflects the position on the slice. At \\(t=0\\), position is at the leftmost point of the slice, while at \\(t=1\\) position is at the right terminus of the slice. Question A Which color line corresponds to slice 1?     black︎✘        gray\\(\\heartsuit\\ \\)       blue︎✘        tan︎✘        yellow︎✘ Question B Which color line corresponds to slice 2?     black︎✘        gray︎✘        blue\\(\\heartsuit\\ \\)       tan︎✘        yellow︎✘ Question C Which color line corresponds to slice 3?     black︎✘        gray︎✘        blue︎✘        tan︎✘        yellow\\(\\heartsuit\\ \\) Question D Which color line corresponds to slice 4?     black︎✘        gray︎✘        blue︎✘        tan\\(\\heartsuit\\ \\)       yellow︎✘ "],["fun-piecewise.html", "Chapter 13 Piecewise functions 13.1 Splitting the domain 13.2 Basic piecewise functions 13.3 Exercises", " Chapter 13 Piecewise functions Each of our basic modeling functions, with two exceptions, has a domain that is the entire number line \\(-\\infty &lt; x &lt; \\infty\\). No matter how big or small is the value of the input, the function has an output. Such functions are particularly nice to work with, since we never have to worry about the input going out of bounds. 1500 The two exceptions are: the logarithm function, which is defined only for \\(0 &lt; x\\). some of the power-law functions: \\(x^p\\). When \\(p\\) is negative, the output of the function is undefined when \\(x=0\\). You can see why with a simple example: \\(g(x) \\equiv x^{-2}\\). Most students had it drilled into them that “division by zero is illegal,” and \\(g(0) = \\frac{1}{0} \\frac{1}{0}\\), a double law breaker. When \\(p\\) is not an integer, that is \\(p \\neq 1, 2, 3, \\cdots\\) the domain of the power-law function does not include negative inputs. To see why, consider the function \\(h(x) \\equiv x^{1/3}\\). It can be tedious to make sure that you are on the right side of the law when dealing with functions whose domain is not the whole number line. The designers of the hardware that does computer arithmetic, after several decades of work, found a clever system to make it easier. It’s a standard part of such hardware that whenever a function is handed an input that is not part of that function’s domain, one of two special “numbers” is returned. To illustrate: sqrt(-3) ## [1] NaN (-2)^0.9999 ## [1] NaN 1/0 ## [1] Inf NaN stands for “not a number.” Just about any calculation involving NaN will generate NaN as a result, even those involving multiplication by zero or cancellation by subtraction or division.19 For instance: 0 * NaN ## [1] NaN NaN - NaN ## [1] NaN NaN / NaN ## [1] NaN Division by zero produces Inf, whose name is reminiscent of “infinity.” Inf infiltrates any calculation in which it takes part: 1510 3 * Inf ## [1] Inf sqrt(Inf) ## [1] Inf 0 * Inf ## [1] NaN Inf + Inf ## [1] Inf Inf - Inf ## [1] NaN 1/Inf ## [1] 0 To see the benefits of the NaN / Inf system let’s plot out the logarithm function over the graphics domain \\(-5 \\leq x \\leq 5\\). Of course, part of that graphics domain, \\(-5 \\leq x \\leq 0\\) is not in the domain of the logarithm function and the computer is entitled to give us a slap on the wrists. The NaN provides some room for politeness. Open a sandbox and see what happens when you make the plot. slice_plot(log(x) ~ x, domain(x=c(-5,5))) 13.1 Splitting the domain In a purely mathematical sense, the problem with functions being undefined over an extended part of a domain has been handled with cunning and imagination, but the solution—the invention of complex numbers—is not our concern here. Instead, we’re going to embrace functions that have a domain smaller than the whole number line and see what we can do with them. To illustrate, let’s use computer notation to create a function whose domain is \\(x &lt; 1\\). To do this, we need a way to write “if,” as in, “If \\(x\\) is 1 or greater, return NaN.” We’ll use a function in R that let’s us ask a TRUE/FALSE question and, depending on the answer, do one or another calculation. The question-answering R function is ifelse() whose name is remarkably descriptive. The ifelse() function takes three arguments. The first is the question to be asked, the second is the value to return if the answer is “yes,” and the third is the value to return for a “no” answer. g &lt;- makeFun( ifelse(x &lt; 1, x, NaN) ~ x) slice_plot(g(x) ~ x, domain(x = c(-2, 2))) What takes getting used to here is the expression x &lt; 1 which is a question not a statement of fact. There’s no standard traditional mathematical notation for questions, although some people use a question mark as in \\(x \\stackrel{?}{&lt;} 1\\). The table shows computer notation for some common sorts of questions. 1520 R notation English x &gt; 2 “Is \\(x\\) greater than 2?” y &gt;= 3 “Is \\(y\\) greater than or equal to 3?” x == 4 “Is \\(x\\) exactly 4?” 2 &lt; x &amp; x &lt; 5 “Is \\(x\\) between 2 and 5?”20 x &lt; 2 | x &gt; 6 “Is \\(x\\) either less than 2 or greater than 6?” abs(x-5) &lt; 2 “Is \\(x\\) within two units of 5?” 13.2 Basic piecewise functions Having an ability to split up the domain of a function and provide different formula for each of the pieces allows us to construct piecewise functions. To illustrate, the function \\(h(x) \\equiv |x|\\). You’ll recognize this as the “absolute value” function. The intuitive algorithm is to “strip the negative sign, if any” from the input. But with the ability to divide the domain into pieces, we gain access to a less mysterious sort of arithmetic operation and can re-write \\[h(x) \\equiv \\left\\{ \\begin{array}{ll} x &amp; \\text{for}\\ 0 \\leq x \\\\ \\text{- x} &amp; \\text{otherwise}\\\\\\end{array} \\right.\\] Or, in computer notation h &lt;- makeFun(ifelse(x &gt;= 0, x, -x) ~ x) Note that the absolute value function is built-in to R in the form of the abs() function. Less familiar is the Heaviside function which has important uses in physics and engineering: \\[\\text{Heaviside}(x) \\equiv \\left\\{ \\begin{array}{cl} 1 &amp; \\text{for}\\ 0 \\leq x \\\\0 &amp; \\text{otherwise}\\end{array} \\right.\\] In computer notation, this is Heaviside &lt;- makeFun(ifelse(x &lt; 0, 0, 1) ~ x) The vertical gap between the two pieces is called a discontinuity. Intuitively, you cannot draw a discontinuous function without lifting the pencil from the paper. The Heaviside function has a discontinuity at \\(x=0\\). Similarly, the ramp function (aka “ReLU”) is a kind of one-sided absolute value: \\[\\text{ramp}(x) \\equiv \\left\\{ \\begin{array}{cl} x &amp; \\text{for}\\ 0 \\leq x\\\\0 &amp; \\text{otherwise}\\end{array} \\right.\\] Or, in computer notation: ramp &lt;- makeFun(ifelse(0 &lt; x, x, 0) ~ x) slice_plot(ramp(x) ~ x, domain(x=c(-3, 3))) A linear combination of two input-shifted ramp functions gives a piecewise version of the sigmoid. sig &lt;- makeFun(ramp(x+0.5) - ramp(x-0.5) ~ x) slice_plot(sig(x) ~ x, domain(x=c(-3, 3))) Figure 13.1 is a graph of monthly natural gas use in the author’s household versus average temperature during the month. (Natural gas is measured in cubic feet, appreviated ccf.) 1530 Figure 13.1: The amount of natural gas used for heating the author’s home varies with the outside temperature. The graph looks somewhat like a hockey stick. A sloping straight-line dependence of ccf on temperature for temperatures below \\(60^\\circ\\)F and constant for higher temperatures. The shape originates from the dual uses of natural gas. Gas is used for cooking and domestic hot water, the demand for which is more of less independent of outdoor temperature at about 15 ccf per month. Gas is also used for heating the house, but that’s needed only when the temperature is less than about \\(60^\\circ\\)F. We can accomplish the hockey-stick shape with a linear combination of the ramp() function and a constant. The ramp function represents gas used for heating, the constant is the other uses of gas (which are modeled as not depending on temperature. Overall, the model is \\[\\text{gas_ccf}(x) \\equiv 4.3\\, \\text{ramp}(62-x) + 15\\] Even simpler is the model for the other uses of natural gas: \\[\\text{other_ccf}(x) \\equiv 15\\]. Our last example concerns a bit of familiar technology: music synthesis. Generating a pure tone electronically is easily done using a sinusoid. Generating a note with rich instrumental timbre can be accomplished by a linear combination of sinusoids. Of course, the note will be localized in time. This could be accomplished by multiplying the sinusoids by a gaussian function envelope. 1540 It turns out that the gaussian function, dnorm(), does not generate a realistic sound. Instead, a more complicated envelope is used, such as the ADSR function shown in Figure 13.2. The function has six (!) parameters: the time the key is pressed, the duration A of the “attack” phase when the sound amplitude is increasing in response to the impulse imposed on the key, a decay of duration D to an output level S that lasts until the key is released, then a decay to zero over duration R. It’s reasonable to think of the D and S phases as a piecewise linear approximation to exponential decay. Figure 13.2: The ADSR envelope function used in music synthesis consists of 6 pieces including zero output before the key is pressed and after the pulse ends. Source 13.3 Exercises Exercise 13.05: EDKYV The function bigger() is defined piecewise in terms of two extremely simple functions. Each of the two simple functions has a contour plot with contours that are parallel. The piecewise combination of the simple functions has a more complicated contour plot, with each simple function’s parallel contours showing up in half of the domain. We’ll call these “pieces” of the domain. bigger &lt;- makeFun(ifelse(y &gt; x, y, x) ~ x + y) contour_plot(bigger(x,y) ~ x+y, domain(x=c(-2,2), y=c(-2,2))) Question A Which of the following best describes the two pieces of the domain? One is above and to the left of the line of identity (that is, \\(y=x\\)) and the other is below and to the right of that line.Nice!  One is \\(x &gt; 0\\) and the other \\(x \\leq 0\\)︎✘ One is \\(x &gt; 0\\) and the other \\(y \\leq 0\\)︎✘ Exercise 13.07: E9e7c6 library(Zcalc) If you are unlucky and develop a serious ear or throat or other infection, and if the infection is bacterial and not viral, you may be prescribed antibiotics. You probably know how it goes. You go to the pharmacy to pick up a bottle of pills. There might be anywhere between 10 pills and 40. The directions will certainly tell you to make sure to finish the bottle; to take the full course of medication. It may say take a pill twice a day, or three times, or every six hours, perhaps with food. The details of this regimen are determined largely by the details of whether food inhibits or buffers absorption of the medicine and by the efficiency by which your body metabolizes the medicine and then removes it from your blood via your liver. Modeling this process—often called the *pharmacokinetics of the drug—is an important step in drug development. A simple but effective model of the drug concentration over time is a piecewise function: zero before you take the pill, then an exponential decay from an initial level of one unit after you take the pill. pill &lt;- makeFun(ifelse(t &lt; 0, 0, exp(-k * t)) ~ t, k = log(2)/1.5) The shape of the pill() function is seen in Figure 13.3. Another part of the model is the therapeutic threshold, the minimal concentration for medical effectiveness. Keep in mind that this is a model. In reality, the drug not is absorbed instantaneously as in the model, and the medical effectiveness varies smoothly with concentration rather than being an all-or-nothing affair. slice_plot(pill(t) ~ t, domain(t=-2:10)) %&gt;% gf_hline(yintercept = ~ 0.25, color=&quot;magenta&quot;) %&gt;% gf_text(0.25 ~ 8, label=&quot;Therapeutic threshold&quot;, color=&quot;magenta&quot;, vjust=0, nudge_y=0.02) %&gt;% gf_labs(y=&quot;Drug availability&quot;, x = &quot;Time (hrs)&quot;) Figure 13.3: A simple illustrative model of drug availability from taking a unit dose at time zero. The therapeutic threshold depends on the drug: 0.25 is shown here. The critical features of the model are the half-life of the drug in the body and the therapeutic threshold, both of which depend on the particular drug in question. Question A What is the half life of the drug depicted in the Figure 13.3?     60 minutes︎✘        90 minutes\\(\\heartsuit\\ \\)       120 minutes︎✘        180 minutes︎✘ Figure 13.3 shows the availability from a single pill. The goal of taking multiple pills, spread out over time, is to keep the drug availability above the therapeutic threshold for an extended time, e.g. 10 days. There are three parameters to the therapy: how often you take a pill, and the dose delivered by a single pill, and the medicine’s half-life. Question B Occasionally, the prescription directs you to take a single pill once a day. Suppose the half-life of the medicine is 3 hours. How big would the dose A need to be in order to keep the availability above a threshold of 0.25 for a 24-hour period?     2 units︎✘        16 units︎✘        64 units\\(\\heartsuit\\ \\)       1024 units︎✘ Let’s explore a familiar-sounding directive: Take one pill every six hours. We can model this by a linear combination of time-shifted pill() functions. Each pill provides a dose of size A. six_hours &lt;- makeFun(A*pill(t, k) + A*pill(t-6, k) + A*pill(t-12, k) + A*pill(t-18, k) + A*pill(t-24, k) ~ t, k=log(2)/3, A = 1) slice_plot(six_hours(t) ~ t, domain(t=-1:24)) The graph shows that the drug is above the therapeutic threshold (0.25) for the entire first day. From the graph of drug availability versus time, do you think continuing the one-pill-every-6-hours regimen will continue to keep the drug level over the therapeutic threshold for the remainder of the course of treatment? Explain why or why not. Let’s switch to an one-pill every 8 hour regimen, the pills being taken at midnight, 8am, and 4pm, … How big a dose A will be needed to keep the drug availability above the therapeutic threshold for the entire course of treatment? (Hint: Construct a function analogous to six_hours() and plot out the drug availability over the 24 hours of the first day. Then vary the dose A until you find the minimum dose that keeps the availability over the threshold of 0.25 for the entire day.) Suppose the instructions were to take 2 pills when you start treatment and then an additional pill every 8 hours. How big a dose A would be needed to keep the drug availability above the therapeutic threshold for the entire course of treatment? Which of the three regimens described (6-hour, 8-hour, 8-hour-double-first-dose) involves the smallest total dose? (The total dose is the sum of the doses for each pill administration.) One that does produce a number is NaN^0.↩︎ Literally, “Is \\(x\\) both greater than 2 and less than 5?”↩︎ "],["modeling-cycle.html", "Chapter 14 Modeling cycle 14.1 Example: Cooling water 14.2 Example: The tides 14.3 Modeling project", " Chapter 14 Modeling cycle Effective modelers treat models with skepticism. They look for ways in which models fail to capture salient features of the real world. They have an eye out for deviations between what their models show and what they believe they know about the system being modeled. They consider ways in which the models might not serve the purpose for which they were developed. 1560 When modelers spot a failure or deviation or lack of proper utility, they might discard the model but more often they make a series of small adjustments, tuning up the model until is successfully serves the purposes for which it is intended. Thus, modeling is a cyclic process of creating a model, assessing the model, and revising the model. The process comes to a sort of preliminary end when the model serves its purposes. But even then, models are often revised to check whether the results are sensitive to some factor that was not included or to check whether some component that was deemed essential really is so. 14.1 Example: Cooling water Looking back on the exponential fitted to the cooling water data in Section 8.3, it looks like our original estimate of the half-life is a bit too small; the data doesn’t seem to decay at the rate implied by \\(k = -0.0277\\). Perhaps we should try a somewhat slower decay, say \\(k = -0.2\\) and see if that improves things. In the cooling water example, we’re using only a subset of the data collected by Prof. Wagon. The next commands re-create that subset so that you can work with it. They also plot the data and an exponential model. 1565 # reconstruct the sample set.seed(101) Stans_data &lt;- CoolingWater %&gt;% sample_n(20) # Plot the sample and overlay a model gf_point(temp ~ time, data=Stans_data) %&gt;% gf_lims(y = c(20, NA)) %&gt;% slice_plot(25 + 83.3*exp(-.0277*time) ~ time, color=&quot;dodgerblue&quot;) See if \\(k=-0.02\\) provides a better fit to the model. (You can add another slice_plot() to be able to compare the original and \\(k=-0.02\\) models.) Later in this course, we’ll study optimization. There are optimization techniques for directing the computer to refine the parameters to best match the data. Just to illustrate, here’s what we get: refined_params &lt;- fitModel(temp ~ A + B*exp(k*time), data = Stans_data, start = list(A = 25, B = 83.3, k = -0.0277)) coef(refined_params) ## A B k ## 25.92628463 60.69255269 -0.01892572 new_f &lt;- makeFun(refined_params) gf_point(temp ~ time, data = Stans_data) %&gt;% slice_plot(new_f(time) ~ time, color=&quot;dodgerblue&quot;) Figure 14.1: Polishing the fit using the rough model as a starting point. The refined parameters give a much better fit to the data than our original rough estimates by eye. We had two rounds of the modeling cycle. First, choice of an exponential model and a rough estimate of the parameters A, B, and \\(k\\). Second, refinement of those parameters using the computer. Looking at the results of the second round, the experienced modeler can see some disturbing discrepancies. First, the estimated baseline appears to be too high. Related, the initial decay of the model function doesn’t seem to be fast enough and the decay of the model function for large \\(t\\) appears to be too slow. Prof. Stan Wagon noticed this. He used additional data to fill in the gaps for small \\(t\\) and refined his model further by changing the basis functions in the linear combination. He hypothesized that there are at least two different cooling processes. First, the newly poured water raises the temperature of the mug itself. Since the water and mug are in direct contact, this is a fast process. Then, the complete water/mug unit comes slowly into equilibrium with the room temperature. 1567 The newly refined model was a even better match to the data. But nothing’s perfect and Prof. Wagon saw an opportunity for additional refinement based on the idea that there is a third physical mechanism of cooling: evaporation from the surface of the hot water. Prof. Wagon’s additional circuits of the modeling cycle were appropriate to his purpose, which was to develop a detailed understanding of the process of cooling. For other purposes, such as demonstrating the appropriateness of an exponential process or interpolating between the data points, earlier cycles might have sufficed. Here’s a graph of the model Prof. Wagon constructed to match the data. Figure 14.2: A model that combines three exponentials provides an excellent fit. This is an excellent match to the data. But … matching the data isn’t always the only goal of modeling. Prof. Wagon wanted to make sure the model was physically plausible. And looking at the refined parameters, which include two exponential processes with parameters \\(k_1\\) and \\(k_2\\), he saw something wrong: But what can we make of \\(k_1\\), whose [positive value] violates the laws of thermodynamics by suggesting that the water gets hotter by virtue of its presence in the cool air? The most likely problem is that our simple model (the proportionality assumption) is not adequate near the boiling point. There are many complicated factors that affect heat transportation, such as air movement, boundary layer dissipation, and diffusion, and our use of a single linear relationship appears to be inadequate. In the next section [of our paper] we suggest some further experiments, but we also hope that our experiments might inspire readers to come up with a better mathematical model. The modeling cycle can go round and round! 14.2 Example: The tides In Section 8.2 we looked at a sinusoid model of tide levels in Rhode Island. We left unresolved how to refine the estimate of the period \\(P\\) and find the time offset \\(t_0\\) in the sinusoidal model \\[\\text{tide}(t) \\equiv A \\sin\\left(\\frac{2\\pi}{P} (t-t_0)\\right) + B\\] 1040 \\[{\\color{blue}{\\text{tide}(t)} \\equiv 1.05 + 0.55 \\sin(2\\pi (t - t_0)/11)}\\] The new parameter, \\(t_0\\), should be set to be the time of a positive-going crossing of the baseline. Looking at the tide data (black) plotted in Figure 14.3 we can pick out such a crossing at about time = 17. Happily, changing the phase does not itself necessitate re-estimating the other parameters: baseline, amplitude, period. This model, incorporating the phase, has been graphed in \\(\\color{blue}{\\text{blue}}\\). Figure 14.3: Shifting the phase of the sinusoid gives the flexibility needed to align the peaks and troughs of the model with the data. Performing this alignment for one peak makes it clear that the period is wrong. For some modeling purposes, such as prediction of future tides, the phase information is essential. For others, say, description of the amplitude of the tides, not. But getting the phase roughly right can help point out other problems. For instance, in the left panel of Figure 14.3 the blue model is roughly aligned with the data. Not at all so in the right panel. What leads to the discrepancy is a bad estimate for the period. 13 hours is roughly right, but over a five-day period the error accumulates until, in the right panel, the model has a trough where the data peak, and vice versa. Although the blue sinusoid is not perfect, having it for comparison suggests that the previously estimated period of 13 hours is too long. We can shorten the period gradually in our model until we find something that better matches the data. For example: Figure 14.4 shows that a period of 12.3 hours is a good match to the data. With this refinement the model is \\[{\\color{green}{\\text{tide}(t)} \\equiv 1.05 + 0.55 \\sin(2\\pi (t - 17)/12.3)}\\] Figure 14.4: With the phase about right, a better estimate can be made of the period: 12.3 hours. We might call it quits with the model in Figure 14.4. But once we have a pretty good model fit, it’s easy to polish the parameter estimates, letting the computer do the tedious work of trying little tweaks to see if it can improve the fit. The R/mosaic fitModel() can do this tweaking for us. As the following commands show, fitModel() takes a tilde expression as input. To the left of the tilde goes the name of the function output in the data frame being used. The right side is a formula for the model, with names used for each parameter and using the names of inputs from the data frame. The second argument is the data frame. The third argument is used to convey an estimate for each parameter; that estimate should be pretty good if fitModel() is to be able to refine it. The output from fitModel() is a function, which we’re naming tide_mod(). tide_mod &lt;- fitModel(level ~ A + B*sin(2*pi*(hour-t0)/P), data = RI_tide, start=list(A=1.05, B=0.55, t0=17, P=12.3)) coef(tide_mod) ## A B t0 P ## 1.0220540 0.4998367 15.3899905 12.5593556 The command coef(tide_mod) displays the parameters found by fitModel() which will be an improvement—perhaps a big improvement, perhaps not—on our original estimates. These new parameters differ only slightly from the ones shown in Figure 14.4, but the match to the data with the new coefficients is discernably better, even by eye. Figure 14.5: Polishing the parameters of the sinusoid This last model seems capable of making reasonable predictions, so if we collected up-to-date data we might be able to fit a new model to predict the tide level pretty accurately a few days ahead of time. Also, the excellent alignment of the model peaks with the data tell us that the cyclic tide has a period that is constant, at least so far as we can tell. 1576 With the period estimate \\(P=12.56\\) hours, we can go looking for other phenomena that might account for the tides. The period of the day-night cycle is, of course 24 hours. So the tides in Providence come in and out twice a day. But not exactly. Something else must be going on. Isaac Newton was the first to propose that the tides were caused by the gravitational attraction of the Moon. A complete cycle of the Moon—moon rise to moon rise—takes about 50 minutes longer than a full day: the Earth revolves once every 24 hours, but in that time the Moon has moved a bit further on in its orbit of the Earth. So the Moon’s period, seen from a fixed place on Earth is about 24.8 hours. Half of this, 12.4 hours, is awfully close to our estimate of the tidal period: 12.56 hours. The difference in periods, 8 minutes a day, might be hard to observe over only 4 days. Maybe with more data we’d get a better match between the tides and the moon. This is the modeling cycle at work: Propose a model form (a sinusoid), adjust parameters to match what we know (the Providence tide record), compare the model to the data, observe discrepancies, propose a refined model. You can stop the model when it is giving you what you need. The period 12.56 hour model seems good enough to make a prediction of the tide level a few days ahead, and is certainly better than the “two tides a day” model. But our model is not yet able to implicate precisely the Moon’s orbit in tidal oscillations. Discrepancies between a model and data play two roles: they help us decide if the model is fit for the purpose we have in mind and they can point the way to improved models. That the tidal data deviates from the steady amplitude of our model can be a clue for where to look next. It’s not always obvious where this will lead. Historically, careful analysis of tides led to a highly detailed, highly accurate model: a linear combination of sinusoids with periods near a half-day 12.42 , 12.00, 12.66, and 11.97 hours as well components with periods that are about a day long 23.93, 25.82, 24.07, 26.87, and 24.00 hours. A tide-prediction model is constructed by finding the coefficients of the linear combination; these differ from locale to locale. There is no global model of tides, but rather a framework of linear combinations of sinusoids of different periods. What customizes the framework to the tides in a particular locale is the coefficients used in the linear combination. 1577 14.3 Modeling project The data frame SunsetLA records the number of minutes after 4 pm until the sun sets in Los Angeles, CA over a 4-year interval from January 2010 (month 1) through December 2013 (month 48). Open a sandbox and make a plot of sunset time versus month. gf_point(Minutes ~ Month, data = SunsetLA) %&gt;% gf_line() We’re using both gf_point() and gf_line(). With data that oscillates up and down, connecting the data points with lines makes it easier to see the pattern. Question C What is the range of the number of minutes until sunset over the whole 4-year period? 40 to 190 minutesNice!  120 minutes︎✘ A range is an interval spanned by two numbers. 40 to 180 minutes︎✘ The largest values are half a tick mark up from 180. Tick marks are spaced by 20 minutes. 0 to 48 months︎✘ That’s the domain. The range is along the vertical axis. Question D The data fall nicely on a sine-shaped curve. What is the period of that sine? 6 months︎✘ Look at the number of months from one peak to another. 11 months︎✘ Look more carefully. And remember that the change in length of day is an annual phenomenon. 12 monthsGood.  12 minutes︎✘ Period refers to an interval on the domain of the function, not the range. The function \\[\\text{sunset}(\\text{Month}) \\equiv A \\sin(2 \\pi\\, \\text{Month} / 12) + C\\] is a linear combination of two functions: The constant function one(Month) The sine function sin(2*pi*Month/12) The two functions are scaled by \\(C\\) and \\(A\\), respectively. Make rough but reasonable numeric estimates for \\(C\\) and \\(A\\) from the data. Then, in the sandbox, define the sunset() function using the numerical estimates in the linear combination. Plot your function as a layer on top of the data. (Pipe the gf_point() layer to slice_plot().) sunset &lt;- makeFun(A + C*sin(2*pi*(Month - offset)/12), A = __your estimate__, C = __your estimate__, offset=0) gf_point(Minutes ~ Month, data = SunsetLA) %&gt;% gf_line() %&gt;% slice_plot(sunset(Month) ~ Month) The domain for slice_plot() is inherited to that implied by the SunsetLA data. Notice that the input name in slice_plot() corresponds to that established in gf_point(). Question E Your sunset() function should be a pretty good match to the data except for one thing. What is that thing? The sunset() function has a completely different range than the data.︎✘ This won’t be the case if you have estimated \\(C\\) and \\(A\\) correctly. The period of the sunset() function doesn’t match the data.︎✘ Did you use sin(2*pi*Month/12)? If so, the period should be right. There is a horizontal time shift between sunset() and the data.Right!  We’re going to fix the problem with sunset() by defining a time offset to use as a reference. For a sine function, a suitable time offset is the value along the horizontal axis when the phenomenon being modeled crosses \\(C\\) with a positive slope. There are 4 such points along the horizontal axis readily identifiable in the data. (They may not be at an integer value of Month.) Question F Which of these is a suitable value for the time offset? 0 months︎✘ That’s not a time when the data suggest that \\(C\\) is being crossed. 19 months︎✘ That’s a maximum, not a crossing of \\(C\\). 21.5 months︎✘ That’s a crossing of \\(C\\), but not one with a positive slope. 15.5 monthsCorrect. This is a good rough value. Since the period is 12 months, you could equally well have said the offset is 3.5 months. In the original scaffolding, the value of offset was zero. Change that to match your answer to the previous question. Plot out the modified sunset() function and confirm that it is a much better match to the data than the original (that is, the one without the time offset). You can “tune” your function by tweaking the numerical values of the \\(A\\), \\(C\\), and \\(offset\\) parameters until you get a solid match. Alternatively, you can use fitModel() to do the tuning for you. Plug in your estimates (a.k.a. “guesses”) for the parameters in place of the ___ in the following. Then run the code. You’ll see your estimate of the function compared to the result of having the computer refine your estimate. Chances are, the computer does a better job of stringing the function through the data. ## rough estimates from graph rough_A &lt;- __estimated_A__ rough_C &lt;- __estimated_C__ rough_offset &lt;- __estimated_offset___ guessed_fun &lt;- makeFun(A*sin(2*pi*(Month - offset)/12) + C ~ Month, A = rough_A, C = rough_C, offset = rough_offset) tuned_fun &lt;- fitModel(Minutes ~ A*sin(2*pi*(Month - offset)/12) + C, data = SunsetLA, start = list(A = rough_A, C = rough_C, offset = rough_offset) ) gf_point(Minutes ~ Month, data = SunsetLA) %&gt;% gf_line(color = &quot;dodgerblue&quot;) %&gt;% slice_plot(tuned_fun(Month) ~ Month) %&gt;% slice_plot(guessed_fun(Month) ~ Month, color = &quot;orange3&quot;) Perhaps you were expecting the tuned sine function to match the data exactly. It does not. One reason for this is that the Earth’s orbit around the Sun is not exactly circular. The sine function is only a model of the phenomenon, good for some purposes and not for others. For a more complete explanation, see this article on Wikipedia. (Thomas Swalm contributed to this project.) "],["magnitudes.html", "Chapter 15 Magnitudes 15.1 Counting digits 15.2 Using digit() to understand magnitude 15.3 Quantity and magnitude 15.4 Composing \\(\\ln()\\) 15.5 Magnitude graphics 15.6 Reading logarithmic scales 15.7 Fractional digits (optional) 15.8 Exercises", " Chapter 15 Magnitudes Undoubtedly you are comfortable with the standard way of writing numbers, for instance 33 or 512 or 1051. Elementary school students master the comparison of such numbers. Which is greater: 512 or 33? Which is less, 1051 or 512? You can answer such questions at a glance; the comparison can be accomplished simply by counting the number of digits. 1051 has four digits, so it is larger than the three-digit number 512. There are two digits in 33, so it smaller than 512. When two numerals have the same number of digits—say, 337 and 512—you can’t answer the “greater than” question by simple counting. Instead, you proceed from left to right and compare the number in each place. So, for 512 and 337, you compare 5 to 3 and … since 5 is greater than 3, 512 is greater than 337. If the two leading digits are the same, go on to the next digit and so on for all the digits in turn. 1600 Things were not always this simple. Our number system that uses place and Arabic numerals is a human invention. An example of an earlier number system is Roman numerals. Here, comparison is hard. For instance, which of these three numbers is bigger? \\[\\text{MLI or CXII or XXXIII}\\] The typographically shorter number is the largest, and vice versa. Even when two Roman numerals have the same length, it’s not trivial to compare them on a place-by-place basis. For instance, IC is about fifteen times bigger than VI, even though I is much smaller than V. 15.1 Counting digits Digit counting provides an easy, fast way to perform many calculations, at least approximately. What is \\(\\sqrt{10000}\\)? There are five digits, and the square root of a number will have “half the number of digits.” So, \\(\\sqrt{10000} = 100\\). What is \\(10 \\times 34\\)? Easy: 340. Just append the one zero from 10 to the end of 34. What is \\(1000 \\times 13\\)? Just as easy: 13,000. We even punctuate written numbers with commas and a period in order to facilitate counting digits. Imagine having a digit counting function called digit(). It takes a number as input and produces a number as output. We don’t have a formula for digit(), but for some inputs the output can be calculated just be counting. For example: digit(10) \\(\\equiv\\) 1 digit(100) \\(\\equiv\\) 2 digit(1000) \\(\\equiv\\) 3 … and so on … digit(1,000,000) \\(\\equiv\\) 6 … and on. The digit() function easily can be applied to the product of two numbers. For instance: digit(1000 \\(\\times\\) 100) = digit(1000) + digit(100) = 3 + 2 = 5. Similarly, applying digit() to a ratio gives the difference of the digits of the numerator and denominator, like this: digit(1,000,000 \\(\\div\\) 100) = digit(1,000,000) - digit(100) = 6 - 2 = 4 15.2 Using digit() to understand magnitude We haven’t shown you the digit() function for anything but the handful of discrete inputs listed above. It was a heroic task to produce the continuous version of digit(). The method is sketched out in 15.7. In practice, digit() is so useful that it could well have been one of our basic modeling functions: \\[\\text{digit(x)} = 2.302585 \\ln(x)\\] or, in R, log10(). We elected \\(\\ln()\\) rather than digit() for reasons that will be seen when we study differentiation. 15.3 Quantity and magnitude The familiar quantity 60 miles-per-hour is written as a number (60 here) followed by units. The quantity is neither the number nor the units: it is the combination of the two. For instance, 100 is obviously not the same as 60. And miles-per-hour is not the same as kilometers-per-hour. Yet, 60 miles-per-hour is almost exactly the same quantity as 100 kilometers-per hour.21 1610 6, 60, 600, and 6000 miles-per-hour are quantities that differ in size by orders of magnitude. Such differences often point to a substantial change in context. A jog is 6 mph, a car on a highway goes 60 mph, a cruising commercial jet goes 600 mph, a rocket passes through 6000 mph on its way to orbital velocity. In everyday speech, the difference between 60 and 6 is 54; just subtract. Modelers and scientists routinely mean something else: the difference between 60 and 6 is “one order of magnitude.” Similarly, 60 and 6000 are different by “two orders of magnitude,” and 6 and 6000 by three orders of magnitude. In everyday English, we have phrases like “a completely different situation” or “different in kind” or “qualitatively different” (note the l) to indicate substantial differences. “Different orders of magnitude” expresses the same kind of idea but with specific reference to quantity. The use of factors of 10 in counting orders of magnitude is arbitrary. A person walking and a person jogging are on the edge of being qualitatively different, although their speeds differ by a factor of only 2. Aircraft that cruise at 600 mph and 1200 mph are qualitatively different in design, although the speeds are only a factor of 2 apart. A professional basketball player (height 2 meters or more) is qualitatively different from a third grader (height about 1 meter). Modelers develop an intuitive sense for when to think about difference in terms of a subtractive difference (e.g. 60 - 6 = 54) and when to look at orders of magnitude (e.g. 60-to-6 is one order of magnitude). This seems to be a skill based in experience and judgment, as opposed to a mechanical process. One clue that thinking in terms of orders of magnitude is appropriate is when you are working with a set of objects whose range of sizes spans one or many factors of 2. Comparing baseball and basketball players? Probably no need for orders of magnitudes. Comparing infants, children, and adults in terms of height or weight? Orders of magnitude may be useful. Comparing bicycles? Mostly they fit within a range of 2 in terms of size, weight, and speed (but not expense!). Comparing cars, SUVs, and trucks? Differences by a factor of 2 are routine, so thinking in terms of order of magnitude is likely to be appropriate. Another clue is whether “zero” means “nothing.” Daily temperatures in the winter are often near “zero” on the Fahrenheit or Celcius scales, but that in no way means there is a complete absence of heat. Those scales are arbitrary. Another way to think about this clue is whether negative values are meaningful. If so, thinking in terms of orders of magnitude is not likely to be useful. You may have guessed that digits() is handy for computing differences in terms of orders of magnitude. Here’s how: 1620 Make sure that the quantities are expressed in the same units. Calculate the difference between the digits() of the numerical part of the quantity. What is the order-of-magnitude difference in velocity between a snail and a walking human. A snail slides at about 1 mm/sec, a human walks at about 5 km per hour. Putting human speed in the same units as snail speed: \\[5 \\frac{km}{hr} = \\left[\\frac{1}{3600} \\frac{hr}{sec}\\right] 5 \\frac{km}{hr} = \\left[10^6 \\frac{mm}{km}\\right] \\left[\\frac{1}{3600} \\frac{hr}{sec}\\right] 5 \\frac{km}{hr} = 1390 \\frac{mm}{sec} \\] Calculating the difference in digits() between 1 and 1390: log10(1390) - log10(1) ## [1] 3.143015 So, about 3 orders of magnitude difference in speed. To a snail, we walking humans must seem like rockets on their way to orbit! Animals, including humans, go about the world in varying states of illumination, from the bright sunlight of high noon to the dim shadows of a half moon. To be able to see in such diverse conditions, the eye needs to respond to light intensity across many orders of magnitude. The lux is the unit of illuminance in the Système international. This table22 shows the illumination in a range of familiar outdoor settings: Illuminance Condition 110,000 lux Bright sunlight 20,000 lux Shade illuminated by entire clear blue sky, midday 1,000 lux Typical overcast day, midday 400 lux Sunrise or sunset on a clear day (ambient illumination) 0.25 lux A full Moon, clear night sky 0.01 lux A quarter Moon, clear night sky For a creature active both night and day, they eye needs to be sensitive over 7 orders of magnitude of illumination. To accomplish this, eyes use several mechanisms: contraction or dilation of the pupil accounts for about 1 order of magnitude, photopic (color, cones) versus scotopic (black-and-white, rods, nighttime) covers about 3 orders of magnitude, adaptation over minutes (1 order), squinting (1 order). 15.4 Composing \\(\\ln()\\) The logarithm is the inverse of the exponential function. In other words, \\[\\ln(e^x) = x\\ \\ \\text{and}\\ \\ e^{\\ln(x)} = x\\] Think about this in terms of the kinds of quantities that are the input and output to each function. 1630 Logarithm: The input is a quantity, the output is the magnitude of that quantity. Exponential: The input is a magnitude, the output is the quantity with that magnitude. 15.5 Magnitude graphics In order to display a variable from data that varies over multiple orders of magnitude, it helps to plot the logarithm rather than the variable itself. Let’s illustrate using the Engine data frame, which contains measurements of many different internal combustion engines of widely varying size. For instance, we can graph engine RPM (revolutions per second) versus enging mass, as in Figure 15.1. gf_point(RPM ~ mass, data = Engines) Figure 15.1: Engine RPM versus mass for 39 different enginges plotted on the standard linear axis. In the graph, most of the engines have a mass that is … zero. At least that’s what it appears to be. The horizontal scale is dominated by the two huge 100,000 pound monster engines plotted at the right end of the graph. Plotting the logarithm of the engine mass spreads things out, as in Figure 15.2. gf_point(RPM ~ mass, data = Engines) %&gt;% gf_refine(scale_x_log10()) Figure 15.2: Engine RPM versus mass on semi-log axes. Note that the horizontal axis has been labelled with the actual mass (in pounds), with the labels evenly spaced in terms of their logarithm. This presentation, with the horizontal axis constructed this way, is called a semi-log plot. When both axes are labeled this way, we have a log-log plot, as shown in Figure 15.3. gf_point(RPM ~ mass, data = Engines) %&gt;% gf_refine( scale_x_log10(), scale_y_log10() ) Figure 15.3: Engine RPM versus mass on log-log axes. Semi-log and log-log axes are widely used in science and economics, whenever data spanning several orders of magnitude need to be displayed. In the case of the engine RPM and mass, the log-log axis shows that there is a graphically simple relationship between the variables. Such axes are very useful for displaying data, but can be hard for the newcomer to read quantitatively. For example, calculating the slope of the evident straight-line relationship in Figure 15.3 is extremely difficult for a human reader and requires translating the labels into their logarithms. Robert Boyle (1627-1691) was a founder of modern chemistry and of the scientific method in general. As any chemistry student already knows, Boyle sought to understand the properties of gasses. His results are summarized in Boyle’s Law. The data frame Boyle contains two variables from one of Boyle’s experiments as reported in his lab notebook: pressure in a bag of air and volume of the bag. The units of pressure are mmHg and the units of volume are cubic inches.23 Famously, Boyle’s Law states that, at constant temperature, the pressure of a constant mass of gas is inversely proportional to the volume occupied by the gas. Figure 15.4 shows a cartoon of the relationship. Figure 15.4: A cartoon illustrating Boyle’s Law. Source: NASA Glenn Research Center Figure 15.5 plots out Boyle’s actual experimental data. I gf_point(pressure ~ volume, data = Boyle) %&gt;% gf_lm() Figure 15.5: A plot of Boyle’s pressure vs volume data on linear axes. The straight line model is a poor representation of the pattern seen in the data. You can see a clear relationship between pressure and volume, but it’s hardly a linear relationship. Plotting Boyle’s data on log-log axes reveals that, in terms of the logarithm of pressure and the logarithm of volume, the relationship is linear. gf_point(log(pressure) ~ log(volume), data = Boyle) %&gt;% gf_lm() Figure 15.6: Plotting the logarithm of pressure against the logarithm of volume reveals a straight-line relationship. Figure 15.6 shows that Boyle’s log-pressure and log-volume data are a straight-line function. In other words: \\[\\ln(\\text{Pressure}) = a + b \\ln(\\text{Volume})\\] You can find the slope \\(b\\) and intercept \\(a\\) from the graph. For now, we want to point out the consequences of the straight-line relationship between logarithms. Exponentiating both sides gives \\[e^{\\ln(\\text{Pressure})} = \\text{Pressure} = e^{a + b \\ln(\\text{Volume})} = e^a\\ \\left[e^{ \\ln(\\text{Volume})}\\right]^b = e^a\\, \\text{Volume}^b\\] or, more simply (and writing the number \\(e^a\\) as \\(A\\)) \\[\\text{Pressure} = A\\, \\text{Volume}^b\\] A power-law relationship! 15.6 Reading logarithmic scales Plotting the logarithm of a quantity gives a visual display of the magnitude of the quantity and labels the axis as that magnitude. A useful graphical technique is to label the axis with the original quantity, letting the position on the axis show the magnitude. 1640 To illustrate, Figure 15.7(left) is a log-log graph of horsepower versus displacement for the internal combustion engines reported in the Engines data frame. The points are admirably evenly spaced, but it is hard to translate the scales to the physical quantity. The right panel in Figure 15.7 shows exactly the same data points, but now the scales are labeled using the original quantity. gf_point(log(BHP) ~ log(displacement), data = Engines) gf_point(BHP ~ displacement, data = Engines) %&gt;% gf_refine(scale_y_log10(), scale_x_log10()) Figure 15.7: Horsepower versus displacement from the Engines data.frame plotted with log-log scales. The tick marks on the vertical axis in the left pane are labeled for 0, 2.5, 5.0, 7.5, and 10. That doesn’t refer to the horsepower itself, but to the logarithm of the horsepower. The right pane has tick labels that are in horsepower at positions marked 1, 10, 100, 1000, 10000. Such even splits of a 0-100 scale are not appropriate for logarithmic scales. One reason is that 0 cannot be on a logarithmic scale in the first place since \\(\\log(0) = -\\infty\\). Another reason is that 1, 3, and 10 are pretty close to an even split of a logarithmic scale running from 1 to 10. It’s something like this: 1 2 3 5 10 x |----------------------------------------------------| 0 1/3 1/2 7/10 1 log(x) It’s nice to have the labels show round numbers. It’s also nice for them to be evenly spaced along the axis. The 1-2-3-5-10 convention is a good compromise; almost evenly separated in space yet showing simple round numbers. 15.7 Fractional digits (optional) So far, we have the digit() function in a tabular form: 1650 input output \\(\\vdots\\) \\(\\vdots\\) 0.01 -2 0.1 -1 1 0 10 1 100 2 1000 3 10,000 4 100,000 5 1,000,000 6 \\(\\vdots\\) \\(\\vdots\\) Here’s the point-plot presentation of the table: Figure 15.8: Connecting the data points for the digit function to make a continuous function. We’ve imagined digits() to be a continuous function so we’ve connected the gaps with a straight line. Now we have a function that has an output for any input between 0.01 and 1,000,000, for instance, 500,000. The angles between consecutive line segments give the function plotted in Figure 15.8 an unnatural look. Still, it is a continuous function with an output for any input even if that input is not listed in the table. Starting around 1600, two (now famous) mathematicians, John Napier (1550-1617) and Henry Briggs (1561-1630) had an idea for filling in gaps in the table. They saw the pattern that for any of the numbers \\(a\\) and \\(b\\) in the input column of the table \\[ \\text{digit}(a \\times b) = \\text{digit}(a) + \\text{digit}(b)\\] This is true even when \\(a=b\\). For instance, digit(10)=1 and digit(10\\(\\times\\) 10) = 2. Consider the question what is digit(316.2278)? That seems a odd question unless you realize that \\(316.2278 \\times 316.2278 = 100,000\\). Since digit(100000) = 5, it must be that digit(316.2278) = 5/2. Another question: what is digit(17.7828)? This seems crazy, until you notice that \\(17.7828^2 = 316.2278\\). So digit(17.78279) = 5/4. For a couple of thousand years mathematicians have known how to compute the square root of any number to a high precision. By taking square roots and dividing by two, it’s easy to fill in more rows in the digit()-function table. You get even more rows by noticing other simple patterns like \\[\\text{digit}(a/10) = \\text{digit}(a) -1 \\ \\ \\text{and} \\ \\ \\ \\text{digit}(10 a) = \\text{digit}(a) + 1\\] Here are some additional rows in the table input output Why? 316.2278 2.5 From \\(\\sqrt{\\strut100,000}\\) 17.17828 1.25 From \\(\\sqrt{\\strut 316.2278}\\) 4.21696 0.625 From \\(\\sqrt{\\strut 17.17828}\\) 31.62278 1.5 From 316.2278/10 3.162279 0.5 From 31.62278/10 You can play this game for weeks. We asked the computer to play the game for about half a second and expanded the original digit() table to 7975 rows. Figure 15.9 plots the expanded digits() function table. Figure 15.9: The digit function with more entries Now we have a smooth function that plays by the digit rules of multiplication. Henry Briggs and his assistants did a similar calculation by hand. Their work was published in 1617 as a table. Figure 15.10: Part of the first page of Henry Briggs table of logarithms The table was called the Chilias prima, Latin for “First group of one thousand.” True to its name, the table gives the output of digits() for the inputs 1, 2, 3, …, 998, 999, 1000. For instance, as you can see from the top row of the right-most column, digits(67) = 1.82607480270082. In everyday speech, 67 has two digits. The authors of Chilias prima sensibly didn’t use the name “digit()” for the function. They chose something more abstract: “logarithm()”. Nowadays, this function is named \\(\\log_{10}()\\). In R, the function is called log10(). 1660 log10(67) ## [1] 1.826075 Our main use for \\(\\log_{10}()\\) (in R: log10()) will be to count digits in order to quickly compare the magnitude of numbers. The difference digits(\\(x\\)) - digits(\\(y\\)) tells how many factors of 10 separate the magnitude of the \\(x\\) and \\(y\\). Another important logarithmic/digit-counting function is \\(\\log_2()\\), written log2() in R. This counts how many *binary digits are in a number. For us, \\(\\log_2(x)\\) tells how many times we need to double, starting at 1, in order to reach \\(x\\). For instance, \\(\\log_2(67) = 6.06609\\), which indicates that \\(67 = 2\\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2^{0.06609}\\) \\(\\log_2(x)\\) and \\(\\log_{10}(x)\\) are proportional to one another. One way to think of this is that they both count “digits” but report the results in different units, much as you might report a temperature in either Celsius or Fahrenheit. For \\(\\log_2(x)\\) the units of output are in bits. For \\(\\log_{10}(x)\\) the output is in decades. A third version of the logarithm function is called the natural logarithm and is denoted \\(\\ln()\\) in math notation and simply log() in R. We’ll need additional calculus concepts before we can understand what justifies calling \\(\\ln()\\) “natural.” 15.8 Exercises Exercise 15.2: ILXEG Open a SANDBOX and make the following log-log plot of horsepower (BHP) versus displacement (in cc, cubic-centimeters) of the internal combustion engines listed in the Engines data frame. gf_point(BHP ~ displacement, data = Engines) %&gt;% gf_refine(scale_x_log10(), scale_y_log10()) %&gt;% gf_labs(x = &quot;displacement (cc)&quot;) In the plot, you’ll see that the vertical axis has labels at 1, 10, 100, 1000, 10000. These numbers are hardly spaced evenly when plotted on a linear scale, but on the log scale they are evenly spaced. Since there is a factor of ten between consecutive labels, the interval between the labels is called a decade. On the horizontal axis, the labels are at 10, 1000, 100,000, and 10,000,000. Each of those intervals spans a factor of one hundred. For instance, from 1000 is one-hundred times 10, 100,000 is one-hundred times 1000, and so on. An interval of size 100 is said to span two decades, not 20 years but a factor of 100. Based on the log-log plot, answer these questions. Question A How many engines have a displacement of 1 liter or less? none︎✘ Perhaps you recognized that the left-most tick mark corresponds to a value of 1, and that no data points are 1 or smaller. But one liter corresponds to 1000 cc. 7︎✘ This is the number of engines with displacement of 10 cc or smaller. But one liter corresponds to 1000 cc. 14Right! Right. It’s the \\(10^3\\) tick that marks 1 liter, since 1 liter is 1000 cc. 25︎✘ That would be true if the cut-off were 10 liters. But it’s not. Question B Using the log-log plot, how many decades of BHP are spanned by the data? 4︎✘ Not a bad answer, but not the best one either. Notice that the smallest engine is about half a decade below 1 BPM, and the largest is about half a decade above 10,000 BPH 5Nice!  100︎✘ The number \\(10^{100}\\) is called a googol and is roughly how many particles (including photons, neutrinos, etc.) are in the universe. Imagine, quite contrary to fact, that 1 BHP could be generated by burning one molecule of fuel per second. Then as many fuel molecules as there are particles in the universe would have to be burned each second to power an engine at the high end of a span of 100 decades. Exercise 15.4: j3xe You have likely heard the phrase “exponential growth” used to describe the COVID-19 pandemic. Let’s explore this idea using actual data. The COVID-19 Data Hub is a collaborative effort of universities, government agencies, and non-governmental organizaions (NGOs) to provide up-to-date information about the pandemic. We’re going to use the data about the US at the whole-country level. (There’s also data at state and county levels. Documentation is available via the link above.) Perhaps the simplest display is to show the number of cumulative cases (the confirmed variable) and deaths as a function of time. We’ll focus on the data up to June 30, 2020. The plot shows confirmed cases in blue and deaths in tan. gf_line(deaths ~ date, data = Covid_US %&gt;% filter(date &lt; as.Date(&quot;2020-06-30&quot;)), color = &quot;orange3&quot;) %&gt;% gf_line(confirmed ~ date, color = &quot;blue&quot;) ::: Question A As of mid June, 2020 about how many confirmed cases were there? (Note that the labeled tick marks refer to the beginning of the month, so the point labeled Feb is February 1.) about 50,000︎✘ The number 1e6 means 1,000,000, that is, six zeros following the 1. about 200,000︎✘ The number 1e6 means 1,000,000, that is, six zeros following the 1. about 500,000︎✘ The number 1e6 means 1,000,000, that is, six zeros following the 1. about 1,000,000︎✘ Mid June is the tick mark after the mark labelled Jun. about 2,000,000Excellent!  about 5,000,000︎✘ Mid June is the tick mark after the mark labelled Jun. Here’s the same graphic as above, but taking the logarithm (base 10) of the number of cases (that is, confirmed) and of the number of deaths. Since we’re taking the logarithm of only the y-variable, this is called a “semi-log” plot. gf_point(log10(confirmed) ~ date, data = Covid_US %&gt;% filter(date &lt; as.Date(&quot;2020-06-30&quot;)), color = &quot;dodgerblue&quot;) %&gt;% gf_point(log10(deaths) ~ date, color = &quot;orange3&quot;) Up through the beginning of March in the US, it is thought that most US cases were in people travelling into the US from hot spots such as China and Italy and the UK, as opposed to contagion between people within the US. (Such contagion is called “community spread.”) So let’s look at the data representing community spread, from the start of March onward. Exponential growth appears as a straight-line on a semi-log plot. Obviously, the overall pattern of the curves is not a straight line. The explanation for this is that the exponential growth rate changes over time, perhaps due to public health measures (like business closures, mask mandates, etc.) The first (official) US death from Covid-19 was recorded was recorded on Feb. 29, 2020. Five more deaths occurred two days later, bringing the cumulative number to 6. Question B The tan data points for Feb 29/March 1 show up at zero on the vertical scale for the semi-log plot. The tan data point for March 2 is at around 2 on the vertical scale. Is this consistent with the facts stated above? No. The data contradict the facts.︎✘ Think about what it means to be 0 on the vertical scale. Yes. The vertical scale is in log (base 10) units, so 0 corresponds to 1 death, since \\(\\log_{10} 1 = 0\\).Nice!  No. The vertical scale doesn’t mean anything.︎✘ You can see from the plotting command what the quantity on the vertical axis is: log10(confirmed) for the blue dots and log10(deaths) for the tan. One of the purposes of making a semi-log plot is to enable you to compare very large numbers with very small numbers on the same graph. For instance, in the semi-log plot, you can easily see when the first death occurred, a fact that is invisible in the plot of the raw counts (the first plot in this exercise). Another feature of semi-log plots is that they preserve proportionality. Look at the linear plot of raw counts and note that the curve for the number of deaths is much shallower than the curve for the number of (confirmed) cases. Yet on the semi-log plot, the two curves are practically parallel. On a semi-log plot, the arithmetic difference between the two curves tells you what the proportion is between those curves. The parallel curves mean that the proportion is practically constant. Calculate what the proportion between deaths and cases was in the month of May. Here’s a mathematical hint: \\(\\log_{10} \\frac{a}{b} == \\log_{10} a - \\log_{10} b\\). We are interested in \\(\\frac{a}{b}\\). Question C What is the proportion of deaths to cases during the month of May? about 1%︎✘ This would correspond to a (vertical) difference between the curves of about 2 log10 units. Is it really that big? about 2%︎✘ This would correspond to a (vertical) difference between the curves of about 1.7 log units. Is it really that big? about 5%Excellent! On the semi-log plot, the deaths curve is about 1.2 log10 units lower than the cases curve. \\(10^{-1.2} = 0.063 = 6.3\\%\\)) separates the two curves. about 25%︎✘ I’m not really sure what could lead you to this answer. You’re making a mistake that I didn’t anticipate. about 75%︎✘ It’s true that in May log10(deaths) is about 5, and log10(cases) is about 6, and 5/6 is indeed roughly 75%. But, on a log scale, the proportion relates to the difference between logs, not the ratio of logs. In many applications, people use semi-log plots to see whether a pattern is exponential or to compare very small and very large numbers. Often, people find it easier if the vertical scale is written in the original units rather than the log units. To accomplish both, the vertical scale can be ruled with raw units spaced logarithmically, like this: gf_point(confirmed ~ date, data = Covid_US %&gt;% filter(date &lt; as.Date(&quot;2020-06-30&quot;)), color = &quot;dodgerblue&quot;) %&gt;% gf_point(deaths ~ date, color = &quot;orange3&quot;) %&gt;% gf_refine(scale_y_log10()) The labels on the vertical axis show the raw numbers, while the position shows the logarithm of those numbers. The next question has to do with the meaning of the interval between grid lines on the vertical axis. Note that on the horizontal axis, the spacing between adjacent grid lines is half a month. Question D What is the numerical spacing (in terms of raw counts) between adjacent grid lines on the vertical axis? (Note: Two numbers are different by a “factor of 10” when one number is 10 times the other.\" Similarly, “a factor of 100” means that one number is 100 times the other. 10 cases︎✘ If this were true, moving up from the lowest label (1e+01, that is, 10) the next grid line would be at 20, then 30, then 40. 100 cases︎✘ If this were true, moving up from the lowest label (1e+01) the next grid line would be at 110, then 210, then 310. A factor of 10.Excellent! Right. Every time you move up by one grid line, the raw number increases ten-fold, so 10, 100, 1000, 10,000, and so on. The phrase a factor of 10 means to multiply by 10, not to add 10. A factor of 100.︎✘ You’re thinking along the right lines, but this is the difference between every second grid line, not adjacent grid lines. Exercise 15.5: RWESX Open a sandbox to carry out some calculations with Boyle’s data. To see how the data frame is organized, use the head(Boyle) and names(Boyle) commands. The scaffolding here contains a command for plotting out Boyle’s data. It also includes a command, gf_lm() that will add a graph of the best straight-line model to the plotted points. Recall that the # symbol turns what follows on the line into a comment, which is ignored by R. By removing the # selectively you can turn on the display of log axes. gf_point(pressure ~ volume, data = Boyle) %&gt;% gf_refine( # scale_x_log10(), # scale_y_log10() ) %&gt;% gf_lm() Question A In a sandbox, plot pressure versus volume using linear, semi-log, and log-log axes. Based on the plot, and the straight-line function drawn, which of these is a good model of the relationship between pressure and volume? linear︎✘ This would look like a straight line on linear axes. exponential︎✘ This would look like a straight line on semi-log axes. power-lawGood.  Exercise 15.6: gmZiWh Recall Robert Boyle’s data on pressure and volume of a fixed mass of gas held at constant pressure. In Section 15.5 of the text you saw a graphical analysis that enabled you to identify Boyle’s Law with a power-law relationship between pressure and volume: \\[P(V) = a V^n\\] On log-log axes, a power-law relationship shows up as a straight-line graphically. Taking logarithms translates the relationship to a straight-line function:\\[\\text{lnP(lnV)} = \\ln(a) + n\\, \\ln(V)\\] To find the parameter \\(n\\), you can fit the model to the data. This R command will do the job: fitModel(log(pressure) ~ log(a) + n*log(volume), data = Boyle) %&gt;% coefficients() Open a SANDBOX and run the model-fitting command. Then, interpret the parameters. Question A What is the slope produced by fitModel() when fitting a power law model? Roughly -1︎✘ You must be a very precise person! Almost exactly -1Nice!  About -1.5︎✘ I’m not sure how you arrived at this answer. Slope \\(&gt; 0\\)︎✘ You should be able to see from the graph you made in part (1) that the slope is negative. According to the appropriate model that you found in (A) and (B), interpret the function you found relating pressure and volume. Question B As the volume becomes very large, what happens to the pressure? Pressure becomes very small.Nice!  Pressure stays constant︎✘ You can see from the graph in part (A) that pressure does change with volume. Pressure also becomes large.︎✘ You can see from the graph in part (A) that pressure goes down as volume goes up. None of the above︎✘ Return to your use of fitModel() to find the slope of the straight-line fit to the appropriately log-transformed model. When you carried out the log transformation, you used the so-called “natural logarithm” with expressions like log(pressure). Alternatively, you could have used the log base-10 or the log base-2, with expressions like log(pressure, base = 10) or log(volume, base = 2). Whichever you use, you should use the same base for all the logarithmic transformations when finding the straight-line parameters. Question C (D) Does the slope of the straight line found by fitModel() depend on which base is used? NoNice!  Yes︎✘ Did you use the same base for both logarithms in your fitModel() expression? There’s no way to tell.︎✘ Yes, there is. Try using fitModel() with the different bases of log. Question D (E) Does the intercept of the straight line found by fitModel() depend on which base is used? YesExcellent! Good. But this will come out in the wash when you calculate the parameter \\(C\\) in \\(C x^b\\), since \\(C\\) will be either \\(2^\\text{intercept}\\) or \\(10^\\text{intercept}\\) or \\(e^\\text{intercept}\\) depending on the base log you use. No︎✘ Are you sure you tried different bases? Exercise 15.7: EWLCI Here is a plot of the power output (BHP) versus displacement (in cc) of 39 internal combustion engines. gf_point(BHP ~ displacement, data = Engines) %&gt;% gf_lims(y = c(0, 30000)) Question A Your study partner claims that the smallest engine in the data has a displacement of 2000 cc (that is, 2.0 liters) and 100 horsepower. Based only on the graph, is this claim plausible? Yes, because 2000 cc and 100 hp would look like (0, 0) on the scale of this graph.Nice!  Yes, because that size engine is typical for a small car.︎✘ That may be, but certainly you’ve encountered lawn mower engines that are much smaller. No, the smallest engine is close to 0 cc.︎✘ Would you be able to distinguish visually an engine of 1 cc from an engine of 1000cc on this graph? Both these values would lie on the same horizontal pixel in the graph. No, my study partner is always wrong.︎✘ Be that as it may, we’re looking for a principled answer, not an ad hominem one. Semi-log scales The next command will make a graph of the same engine data as before, but with a log scale on the horizontal axis. The vertical axis is still linear. gf_point(BHP ~ displacement, data = Engines) %&gt;% gf_refine(scale_x_log10()) Question B Using just the graph, answer this question: The engines range over how many decades of displacement? (Remember, a decade is a factor of 10.) 7 decadesCorrect.  Can’t tell︎✘ Yes, you can. Figure out what one decade corresponds to in terms of distance on the log axes. \\(10^7\\) decades︎✘ The estimated volume of the entire universe is about \\(4 \\times 10^{86}\\) cc. The volume of a neutron is about \\(6 \\times 10^{-81}\\) cc. The range between a neutron and the universe is therefore about \\(86 - -81 = 167\\) decades. Do you think it likely that there is an internal combustion engine smaller than a neutron or larger than the universe? About 3.5 decades︎✘ Perhaps you’re treating the distance between axis labels as one decade. Look carefully and you see that it’s actually a factor of 100, that is, two decades. Exercise 15.8: TLEXE Question A Consider the axis scales shown above. Which kind of scale is the horizontal axis? linearCorrect. You can see this because a given length along the axis corresponds to the same arithmetic difference regardless of where you are on the axis. the distance between 0 and 50 is exactly the same as the difference between 50 and 100, or the distance between 150 and 200. logarithmic︎✘ A clue that an axis is not logarithmic is that there is a zero marked. The log of zero is \\(-\\infty\\), which can’t appear on any actual graph. Another key is whether the scale shows doubling behavior. The distance between 50 and 100 represents one doubling: 100 is twice 50. If the scale were logarithmic, moving forward that same distance from 100 would bring you to 200. But that’s not what happens here. semi-logarithmic︎✘ “Semi-logarithmic” is not about a single axis but about two axes: horizontal and vertical. It means that one axis is linear while the other is logarithmic. log-log︎✘ “Log-log” is not about a single axis but about two axes. It means that both the horizontal and vertical axes are logarithmic. Question B Which kind of scale is the vertical axis? linear︎✘ Measure the distance from 30 to 50. If the scale were linear, then moving that same distance from 50 would bring you to 70, and moving that distance again would bring you to 90. But you can see that instead of reaching 90, you’d reach something greater than 100 on the scale. So the scale is not linear. logarithmicExcellent!  semi-logarithmic︎✘ “Semi-logarithmic” is not about a single axis but about two axes: horizontal and vertical. It means that one axis is linear while the other is logarithmic. log-log︎✘ “Log-log” is not about a single axis but about two axes. It means that both the horizontal and vertical axes are logarithmic. Question C Given your answers to the previous two questions, what kind of plot would be made in the frame being displayed at the top of this question? semi-logExcellent!  log-log︎✘ A log-log plot has log scales for both axes. The horizontal axis here is linear. linear-linear︎✘ No, the vertical axis is logarithmic. Exercise 15.9: SELIX The data frame SSA_2007 comes from the US Social Security Administration and contains mortality in the US as a function of age and sex. (“Mortality” refers to the probability of dying in the next year.) Open a sandbox and copy in the following scaffolding to see the organization of the data. data(SSA_2007) SSA_2007 Once you understand the data organization, delete the old scaffolding and insert this: data(SSA_2007) gf_point(Mortality ~ Age, color = ~ Sex, data = SSA_2007) There is a slight mistake in the way the command is written, so an error message will be generated. To figure out what’s wrong, read the error message, check the variable names, and so on until you successfully make the plot. Question A What was the mistake in the plotting command in the above code box? Variable names didn’t match the ones in the data.Right!  The tilde in the argument color = ~ sex︎✘ The color = argument is right. The value being used, ~ sex, is a one-sided formula and is used for things like color, shape, transparency, …. The data frame name is spelled wrong.︎✘ No. There is no function gf_point().︎✘ No. gf_point() is one of the more commonly used plotting functions Essay question tmp-1: What’s the obvious (simple) message of the above plot? Now you are going to use semi-log and log-log scales to look at the mortality data again. To do this, you will use the gf_refine() function. gf_point( __and_so_on__) %&gt;% gf_refine( scale_y_log10(), scale_x_log10() ) Fill in the __and_so_on__ details correctly and run the command in your sandbox. As written, both vertical and horizontal axes will be on log scales. This may not be what you want in the end. Arrange the plotting command to make a semi-log plot of mortality versus age. Interpret the plot to answer the following questions. Note that labels such as those along the vertical axis are often called “decade labels.” Question B The level of mortality in year 0 of life is how much greater than in year 1 and after? About twice as large.︎✘ Hint: How much is the change between successive labels on the y axis? About five times as large︎✘ Hint: How much is the change between successive labels on the y axis? About 10 times as largeExcellent!  About 100 times as large︎✘ Hint: How much is the change between successive labels on the y axis? Question C Near age 20, the mortality of males is how much compared to females? Less than twice as large.︎✘ Hint: Due to the nature of logs, a difference of half a decade corresponds to a change of \\(\\sqrt{10}\\). A bit more than three times as largeRight!  About 8 times as large︎✘ Hint: Due to the nature of logs, a difference of half a decade corresponds to a change of \\(\\sqrt{10}\\). About 12 times as large︎✘ Hint: Due to the nature of logs, a difference of half a decade corresponds to a change of \\(\\sqrt{10}\\). Question D Between the ages of about 40 and 80, how does mortality change with age? It stays about the same.︎✘ But the curve is sloping up, isn’t it? It increases as a straight line.︎✘ It would be fair to say this about the logarithm of mortality. But a straight line in log mortality means that mortality itself is increasing exponentially. It increases exponentially.Nice!  It increases, then decreases, then increases again.︎✘ Interesting that you would say this when the function in clearly monotonically increasing above age 30. Remake the plot of mortality vs age once again, but this time put it on log-log axes. The sign of a power-law relationship is that it shows up as a straight line on log-log axes. Question E Between the ages of about 40 and 80 is the increase in mortality better modeled by an exponential or a power-law process? Power-law︎✘ But it’s hard to find any straight line on the log-log plot. ExponentialRight! Right. The graph is much closer to a straight line on semi-log scales than on log-log scales. No reason to prefer one or the other.︎✘ One is much closer to a straight line than the other. Exercise 15.10: PeQJCA The graph comes from an online guide, “Retirement Income Analysis with Scenario Matrices,” published in 2019 by William F. Sharpe, winner of the Nobel Prize in economices in 1990. The guide is intended to be of interest to those planning for retirement income who also happen to have a sophisticated understanding of mathematics and computing. You may or may not be in the former group, but it is hoped that, as you follow this course, you are becoming a member of the later group. ## Warning in normalizePath(&quot;www/rismat-mortality.png&quot;): path[1]=&quot;www/rismat- ## mortality.png&quot;: No such file or directory Figure 15.11: Mortality rates for people aged 50+ in the US in 2009. The mortality rate is the probability of dying in one year. It’s shown here as a function of age and sex. As you can see, the graph shows nearly parallel straight-line functions for both women and men, with women somewhat less likely than men to die at any given age. Question A What is the format of the graphics axes? linear︎✘ The function might be linear, but we’re asking about the coordinate axes? semi-logCorrect.  log-log︎✘ The ‘age’ axis is linear. For instance, the interval from 50 to 55 is just as long on the axis as is the interval from 95 to 100. Question B If the age axis had been logged, which of the following would be true? The interval from 50 to 55 would be graphically larger than the interval from 95 to 100.Good.  The interval from 50 to 55 would be graphically smaller than the interval from 95 to 100.︎✘ The two intervals would have the same graphical length.︎✘ Question C At age 100, which of these is closest to the mortality rate for men? About 10%︎✘ The blue dot is well above the tick mark for a mortality of \\(10^{-1}\\). About 20%.︎✘ 20% would be the first tick mark above the \\(10^{-1}\\) mark. About 40%.Excellent! 40% is the third tick mark above the \\(10^{-1}\\) mark. About 60%︎✘ 60% is the *fifth tick mark abavoe the \\(10^{-1}\\) mark. Question D At age 65, women have a lower probability of dying than men. How much lower, proportionately? About 5% lower than men︎✘ About 15% lower than men.︎✘ You’re not taking into account the log scale of the vertical axis. About 40% lower than men.Right! Women have a mortality rate of 1% while the rate for men is just under 2%. Question E A rough estimate for the absolute limit of the human lifespan can be made by extrapolating the lines out to a mortality of 100%. This extrapolation would be statistically uncertain, and the pattern might change in the future either up or down, but let’s ignore that for now and simply extrapolate simply a line fitting the data from age 50 to 100. Which of these is the estimate made in that way for the absolute limit of the human lifespan?     105 years︎✘        110 years\\(\\heartsuit\\ \\)       120 years︎✘        130 years︎✘ Question F To judge from the graph, the function relating mortality to age is which of the following? A straight-line function with positive slope.︎✘ A power-law with a positive exponent.︎✘ That would be a straight line on log-log axes. An exponentially increasing function with a horizontal asymptote at mortality = 0.Nice! A straight-line on semi-log axes—what we have here—is diagnostic of an exponential function. The function value would go to zero for age = \\(- \\infty\\), but that mathematical fact is hardly relevant to human lifespan. An exponentially decaying function, with a horizontal asymptote at mortality = 100%.︎✘ 95.69 km/hr is exactly 60 mph.↩︎ Source: https://en.wikipedia.org/wiki/Daylight↩︎ Boyle’s notebooks are preserved at the Royal Society in London. The data in the Boyle dataframe have been copied from this source.)↩︎ "],["dimensions.html", "Chapter 16 Dimensions 16.1 Mathematics of quantity 16.2 Compound dimensions 16.3 Arithmetic with dimensions 16.4 Example: Dimensional analysis 16.5 Conversion: Flavors of 1 16.6 Dimensions and linear combinations 16.7 Exercises", " Chapter 16 Dimensions Next time you’re at a family gathering with your 10-year old cousin, give her the following math quiz. 1700 What’s 3 + 2? What’s 7 - 3? What’s 3 miles + 2 miles? What’s 3 miles + 2 kilometers? What’s 3 miles + 2 kilograms? I don’t know your cousin, but I suspect she will have an easy time answering (1) and (2) correctly. As for (3), she might give the correct answer, “5 miles,” or just say “5.” If so, you’ll follow up with “5 what?” at which point she’ll definitely say “miles.” is a bit harder. You might need to prompt her with the information that 1 kilometer is about 0.6 miles. Then, if she’s pretty smart, she’ll answer “4.2 miles.” 10-year olds are pretty creative, so I’m not sure how she’ll answer (5). But if you ask your Ph.D. aunt, she’ll answer along the lines of “silly question,” or “there’s no such thing.” That’s true. Consider these everyday quantities: 60 miles per hour: a typical speed for driving on a highway 2106 square feet: the in-bounds area for a court used for singles tennis. 355 cubic centimeters: the volume in a canned beverage (in the US). 2.5 gallons per minute: the US mandated maximum flow rate for water through a shower head. 35 miles per gallon: a typical fuel economy for a small car in the US. 0.044 lbs per square foot: the body-mass index of Dwayne (“The Rock”) Johnson. In the more conventional units of kg per square meter, his BMI is 30.8. Consider how you would measure such things: We ordinarily use a speedometer to measure instantaneous car speed and police use a radar gun. But fundamentally, you measure the distance traveled and the time used and divide distance by time. Most people would rely on the internet for this information, but you would check your local court by measuring the width (27 feet is the standard) and the length of the course (78). Multiply the two. Pour the beverage into a measuring cup and read off the volume. But more fundamentally, you could measure the circumference of the can (\\(2 \\pi r\\)), square it (\\(4 \\pi^2 r^2\\)) and divide by \\(4 \\pi\\) to get the cross section area of the can. Then multiply that by the height of the can. We don’t usually monitor water used by a shower. But if you need to, get a 5-gallon pail (the standard volume of the plastic pails used for so many purposes in construction), put it under the shower head, and measure the time it takes to fill the pail. Divide the volume by the time. Record the mileage on the car’s odometer when you fill up the car with gas. Drive. When you next get gas, measure the new odometer reading and the volume of gas you purchased. Divide the change in odometer reading by the gas volume. (In Europe, you would divide the gas volume by the change in odometer reading.) Weigh Dwayne. The scale is usually graduated in both pounds and kilograms: take your choice. Measure his height; the ruler-in-the-doorway method works well. Then divide his weight by the square of his height. Evidently, it makes sense to multiply and divide different types of quantities: feet, gallons, kilometers, kilograms, pounds, hours, …. But you won’t ever see a quantity constructed by adding or subtracting miles and hours or gallons and and square feet. You can square feet and cube centimeters, but can you take the square root of a gallon? Does it make sense to raise 2 to the power of 3 yards? 1710 This section is about the mathematical structure of combining quantities; which kinds of mathematical operations are legitimate and which are not. 16.1 Mathematics of quantity [Fun-10a] Know the definition of a fundamental dimension and the notation for the most common ones (definition page 241-242) [Fun-10b] Understand how derived dimensions are formed from fundamental dimensions (definition page 241-242) [Fun-10c] Know that units are ways of measuring dimensions and derived dimensions. The first step in understanding the mathematics of quantity is to make an absolute distinction between two concepts that, in everyday life, are used interchangeably: dimension and unit. Length is a dimension. Meters is a unit of length. We also measure length in microns, mm, cm, inches, feet, yards, kilometers, and miles, to say nothing of furlongs, fathoms, astronomical units (AU), and parsecs. Time is a dimension. Seconds is a unit of time. We also measure time in micro-seconds, milli-seconds, minutes, hours, days, weeks, months, years, decades, centuries, millenia. Mass is a dimension. Kilograms is a unit of mass. Length, time, and mass are called fundamental dimensions. This is not because length is more important than area or volume. It’s because you can construct area and volume by multiplying lengths together. This is evident when you consider units of area like square-inches or cubic centimeters, but obscured in the names of units like acre, liter, gallon. We use the notation L, T, and M to refer to the fundamental dimensions. (Electrical current Q is also a fundamental dimension, but we won’t have much use for it in our examples. Also useful are \\(\\Theta\\) (“theta”) for temperature, S for money, and P for a count of organisms such as the population of the US or the size of a sheep herd.) Brackets translate between a quantity and the dimension. For instance, [1 yard] = L, [1000 kg] = M, [3 years] = T, [10 \\(\\mu\\) (microns)] = L, 16.2 Compound dimensions There are other dimensions: volume, force, pressure, energy, torque, velocity, acceleration, and such. These are called compound dimensions because we represent them as combinations of the fundamental dimensions, L, T, and M. The notation for these combinations involves multiplication and division. For instance: Volume is L \\(\\times\\) L \\(\\times\\) L \\(=\\) L\\(^3\\), as in “cubic centimeters” Velocity is L/T, as in “miles per hour” Force is M L/T\\(^2\\), which is obscure unless you remember Newton’s Second Law that \\(\\text{F} = \\text{m}\\,\\text{a}\\): “force equals mass times acceleration.” In terms of dimension, mass is M, acceleration is L/T\\(^2\\). Multiply the two together and you get the dimension “force.” Multiplication and division are used to construct a compound dimension from the fundamental dimensions L, T, and M. Addition and subtraction are never used to form a compound dimension. Much of the work in understanding dimensions involves overcoming the looseness of everyday speech. Remember the weight scale graduated in pounds and kilograms. The unit kilograms is a way of measuring M, but the unit of pounds is a way of measuring force: M L/T\\(^2\\). Weight is not the same as mass. This makes no sense to most people and doesn’t really matter in everyday life. It’s only when you venture off the surface of the Earth that the difference shows up. The Mars rover Perseverence has a weight of 1000 kg on Earth. It was weightless for most of its journey to Mars. After landing on Mars, Perseverence weighed just 380 kg. But the rover’s mass didn’t change at sll. 1720 Another source of confusion carried over from everyday life is that sometimes we measure the same quantity using different dimensions. You can measure a volume by weighing water; a gallon of water weighs 8 pounds, a liter of water has a mass of 1 kg. Serious bakers measure flour by weight; a casual baker uses a measuring cup. We can measure water volume with length because water has a (more-or-less) constant mass density. But 8 pounds of gasoline is considerably more than a gallon. It turns out that the density of flour varies substantially depending on how it’s packed, on humidity, etc. This is why it matters whether you weigh flour for baking or measure it by volume. You can measure time by the swing of a pendulum. To measure the same time successfully with different pendula they need to have the same length, not the same mass. A unit is a conventional amount of a quantity of a given dimension. All lengths are the same dimensionally, but they can be measured with different conventions: inches, yards, meters, … Units for the same dimension can all be converted unambiguously one into the other. A meter is exactly the same quantity of length as 39.3701 inches, a mile is the same length as 1609.34 meters. Liters and gallons are both units of volume (L\\(^3\\)): a gallon is the same as 3.78541 liters. You will hear it said that a kilogram is 2.2 pounds. That’s not strictly true. A kilogram has dimension M and a pound has dimension ML/T\\(^2\\). Quantities with different dimensions cannot be “equal” or even legitimately compared to one another. Unless you bring something else into the game that physically changes the situation, for instance gravity (dimension of acceleration due to gravity (dimension \\(\\text{L}/\\text{T}^2\\)). The weight of a kilogram on the surface of the Earth is is 2.2 pounds because gravitational acceleration is (almost) the same everywhere on the surface of the Earth. It’s also potentially confusing that sometimes different dimensions are used to get at the same idea. For instance, the same car that gets 35 miles / gallon in the US (dimension \\(\\text{L}/\\text{L}^3 = 1/\\text{L}^2\\)) will use 6.7 liters per 100 kilometers (\\(\\text{L}^3 / L = \\text{L}^2\\)) in Europe. Same car. Same fuel. Different conventions using different dimensions. 1730 Keeping track of the various compound dimensions can be tricky. For many people, it’s easier to keep track of the physical relationships involved and use that knowledge to put together the dimensions appropriately. Often, the relationship can be described using specific calculus operations, so knowing dimensions and units helps you use calculus successfully. Easy compound dimensions that you likely already know: [Area] \\(= \\text{L}^2\\). Some corresponding units to remind you: “square feet”, “square miles”, “square centimeters.” [Volume] \\(= \\text{L}^3\\). Units to remind you: “cubic centimeters”, “cubic feet”, “cubic yards.” (What landscapers informally call a “yard,” for instance “10 yards of topsoil” should properly be called “10 cubic-yards of topsoil.”) [Velocity] \\(= \\text{L}/\\text{T}\\). Units: “miles per hour,” “inches per second.” [Momentum] \\(= \\text{M}\\text{L}/\\text{T}\\). Units: “kilogram meters per second.” Anticipating that you will return to this section for reference, we’ve also added some dimensions that can be understood through the relevant calculus operations. [Acceleration] \\(= \\text{L}/\\text{T}^2\\). Units: “meters per second squared,” In calculus, acceleration is the derivative of velocity with respect to time, or, equivalently, the 2nd derivative of position with respect to time. [Force] \\(= \\text{M}\\, \\text{L}/\\text{T}^2\\) In calculus: force is the derivative of momentum with respect to time. [Energy] or [Work] \\(= \\text{M}\\, \\text{L}^2/\\text{T}^2\\) In calculus, energy is the integral of force with respect to length. [Power] \\(= \\text{M}\\, \\text{L}^2/\\text{T}^3\\) In the language of calculus, power is the derivative of energy with respect to time. Density sounds like a specific concept, but there are many different kinds of densities. These have in common that they are a ratio of a physical amount to a geometric extent: 1740 a physical amount: which might be mass, charge, people, etc. a geometric extent: which might be length, area, or volume. Some examples: “paper weight” is the mass per area, typically grams-per-square-meter “charge density” is the amount of electrical charge, usually per area or volume “lineal density of red blood cells” is the number of cells in a capillary divided by the length of the capillary. (Capillaries are narrow. Red blood cells go through one after the other.) “population density” is people per area of ground. The theory of dimensions and units was developed for the physical sciences. Consequently the fundamental dimensions are those of physics: length, mass, time, electrical current, luminous intensity. Since proper use of units is important even outside the physical sciences, it’s helpful to recognize the dimension of several other kinds of quantity. “people” / “passengers” / “customers” / “patients” / “cases” / “passenger deaths”: these are different different ways to refer to people. We’ll consider such quantities to have dimension P, for population. “money”: Units are dollars (in many varieties: US, Canadian, Australian, New Zealand), euros, yuan (synonym: renminbi), yen, pounds (many varieties: UK, Egypt, Syria, Lebanon, Sudan and South Sudan), pesos (many varieties), dinar, franc (Swiss, CFA), rand, riyal, rupee, won, and many others. Conversion rates depend on situation and national policy, but we will consider money a dimension, denoted by S (from the name of the first coinage, the Mesopotanian Shekel). Examples: Passenger-miles is a standard unit of transport. Passenger-miles-per-dollar is an appropriate unit of the economic efficiency of transport. Passenger-deaths per million passenger-mile is one way to describe the risk of transport. 16.3 Arithmetic with dimensions Recall the rules for arithmetic dimensioned quantities. We restate them briefly with the square-bracket notation for “the dimension of.” For instance, “the dimension of \\(b\\)” is written \\([b]\\). We also write \\([1]\\) to stand for the dimension of a pure number, that is, a quantity without dimension. Operation Result Only if satisfies Metaphor Multiplication \\([a \\times b] = [a] \\times [b]\\) anything goes promiscuous Division \\([a \\div b] = [a] \\div [b]\\) anything goes promiscuous Addition \\([a + b] = [a]\\) \\([a] = [b]\\) monogomous Subtraction \\([a - b] = [a]\\) \\([a] = [b]\\) monogomous Trigonometric \\([\\sin(a)] = [1]\\) \\([a] = [1]\\) celibate Exponential \\([e^a] = [1]\\) \\([a] = [1]\\) (of course, \\([e] = [1]\\)) celibate Power-law \\([b ^ a] = \\underbrace{[b]\\times[b]\\times ...\\times [b]}_{a\\ \\ \\text{times}}\\) \\([a] = [1]\\) with \\(a\\) an integer exponent celibate Square root \\([\\sqrt{b}] = [c]\\) \\([b] = [c\\times c]\\) idiosyncratic Cube root \\([\\sqrt[3]{b}] = [c]\\) \\([b] = [c \\times c \\times c]\\) idiosyncratic Hump \\([\\text{hump}(a)] = [1]\\) \\([a] = [1]\\) celibate Sigmoidal \\([\\text{sigmoid}(a)] = [1]\\) \\([a] = [1]\\) celibate 16.4 Example: Dimensional analysis We want to relate the period (in T) of a pendulum to it’s length and mass. Acceleration due to gravity also plays a role; that has dimension \\(\\text{L}\\cdot \\text{T}^{-2}\\). For simplicity, we’ll assume that only the bob at the end of the pendulum cable or rod has mass. 1750 The analysis strategy is to combine the four quantities we think play a role into one total quantity that is dimensionless. Since it is dimensionless, it can be constant regardless of the mass, length, period, gravity of each individual situation. \\[\\text{[Period]}^a \\cdot \\text{[Mass]}^b \\cdot \\text{[Length]}^c \\cdot \\text{[Gravity]}^d = T^a \\cdot M^b \\cdot L^c \\cdot L^d \\cdot T^{-2d} = [1]\\] To be dimensionless: \\(c = -d\\), cancel out the L \\(a = 2d\\), cancel out the T \\(b=0\\), there’s no other mass term, and we need to cancel out the M All of the exponents can be put in terms of \\(d\\). That doesn’t tell us what \\(d\\) should be, but whatever value for \\(d\\) we decide to choose, we get a ratio that’s equivalent to: \\[ \\frac{[\\text{Gravity}]\\cdot [\\text{Period}]^2}{[\\text{Length}]} = [1]\\] This is a relationship between dimensions of quantities. To render it into a formula involving the quantities themselves we need to take into account the units. \\[ \\frac{\\text{Gravity}\\cdot \\text{Period}^2}{\\text{Length}} = B\\] We can experimentally determine the numerical value of the dimensionless constant \\(B\\) by measuring the period and length of a pendulum and (on Earth) recognizing that gravitational acceleration on Earth’s surface is 9.8 meters-per-second-squared. Such experiment and mathematical models using differential equations give \\(B = (2\\pi)^2\\). 16.5 Conversion: Flavors of 1 Numbers are dimensionless but not necessarily unitless. Failure to accept this distinction is one of the prime reasons people have trouble figuring out how to convert from one unit to another. 1760 The number one is a favorite of elementary school students because its multiplication and division tables are completely simple. Anything times one, or anything divided by one, is simply that thing. Addition and subtraction are pretty simple, too, a matter of counting up or down. When it comes to quantities, there’s not just one one but many. And often they look nothing like the numeral 1. Some examples of 1 as a quantity: \\(\\frac{180}{\\pi} \\frac{\\text{degrees}}{\\text{radians}}\\) \\(0.621371 \\frac{\\text{mile}}{\\text{kilometer}}\\) \\(3.78541 \\frac{\\text{liter}}{\\text{gallon}}\\) \\(\\frac{9}{5} \\frac{^\\circ F}{^\\circ C}\\) \\(\\frac{1}{12} \\frac{\\text{dozen}}{\\text{item}}\\) I like to call these and others different flavors of one. In every one of the above examples, the dimension of the numerator matches the dimension of the denominator. The same is true when comparing feet and meters ([feet / meter] is L/L = [1]), or comparing cups and pints ([cups / pint] is \\(\\text{L}^3/\\text{L}^3 = [1]\\)) or comparing miles per hour and feet per second ([miles/hour / ft per sec] = L/T / L/T = [1]). Each of these quantities has units but it has no dimension. It’s helpful to think about conversion between units as a matter of multiplying by the appropriate flavor of 1. Such conversion will not change the dimension of the quantity but will render it in new units. Example: Convert 100 feet-per-second into miles-per-hour. First, write the quantity to be converted as a fraction and alongside it, write the desired units after the conversion. In this case that will be \\[100 \\frac{\\text{feet}}{\\text{second}} \\ \\ \\ \\text{into} \\ \\ \\ \\frac{\\text{miles}}{\\text{hour}}\\] First, we’ll change feet into miles. This can be accomplished by multiplying by the flavor of one that has units miles-per-foot. Second, we’ll change seconds into hours. Again, a flavor of 1 is involved. What number will give a flavor of one? One mile is 5280 feet, so \\[\\frac{1}{5280} \\frac{\\text{miles}}{\\text{foot}}\\] is a flavor of one. Next, we need a flavor of one that will turn \\(\\frac{1}{\\text{second}}\\) into \\(\\frac{\\text{1}}{\\text{hour}}\\). We can make use of a minute being 60 seconds, and an hour being 60 minutes. \\[\\underbrace{\\frac{60\\ \\text{s}}{\\text{minute}}}_\\text{flavor of 1}\\ \\underbrace{\\frac{60\\ \\text{minutes}}{\\text{hour}}}_\\text{flavor of 1} = \\underbrace{3600\\frac{\\text{s}}{ \\text{hour}}}_\\text{flavor of 1}\\] Multiplying our carefully selected flavors of one by the initial quantity, we get \\[ \\underbrace{\\frac{1}{5280} \\frac{\\text{mile}}{\\text{foot}}}_\\text{flavor of 1} \\times \\underbrace{3600 \\frac{\\text{s}}{\\text{hour}}}_\\text{flavor of 1} \\times \\underbrace{100 \\frac{\\text{feet}}{\\text{s}}}_\\text{original quantity} = 100 \\frac{3600}{5280} \\frac{\\text{miles}}{\\text{hour}} = 68.18 \\frac{\\text{miles}}{\\text{hour}}\\] 16.6 Dimensions and linear combinations Low-order polynomials are a useful way of constructing model functions. For instance, suppose we want a model of the yield of corn in a field per inch of rain over the growing season, will call it corn(rain). The output will have units of bushels (of corn). The input will have units of inches (of rain). A second-order polynomial will be appropriate for reasons to be discussed in Chapter ??. 1770 \\[\\text{corn(rain)} \\equiv a_0 + a_1\\, \\text{rain} + \\frac{1}{2} a_2\\, \\text{rain}^2\\] Of course, the addition in the linear combination will only make sense if all three terms \\(a_0\\), \\(a_1\\,\\text{rain}\\), and \\(\\frac{1}{2}\\, a_2\\, \\text{rain}^2/2\\) have the same dimension. But clearly \\([\\text{rain}] \\neq [\\text{rain}^2]\\). In order for things to work out, the coefficients must themselves have dimension. We know the output of the function will have dimension \\([\\text{volume}] = \\text{L}^3\\). Thus, \\([a_0] = \\text{L}^3\\). \\([a_1]\\) must be different, because it has to combine with the \\([\\text{rain}] = \\text{L}\\) and produce \\(\\text{L}^3\\). Thus, \\([a_1] = \\text{L}^2\\). Finally, \\([a_2] = \\text{L}\\). Multiplying that by \\([\\text{rain}]^2\\) will give the required \\(\\text{L}^3\\) In everyday communication as well as in most domains such as construction, geography, navigation, and astronomy we measure angles in degrees. 90 degrees is a right angle. But in mathematics, the unit of angle is radians where a right angle is 1.5708 radians. (1.5708 is the decimal version of \\(\\pi/2\\).) The conversion function, which we’ll call raddeg(), is \\[\\text{raddeg}(r) \\equiv \\frac{180}{\\pi} r\\] The function that converts degrees to radians, which we’ll call degrad() is very similar: \\[\\text{degrad}(d) \\equiv \\frac{\\pi}{180} d\\] (Incidentally, \\(\\frac{180}{\\pi} = 57.296\\) while \\(\\frac{\\pi}{180} = 0.017453\\).) In traditional notation, the trigonometric functions such as \\(\\sin()\\) and \\(\\tan()\\) can be written with an argument either in degrees or radians. For instance, \\(\\sin(90^\\circ) = \\sin\\left(\\frac{\\pi}{2}\\right)\\). Similarly, for the inverse functions like \\(\\arccos()\\) the units of the output are not specified. This works because there is always a human to intervene between the written expression and the eventual computation. In R, as in many other computer languages like Python or spreadsheet packages, there is no valid expression like sin(90 deg). In these languages, 90 deg is not a valid expression (although it might be good if it were valid!). In these and many other languages, angles are always given in radians. Such consistency is admirable, but people are not always so consistent. It is a common source of computer bugs that angles in degrees are handed off to functions like \\(\\sin()\\) and that the output of \\(\\arccos()\\) is (wrongly) interpreted as degrees rather than radians. 1780 Function composition to the rescue! Consider this function given in the Wikipedia article on the position of the sun as seen from Earth.24 \\[\\delta_\\odot(n) \\equiv - 23.44^\\circ \\cdot \\cos \\left [ \\frac{360^\\circ}{365\\, \\text{days}} \\cdot \\left ( n + 10 \\right ) \\right ]\\] Where \\(n\\) is zero at the midnight marking New Years and increases by 1 per day. (The \\(n+10\\) has units of days and translates New Years back 10 days, to the day of the winter solstice.) \\(\\delta_\\odot()\\) gives the declination of the sun: the latitude pieced by an imagined line connecting the centers of the earth and the sun. The Wikipedia formula is well written in that it uses some familiar numbers to help the reader see where the formula comes from. 365 is recognizably the length of the year in days. \\(360^\\circ\\) is the angle traversed when making a full cycle around a circle. \\(23.44^\\circ\\) is less familiar, but the student of geography might recognize it as the latitude of the Tropic of Cancer, the latitude farthest north where the sun is directly overhead at noon (on the day of the summer solstice). But there’s a world of trouble for programmer who implements the formula as dec_sun &lt;- makeFun(-23.44 * cos((360/365)*(n+10)) ~ n) For instance, the equinoxes are around March 21 (n=81) and Sept 21 (n=264). On an equinox, the delination of the sun is zero degrees. But let’s plug \\(n=81\\) and \\(n=264\\) into the formula and see what we get. dec_sun(81) ## [1] 5.070321 dec_sun(264) ## [1] -23.38324 The equinoxes aren’t even equal! And they are not close to zero. Does this mean astronomy is wrong? The Wikipedia formula should have been programmed this way, using 2 \\(\\pi\\) radians instead of 360 degrees in the argument to the cosine function: dec_sun_right &lt;- makeFun(-23.44 * cos(( 2*pi / 365)*(n+10)) ~ n) dec_sun_right(81) ## [1] -0.1008749 dec_sun_right(264) ## [1] -0.1008749 The deviation of one-tenth of a degree reflects rounding off the time of the equinox to the nearest day. 16.7 Exercises Exercise 16.1: mHACgC You are designing a pendulum for a planned joint NASA/ESA mission to Mars. From the orbital period and radius of Mars, its mass is known. From the mass and the observed diameter of the planet, gravitational acceleration at the surface is calculated as 3.721 m/s\\(^2\\). According to Section 16.4, the period is \\(\\text{Period} = 2 \\pi \\sqrt{\\frac{\\text{Length}}{\\text{Gravity}}}\\). The length of your pendulum is 3 feet. Question A What will be the period of your pendulum when it eventually gets to Mars? (Hint: Don’t make the mistake of the engineers working on the Mars Polar Lander and forget to resolve the different units of length presented in the problem.)     1.3 seconds︎✘        1.9 seconds︎✘        3.1 seconds\\(\\heartsuit\\ \\)       9.1 seconds︎✘ Question B What is the period of your pendulum on Earth?     1.3 seconds︎✘        1.9 seconds\\(\\heartsuit\\ \\)       3.1 seconds︎✘        9.1 seconds︎✘ Exercise 16.2: UGDKY For each mathematical operation, identify the operation as valid or invalid according to the rules of dimensional arithmetic. Question A In this formula \\[\\frac{8 \\text{m} - 2.5 \\text{km}}{2 \\text{min} - 32 \\text{s}}\\] choose which rule (if any) is violated. Addition or Subtraction rule︎✘ Both the numerator and denominator are valid subtractions, with dimension L and T respectively. Multiplication or Division rule︎✘ There are no restrictions for multiplication and division, so a formula can hardly violate them! Exponential︎✘ There’s no exponent here. It’s valid. No rules are violated.Good.  Question B In this formula \\[\\frac{3 \\text{g} \\times 2 \\text{m}}{3 \\text{km}^2}\\] choose which rule (if any) is violated. Addition or Subtraction rule︎✘ No addition or subtraction here. Multiplication or Division rule︎✘ There are no restrictions for multiplication and division, so a formula can hardly violate them! Exponential︎✘ There’s no exponent here. It’s valid. No rules are violated.Excellent!  Question C For this formula \\[10^{\\frac{4 \\text{hr}}{3 \\text{g}}}\\] choose which rule (if any) is violated. Addition or Subtraction rule︎✘ No addition in this formula. Multiplication or Division rule︎✘ There are no restrictions for multiplication and division, so a formula can hardly violate them! ExponentialCorrect. The exponent is 4 ft / 3 g, which has dimension L / M. Exponents must always have dimension [1]. It’s valid. No rules are violated.︎✘ Question D In this formula \\[6^{\\frac{2 \\text{hr}}{3 \\text{min}}}\\]choose which rule (if any) is violated. Addition or Subtraction rule︎✘ No addition or subtraction in this formula. Multiplication or Division rule︎✘ There are no restrictions for multiplication and division, so a formula can hardly violate them! Exponential︎✘ The exponent is 4 hr/3 min, which has dimension T/T = [1]. So the rule is satisfied. It’s valid. No rules are violated.Excellent!  Question E In this formula \\[5 \\text{g} \\times 3 \\text{kg} - 7 \\text{lbs}\\] choose which rule (if any) is violated. Addition or Subtraction ruleRight! You can’t subtract M from M\\(^2\\). (Strictly speaking, lbs has dimension of force, \\(M L^2 / T^2\\), but you can’t subtract force from M\\(^2\\) either. Multiplication or Division rule︎✘ There are no restrictions for multiplication and division, so a formula can hardly violate them! Exponential︎✘ There’s no exponent here. It’s valid. No rules are violated.︎✘ Question F In this formula \\[\\sqrt[3]{8 m^3 + 27 \\text{ft}^2}\\] choose which rule (if any) is violated. Addition or Subtraction ruleNice! You can’t add L\\(^3\\) to L\\(^2\\). Multiplication or Division rule︎✘ There are no restrictions for multiplication and division, so a formula can hardly violate them! Exponential︎✘ Maybe you’re thinking that the cube-root rule is violated, but since the quantity in the cube root is invalid, the root doesn’t do anything additionally wrong. It’s valid. No rules are violated.︎✘ Exercise 16.3: DVGKY Question A The dimension of \\(t\\) is T, that is, \\([t] = T\\). What must the dimension of \\(k\\) be in \\(e^{kt}\\) for the operation to make sense? [1]︎✘ Then \\([k\\,t] = \\text{T}\\), which would violate the exponential rule. T\\(^{-1}\\)Correct. Right, [k] needs to cancel out [t] so that the exponention is valid. T︎✘ Then \\([k\\,t] = \\text{T}\\)^2$, which would violate the exponential rule. None of the above︎✘ Question B What must the dimension of \\(c\\) for the arithmetic operation \\(1 + c \\cdot 2^{k\\,t}\\) to make sense? [1]Nice! Right. You’re going to have to add \\(c \\cdot 2^{kt}\\) to 1. Since \\([k\\,t] = [1]\\), \\(c\\) also needs to be dimensionless. T\\(^{-1}\\)︎✘ T︎✘ Then $[k,t] = \\(T^2\\), which would violate the exponential rule. Depends on the dimension of \\(2^{kt}\\)︎✘ We already determined that \\([kt] = [1]\\), so \\([2^{kt}] = [1]\\). Exercise 16.4: KGYKY The surface area \\(S\\) of a mammal is reasonably well approximated by the function \\[S(M) \\equiv k M^{2/3}\\] where \\(M\\) is the body mass (in kg) and the constant \\(k\\) depends on the particular species under consideration. Note that \\(M^{2/3}\\) is not an allowed arithmetic operation. \\([M] = \\text{mass}\\), and mass, like any other dimension, cannot be raised to a non-integer power. More properly, the expression should be written \\[\\left(\\frac{M}{1\\ kg}\\right)^{2/3}\\] The division by “1 kg” renders dimensionless the quantity in the parentheses: \\[\\left[\\frac{M}{1\\ kg}\\right] = 1\\] In order to render the quantity both dimensionless and unitless, \\(M\\) should be specified in kg. The usual practice is to skip the “1 kg” business and simply say, “Where \\(M\\) is in kg.” You will see such notation frequently in your career and should take care to use the indicated units. You’ll need to open a computing sandbox to do the calculations. Question A Consider a baby and an adult. The adult’s mass is \\(8\\) times greater than the baby’s. Then the adult’s surface area is …? The same as the baby’s︎✘ 1.5 times of the baby’s︎✘ 4 times the baby’sCorrect.  8 times the baby’s︎✘ Question B Consider a human of body mass 70 kg with a skin surface area of 18,600 cm2. Which of the following units for the constant of proportionality \\(k\\) is correct? cm\\(^2\\) kg\\(^{-2/3}\\)︎✘ Kilograms to a fractional power is not a sensible unit. cm\\(^2\\)Right!  cm\\(^2\\) kg\\(^{2/3}\\)︎✘ When you multiply \\((70 kg/kg)^{2/3}\\) by \\(k\\), you need to get a result in \\(cm^2\\). kg\\(^{-1}\\)︎✘ Would this produce \\(cm^2\\) for the result? Question C In the units of part (B), which value is \\(k\\) closest to?     1︎✘        10︎✘        100︎✘        1000\\(\\heartsuit\\ \\) The numerical value of the constant \\(k\\) changes depending on what units you want to express it in. The value you found in part (C) works for masses stated in kg and skin areas in cm\\(^2\\). Suppose you want to figure out a value of \\(k&#39;\\) that you can use in the formula for people who are used to talking about skin area in square inches and mass in pounds. The units of \\(k\\) are cm\\(^2\\), and we want the units of \\(k&#39;\\) to be in\\(^2\\). That part is easy: just multiply \\(k\\) by two flavors of one to change the units from cm to inches, like this: \\[k&#39; = k\\ \\underbrace{\\frac{\\text{in}}{2.6 \\text{cm}}}_\\text{flavor of 1}\\ \\underbrace{\\frac{\\text{in}}{2.6 \\text{cm}}}_\\text{flavor of 1} = \\frac{k}{2.6^2}\\] where the flavor of 1 reflects that 1 inch is 2.6 cm. But this is not the whole story. We have to be very careful in dealing with the \\(\\left(\\frac{M}{1 kg}\\right)^{2/3}\\). Translated to pounds, \\(M = 70\\ \\text{kg} = 154\\ \\text{lbs}\\), since, in the rough-and-ready way everyday people express themselves, 1 kg \\(\\approx\\) 2.2 lbs.25 Plugging in \\(M=154\\) lbs makes the power-law part of the formula for skin area \\[\\left(\\frac{154\\ \\text{lbs}}{1\\ \\text{kg}}\\right)^{2/3}\\] You can’t take (pounds)\\(^{2/3}\\) or (kg)\\(^{2/3}\\); you won’t get a sensible unit in either case. But [pounds/kg] = [1], so taking the two-thirds power of the ratio is perfectly legitimate. Still, there’s a problem. Multiplying \\(k\\ 154^{2/3} (\\text{lbs}/\\text{kg})^{2/3}\\) has the right dimension, but strange-looking units that have nothing to do with skin area. The resolution to this paradox is to multiply \\(\\frac{154\\ \\text{lbs}}{1\\ \\text{kg}}\\) by an appropriate flavor of 1 to render the dimensionless quantity unitless as well as dimensionless. This flavor will be \\(\\frac{1 \\text{kg}}{2.2 lbs}\\), giving a formula for skin area in square inches: ## Warning in normalizePath(&quot;www/EQ-cancel.png&quot;): path[1]=&quot;www/EQ-cancel.png&quot;: No ## such file or directory Question D Optional challenge) Assuming that \\(k = 1000 \\text{cm}^2\\) when specifying mass in kilograms, what should be the numerical value of \\(k&#39;\\) in square-inches that should be used when body mass is given in pounds?     8.7︎✘        87\\(\\heartsuit\\ \\)       870︎✘        8700︎✘        87000︎✘ Exercise 16.5: JELCI The “Energy-maneuverability Theory” (E-M) of aircraft performance was developed by renowned fighter pilot Col John Boyd and mathematician Thomas Christie in the 1960s. The theory posits that the available maneuverability of an aircraft is closely related to its specific energy \\(E_s\\), that is, the kinetic plus potential energy of the aircraft divided by aircraft weight. To be highly maneuverable, an aircraft must be able to change it’s specific energy rapidly in time. Let’s call this ability the specific power (that is, power divided by mass), \\(P_s\\). An aircraft with large \\(P_s\\) is more maneuverable than one with small \\(P_s\\). An important formula in E-M Theory is \\[P_s = \\frac{T - D}{W} V\\] where \\(T\\) is aircraft thrust, \\(D\\) is drag, \\(W\\) is weight, and \\(V\\) is velocity. \\((T-D)\\), thrust minus drag, is the net forward force on the aircraft. Recall these facts about the dimension of physical quantities: Velocity has dimension \\(L^1 T^{-1}\\) (e.g. meters per second) Acceleration has dimension \\(L^1 T^{-2} =\\) [Velocity] \\(\\times\\ T^{-1}\\) (e.g. meters per second-squared) Force has dimension \\(M \\times\\ \\) [Acceleration] Energy has dimension [Force] \\(\\times\\ L\\) Power has dimension [Energy] \\(\\times\\ T^{-1}\\). Question A Which of the following is a correct dimensional formulation of power?     [Force][Velocity]\\(\\heartsuit\\ \\)       [Energy][Velocity]︎✘        [Force] / [Velocity]︎✘        [Energy] / [Velocity]︎✘ Question B What is the dimension of \\(P_s\\) in E-M Theory? [Power] \\(\\times\\ M^{-1}\\)Correct. In other words, specific power, that is, power per mass. [Force] \\(\\times\\) [Acceleration]︎✘ Just so you know, such a dimension is rarely, if ever, encountered in practice. [Force] \\(\\times\\) [Velocity]︎✘ You’re leaving out the division by \\(W\\) in the E-M Theory formula. [Power]︎✘ Exercise 16.6: aNEcW1 Newton’s law of universal gravitation—also known as the inverse square law—is generally written \\[F = G \\frac{m_1\\ m_2}{r^2} .\\] \\(m_1\\) and \\(m_2\\) are the masses of the two objects (say, Earth and Sun). \\(r\\) is the distance between the two objects (about 150,000,000 km). \\(F\\) is the gravitational force and \\(G\\) is a fixed quantity called the “gravitational constant.” Of course, you already know the dimension of force, mass, and distance. Question A What is the dimension of the gravitational constant, \\(G\\)? \\(L^3\\ M^{-1}\\ T^{-2}\\)Nice!  \\(L^2\\ M^{-2}\\)︎✘ Remember, \\(G m_1 m_2 / r^2\\) has to have the same dimensions as force. \\(L^2\\ M^{2}\\ T^{-2}\\)︎✘ Check your signs! \\(L^2\\ M^{-2}\\ T^{-2}\\)︎✘ Question B The quantity \\(G\\) is \\(6.674 \\times 10^{−11}\\) when \\(L\\) is in meters, \\(M\\) is in kilograms, and \\(T\\) in seconds. What is the gravitational force between Earth (mass \\(6 \\times 10^{24}\\) kg) and Sun (mass \\(2\\times 10^{30}\\) kg) ? \\(3.6 \\times 10^{28}\\) NewtonsCorrect.  \\(3.6 \\times 10^{31}\\) meters︎✘ \\(3.6 \\times 10^{28}\\) meters per second-squared︎✘ \\(3.6 \\times 10^{31}\\) meter seconds per kg︎✘ Exercise 16.7: VA9Dxi In this book, we are parameterizing the sinusoid using the period \\(P\\), the duration a cycle. In many settings, such as communications engineering and physics, it is preferable to parameterize in terms of the frequency, often written with the Greek letter \\(\\omega\\) (“omega”). Here’s the relationship: \\[\\sin\\left(\\frac{2\\pi}{P} t\\right) = \\sin(2\\pi \\omega t)\\] Question A When the input quantity \\(t\\) represents time, it has dimension T. The period P has the same dimension so that the overall argument to \\(\\sin()\\) is dimensionless, as required. What is the dimension of \\(\\omega\\)?     T︎✘        T\\(^2\\)︎✘        T\\(^{-1}\\)\\(\\heartsuit\\ \\)       T\\(^{-2}\\)︎✘ In an earlier exercise, we looked at human breathing. The period of a breathing cycle differs from hour to hour and from person to person. (It’s also somewhat, but not completely, under conscious control.) A reasonable scale for the period of normal human breathing is 3 seconds. Question B Given a respiratory period of 3 seconds/breath, what is the respiratory frequency in units of breaths/minute? 20 breaths/minuteExcellent! Right. Each breath takes 1/20th of a minute, which is 3 seconds, the period specified in the question. 3 breaths/minute︎✘ If this were true, each breath would take 20 seconds to complete. 1/3 breath per minute︎✘ With breaths completed every three seconds, 1/3 of a breath is completed each second. But the problem asked for breaths per minute. 20 seconds per breath︎✘ The period is in the units of seconds per breath, but the frequency will have units of breaths per second. Frequency is the reciprocal of period (and vice versa). Article accessed on May 30, 2021↩︎ Of course, pounds is a measure of force, not mass. But people use it as if it were mass. A mass of 70 kg corresponds to about 4.8 slugs. In Earth’s gravity, the mass 4.8 slugs produces a force of 154 pounds.↩︎ "],["projects-and-review.html", "Projects and review Block 1 Project 1: Ebola in Guinea, part I Block 1 Project 2: Orbit dimensions Block 1 Review", " Projects and review Block 1 Project 1: Ebola in Guinea, part I In December 2013, an 18-month-old boy from a village in Guinea suffered fatal diarrhea. Over the next months a broader outbreak was discovered, and in mid-March 2014, the Pasteur Institute in France confirmed the illness as Ebola-Virus Disease caused by the Zaire ebolavirus. Although the outbreak was first recognized in Guinea, it eventually encompassed Liberia and Sierra Leone as well. By July 2014, the outbreak spread to the capitals of all three countries. We are going to examine the time course of the epidemic using reports that were issued by the World Health Organization along with some concepts and techniques we have been studying in the first block of Math 141Z. Data are provided by the US Centers for Disease Control (CDC). Data The CDC data are provided to you as a dataframe named EbolaAll. The dataframe consists of 182 reports spread out over 18 months during 2014 and 2015. Each report is represented by a single row in the dataframe . Each report gives the number of new cases and disease-related deaths since the last report in each or three countries: Sierra Leon, Liberia, and Guinea. These values have been calculated from the raw, cumulative data. The data have been scrubbed to remove obvious errors. Exploring the Data We will begin by looking at some data. Use head(EbolaAll) to see the column headers and first 6 rows of data. As you can see, the EbolaAl dataframe is structured like a table, and each row contains multiple columns of data. The table below lists the column names found in EbolaAll dataframe along with a brief description of what the column records. Date: Date when the World Health Organization issued the report Gcases: Number of new cases in Guinea Gdeaths: Number of new deaths in Guinea Lcases: Number of new cases in Liberia Ldeaths: Number of new deaths in Liberia SLcases: Number of new cases in Sierra Leone SLdeaths: Number of new deaths in Sierra Leone TotCases: Total number of cases across all three countries TotDeaths: Total number of deaths across all three countries We will focus on the Guinea data. As we have done throughout this book, we model this data using the pattern-book functions. In a SANDBOX, use gf_point() to plot the number of new cases in Guinea (variables Date and Gcases in dataframe EbolaAll). **Question 1**: Look at the shape of the graph. Of the functions we have studied, which would be most appropriate as a model for the new cases in Guinea? If none of the functions we have studied best matches this data, select &quot;None of the above.&quot; Although we are tempted to regard data sets as definitive, they are the culmination of an imperfect process of data collection in the field and imperfect processing/correction/amendment by people. For instance, most of the cases (and deaths) in the epidemic were never confirmed by viral testing and are considered “suspected cases.” Cases and deaths reported on one day might possibly be from previous days, and some cases and deaths were, no doubt, not reported. In the Sandbox, run the following command to look at the data: DT::datatable(EbolaAll) The resulting display is interactive; you can page through the many rows of data. Question 2: Look through the data printout and find a data point form one of the World Health Organization reports that seems strange or inconsistent when compared with nearby reports. To receive full credit for this question, you must state the country and date of the report and explain your reasons for identifying this report as inconsistent. Data Wrangling An essential part of all projects involving data is to prepare the data for analysis: a process often called data wrangling. Although data wrangling is an important skill, it is not the topic of this book. So we will take care of the programming and present you with the results in the form of a data frame EbolaGuinea. The wrangling accomplished two things: averaging the data over 7-report windows and extracting a numerical “day number” from the Date of each report. First, rather than working with the year:month:day format of Date, it’s convenient to use a purely numerical quantity to represent time. So, we’ll translate the day when reports were issued into number of days from the initial report, presenting the result in the column Days. This makes the data-analysis programming easier, since all our mathematical software knows how to handle numbers, but not necessarily calendar dates. Second, we’re going to smooth the number of cases and the number of deaths. We did this by averaging each day’s number-of-cases and number-of deaths over several report. As you can see in the data, the interval between reports is not constant. Some reports occur just one day after the previous report; sometimes there is a week between reports. The widely spaced reports tend to have much higher cases and deaths than reports that come every day. This is for the simple reason that each report gives the number of new cases and deaths since the previous report; there’s more time for the numbers to accumulate when there is a wide spacing between reports. The data reflect not just the process of the Ebola epidemic, but also the way the data were collected and reported, which is not directly of interest to us. To reduce this report-to-report fluctuation, we’ll average the number of new cases in each report with the three reports before and three reports after: a moving average over seven reports. The result of our wrangling—the dataframe EbolaGuinea—includes three new columns: Days: When the report was issued in terms of a count of days from the initial report. G7Rcases: Number of new cases in Guinea averaged across 7 reports G7Rdeaths: Number of new deaths in Guinea averaged across 7 reports Analysis of the outbreak In your Sandbox, use gf_point() to plot the smoothed data in EbolaGuinea to show the time course of the epidemic. The variables you want to plot are G7Rcases versus Days. averaged number of new cases in Guinea (variables Days and G7Rcases in dataframe EbolaGuinea). Question 3 Look at the shape of the graph. Of the functions we have studied, which would be most appropriate as a model for the new cases in Guinea? If none of the functions we have studied best matches this data, select “None of the above.” It is well known that the infection rate during an outbreak follows a Gaussian pattern when the population interacts consistently. Ebola initially spreads exponentially as people pass the virus to one another. As people are exposed to the virus, there are fewer and fewer people who are still susceptible. The result is that the rate of exponential growth slows and, when the fraction of the population that is susceptible becomes small, the epidemic slows down and the number of new cases decays exponentially. Overall, the pattern of new cases day-by-day looks like a gaussian: zero cases per day before the outputbreak, exponential growth at first after the virus is introduced to the population, leveling out for a time, and exponential decay back to zero new cases. The graph of G7Rcases versus Days looks only vaguely like a gaussian hump. One possible explanation is that the data summarize more than one outbreak, as the virus spreads from one region to another. We’ll treat each individual output as a gaussian and try to figure out how many of them make up the whole data. The individual outbreaks will be modelled as a gaussian function with it’s own center and width. The center for each gaussian corresponds to the peak of the hypothesized outbreak in one particular region. We’ll combine the several gaussians in a linear combination. The scalar multiplying each gaussian is related to the size of the population exposed in each outbreak. Here is an R/mosaic definition of a linear combination of two gaussian outbreaks. my_mod &lt;- makeFun(15800*(A*dnorm(t,m1,sd1) + (1-A)*dnorm(t,m2,sd2)) ~ t) There are five parameters in the function. m1 the time when the first hypothesized outbreak peaked, m2 is the peak time of the second hypothesized outbreaks, and sd1 and sd2 reflect the duration of each outbreak. The parameter A represents the relative population sizes of the two regions. The number 15,800 reflects the total number of cases, which we know retrospectively. (The 15,800 includes a correction for the average day spacing between reports, but that detail need not concern us here.) Note that selecting A sets the amplitude for both Gaussians, i.e. A and 1−A. The amplitudes A and 1-A sum up to 1. Arranging things this way effectively make A the size of the one outbreak, leaving 1-A to be the size of the other outbreak. To see how these Gaussians work together, start with the following values: A = 0.5, m1 = 150, sd1 = 50, m2 = 350, sd2 = 50. Do not change the 15800 number which reflects the overall size of the whole outbreak, as opposed to the relative size of the hypothesized individual outbreaks: A and 1-A. Use gf_point(), the pipe operator %&gt;%, and slice_plot() to overlay your model on top of the data. Discrepancies between the model and the data can lead you to improve the model by adjusting the parameters. It’s to be expected that you will need several cycles of such parameter adjustments until you find a model that seems to agree with the data in a satisfactory way. to you Guinea cases along with your model. Once you have adjusted your model to match the data as closely as you can, write down the parameters you used in your report, as well as the graph comparing the data to your final model. Question 3: Find the longest time interval during which your model systematically overstates the number of cases. What’s the start and end of that interval? (Your answer can be rough, just so long as it points the reader of your report to the interval you mean.) More data smoothing Accurately modeling the Guinea case data with two gaussian functions is difficult. Despite the smoothing, the numbers in G7Rcases fluctuate irregularly and substantially from report to report. Another way to smooth the data, that is, to reduce the irregular report-to-report fluctuations, is to accumulate the number of new cases to get the total number of cases up through each report. (This accumulation, at the end of the epidemic, will be the total number of people who came down with Ebola illness.) Such a sum of new cases from the beginning of the outbreak through the day of each report is called a cumulative sum or “running total.” Keep in mind that this is not a number, but a new column of data giving the number of cases to date for each of the dates in the data. To illustrate, the small set of numbers: [1 2 3 4 5 6]. The cumulative sum of this set shows the running total: [1 3 6 10 15 21]. Make sure you are comfortable with how the second set of numbers is related to the first. The R function cumsum() calculates the cumulative sum on a column of data. You are going to need to do a little data wrangling; we can’t do it for you because we don’t know what model you decided to settle on. There are many computer systems for data wrangling. You may have heard of one called Structured Query Language (SQL) which is a required skill listed in many job listings and a multi-billion dollar component of the economy. We will use a system called dplyr specially designed for the R language. In the dplyr system, the function mutate() is used to create a new column in a data frame by carrying out calculations on the existing columns. Here is an R/dplyr command to generate the running total of cases. (We’re using Gcases instead of the smoothed G7Rcases because the cumulative summing will do the smoothing for us.) EbolaGuinea &lt;- EbolaGuinea %&gt;% mutate(GcasesTotal = cumsum(Gcases)) It’s worthwhile to parse that command carefully. The part to the right of &lt;- is an instruction for taking the EbolaGuinea data frame and adding a new column. The new column will be called GcasesTotal. The values in the new column will be generated by applying cumsum() to the Gcases column. Altogether, the right-hand side of the statement creates a new data frame that includes the new column. The left-hand side of the statement stores this new data frame under a name. For convenience, we’re using EbolaGuinea as that name. Effectively, the command as a whole, including the name assignment EbolaGuinea &lt;- can be seen as updating the data frame with the new column. You can verify that the new column is in place by showing the first several lines of the updated data frame: head(EbolaGuinea) Use gf_point() to plot GCasesTotal versus Days. The graph will show how the number of cases accumulated over time to to the overall total for the epidemic as a whole. Question 5: Consider which of the functions we have studied could be fitted to represent the GCasesTotal versus Days curve in your graph? It’s likely that none of the functions we have studied fits the data particularly well, but one of them will be better than the others. We haven’t forgotten that you already created a model of the new cases by a linear combination of gaussian functions. What we want to do now is translate your model for the number of new cases each day into a model of the cumulative number of cases to date. In other words, we want to perform the same action that cumsum() does, but applied to your model rather than data. To do this, you will replace the gaussian dnorm() function in your model with the sigmoidal pnorm(). No other changes are needed. This works because the gaussian and sigmoid functions are related to one another in just the same way as cumsum() relates the GCases column to the GCasesTotal column. Remember that the Gaussian and sigmoid functions are related to one another. The sigmoid is the accumulation of the Gaussian, i.e. it is the cumulative sum of the Gaussian. We will use this relationship to improve your double Gaussian model. Create a new function in your sandbox called my_mod_cumulative(). Plot this new function over the GCasesTotal versus Dates data. As before, you can do this with gf_point(), the pipe operator %&gt;%, and slice_plot(). Question 6: Observe the rate of change (slope) of your model. The rate of change represents the number of new infections per day. Find the day on which your rate of change is greatest. Describe how this is related to the argmax of your model from Question 4. Try adjusting the parameters in my_mod_cumulative() to better match the function to the GCasesTotal data. Some aspects of the outbreak can be better seen from the cumulative number of cases to date, and other aspects may be better seen with the-newcases-each-day data. Now we will leverage the relationship between the Gaussian and sigmoid functions. Adjust your double Gaussian model and use the Question6 cumulative sums graph to evaluate your modifications. The procedure is outlined here: Final thoughts The gaussian as a model for the time course of new cases, and the sigmoid for the time course of accumulated cases to date, are well established. But here we’ve used two gaussians (or, equivalently, two sigmoids). So was there one outbreak or two? Question 7: Think about why the two-gaussian model matches the data better than the one-gaussian model. What might this mean in terms of the structure of the Ebola outbreak in Guinea? Don’t be afraid to speculate and frame your answer in terms that a layman might understand. The modeling cycle is all about using your current model to identify ways that you might be able to improve the model. Of course, in practice, you need to present your model for use, so you have to exit the cycle at some point. You’re at that point now, but we ask you to reflect a bit more. Question 8: Given the results of your modeling efforts and your answer to Question 7, might it be better to model the outbreak using 3 or 4 Gaussians in our linear combination? What are the challenges associated with using more Gaussians? Question 9: The EbolaAll data frame records the Sierra Leone and Liberia outbreaks as well as the outbreak in Guinea. How might you use that additional data to explore the validity of your modeling process? Authors: Prof. Robert Wolverson, USAFA &amp; Daniel Kaplan, Macalester College and USAFA. Block 1 Project 2: Orbit dimensions This activity will apply some of the concepts and techniques you’re learning to answer the following question: How fast does a satellite move along its orbit? As you can imagine, the answer is already known and you could look it up. The point of our reconstructing what is already known is to see the totality of a modeling project, even if it is a very simple one. In textbooks and in-class demonstrations, students are often shown complete, flawless models. In reality, model construction is a matter of trial and error. Whoops! We’re supposed to say “modeling cycle.” That phrase doesn’t suggest anything about “error.” But in reality, modelers make mistakes, operate under misconceptions, collect erroneous data, misunderstand the purpose of building a model, and make all sorts of mistakes. To cope with this unhappy situation, good modelers are constantly checking and testing their models for inconsistencies. To start, you should have A good idea of what the eventual answer will be. Often, that idea comes from somewhat vague and imprecise knowledge. For example, you may have heard that it takes a satellite in low orbit about 90 minutes to complete one circuit of the Earth. You may also know that the length of the equator is roughly 40,000 kilometers. (This is actually the original definition of the meter.) A velocity is distance traveled over time, so a satellite in low orbit has a velocity of roughly \\(40000 / 90\\) km/minute, which comes out to 7400 meters/second. A theory that relates what you want to know to what you already know. For our purposes, that theory comes directly from Isaac Newton in the 1680s: his laws of motion and his theory of universal gravitation. The theory We won’t assume that you have anything more than a vague understanding of Newton’s laws and theory of gravitation. The diagram shows the situation schematically. The satellite is traveling clockwise along a curved trajectory encircling the Earth. The position of the satellite is shown at several times by the numbered blue dots. Let’s focus on the satellite at time 1. The satellite is an object in motion. Newton’s First Law (“Lex I”) is stated in his 1687 book, Philosophiae Naturis Principia Mathematica (Mathematical principles of natural philosophy) on p.12 Translating into English, this is Law I: Every body persists in its state of rest or uniform motion in a straight line, unless compelled to change that motion by forces impressed upon it. The dashed line connecting the points labeled 1 and 2’ shows the path that the satellite would follow if there were no forces impressed upon it. Yet there is a force impressed on the satellite: the gravitational attraction between the Earth and the satellite. This force accelerates the satellite perpendicular to its orbit (toward the center of the Earth) causing the satellite to follow a curved path rather than a straight path off into deep space. The acceleration of the satellite traveling at constant speed in orbit depends on both the velocity \\(v\\) of the satellite and the radius \\(r\\) of its orbit. Task #1: Let \\(A_1\\) be the acceleration needed to keep the satellite in a circular orbit. Find a plausible relationship between \\(A_1\\), \\(r\\), and \\(v\\). One possibility is that the relationship is a general product of the form \\[A_1 = v^n\\ r^m .\\] Use dimensional analysis to find \\(n\\) and \\(m\\). Recall that acceleration has dimension L/T\\(^{2}\\), velocity has dimension \\(L/T\\) and radius has dimension L. Once you determine \\(n\\) and \\(m\\), write down the relationship \\(A_1\\) as a function of \\(r\\) and \\(v\\). As we all know, gravity pulls all objects toward the center of the Earth. The acceleration \\(A_2\\) due to gravity on an object a distance \\(r\\) from the enter of the Earth is proportional to the mass of the Earth and is known to be \\[A_2 = G\\ M_e/r^2\\] where \\(G\\) is a constant of proportionality and \\(M_e\\) is the mass of Earth. In order for the satellite to stay in orbit, the two accelerations \\(A_1\\) (what’s needed to stay in orbit) and \\(A_2\\) (what the Earth’s gravity provides) must be equal. Task #2: Set your expression for \\(A_1\\) equal to the expression for \\(A_2\\) and solve for the velocity \\(v\\) of the satellite (our original objective for this exercise). Your answer will involve \\(G\\), \\(M_e\\), and \\(r\\). Use the known numerical values for \\(G\\) and \\(M_e\\) given in the next section to check that your answer makes sense. The data The data here come from scientific observations made over centuries that give us numerical values (with units) of \\(M_e\\) and \\(G\\) in the theory. \\(G\\) is a universal constant (according to Newton’s theory of gravitation). The quantity is given by several sources as \\[G = 6.674 \\times 10^{-11} m^3 /(s^2 kg).\\] Similarly, the mass of the Earth is given as \\[M_e = 5.972 × 10^{24} kg\\] These reported facts seem plausible, but it’s a good practice to check. Toward that end, check The dimension and units of \\(A_2(v, r)\\) are consistent. The value of \\(A_2\\) at the Earth’s surface is consistent with the famous value 9.8 m/s\\(^2\\). Task #3: Finishing up. Use the formula you derived for \\(v\\) as a function of \\(r\\), \\(G\\), and \\(M_e\\) to find \\(v\\) for a satellite in low orbit around the Earth. The official extent of the “Low Earth Orbit Region” is up to 2000 km. If you were using the altitude of the International Space Station (400 km), you would set \\(r = r_e + 400km\\), where \\(r_e\\) is the radius of the earth: 6, 378.1 km. As always, you want to do the calculation in a way that helps you to spot possible errors. Here are two good practices: You have already confirmed (or should have) that your formula for \\(v\\) as a function of \\(r\\), \\(G\\), and \\(M_e\\) is dimensionally consistent. As you plug in numerical values for \\(r\\), \\(G\\), and \\(M_e\\), make sure to keep track of the units explicitly and that the result you get has proper units for velocity. Compare your result to the rough estimate of \\(v\\) for satellites in low orbit that you made at the beginning of this activity. If there is a discrepancy, review both your initial rough estimate as well as your gravity-based derivation of \\(v\\) to figure out where the inconsistency comes from. Then fix it. Block 1 Review "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
